#!/usr/bin/perl -w


BEGIN {
	$ENV{PERL_LWP_SSL_VERIFY_HOSTNAME} = 0;
	eval 'require Unix::Syslog;';
	if (!$@) {
		require Unix::Syslog;
		Unix::Syslog->import(qw(:subs :macros));
	}
}

use strict;
use VMware::VIRuntime;
use VMware::VILib;
use IO::Socket;
use Net::hostent; # for OOish version of gethostbyaddr
use IO::Select;
use POSIX ":sys_wait_h";
use Data::Dumper;

use vars qw($port $service_url $username $password $TIMEOUT_VSPHERE $TIMEOUT $TIMEOUT_KILL $REFRESH_KEEPER_SESSION);
use vars qw($LOG $log_mode $log_crit $log_facility);
use constant {
	LOG_ESXD_ERROR => 1,
	LOG_ESXD_INFO  => 2
};

require '/etc/centreon/centreon_esxd.pm';

our $session_id;
our %sockets = ();
our %child_proc;
our %return_child;
our $vsphere_connected = 0;
our $last_time_vsphere;
our $keeper_session_time;
our $last_time_check;
our $perfmanager_view;
our %perfcounter_cache;
our %perfcounter_cache_reverse;
our $perfcounter_refreshrate = 20;
our $perfcounter_speriod = -1;
our $stop = 0;
our $counter_request_id = 0;
our $child_vpshere_pid;
our $read_select;
our $reader_pipe_one;
our $writer_pipe_one;
our $reader_pipe_two;
our $writer_pipe_two;
our $session1;
our $counter = 0;
our $global_id;

our %ERRORS = ( "OK" => 0, "WARNING" => 1, "CRITICAL" => 2, "UNKNOWN" => 3, "PENDING" => 4);
our %MYERRORS = (0 => "OK", 1 => "WARNING", 3 => "CRITICAL", 7 => "UNKNOWN");
our %MYERRORS_MASK = ("CRITICAL" => 3, "WARNING" => 1, "UNKNOWN" => 7, "OK" => 0);
our %checks_descr = (
			"healthhost" => {'arg' => \&healthhost_check_args, 'compute' => \&healthhost_compute_args, 'exec' => \&healthhost_do},
			"datastores" => {'arg' => \&datastores_check_args, 'compute' => \&datastores_compute_args, 'exec' => \&datastores_do},
			"maintenancehost" => {'arg' => \&maintenancehost_check_args, 'compute' => \&maintenancehost_compute_args, 'exec' => \&maintenancehost_do},
			"statushost" => {'arg' => \&statushost_check_args, 'compute' => \&statushost_compute_args, 'exec' => \&statushost_do},
			"cpuhost" => {'arg' => \&cpuhost_check_args, 'compute' => \&cpuhost_compute_args, 'exec' => \&cpuhost_do},
			"nethost" => {'arg' => \&nethost_check_args, 'compute' => \&nethost_compute_args, 'exec' => \&nethost_do},
			"memhost" => {'arg' => \&memhost_check_args, 'compute' => \&memhost_compute_args, 'exec' => \&memhost_do},
			"swaphost" => {'arg' => \&swaphost_check_args, 'compute' => \&swaphost_compute_args, 'exec' => \&swaphost_do},
			"listhost" => {'arg' => \&listhost_check_args, 'compute' => \&listhost_compute_args, 'exec' => \&listhost_do},
			"listdatastore" => {'arg' => \&listdatastore_check_args, 'compute' => \&listdatastore_compute_args, 'exec' => \&listdatastore_do},
			"listnichost" => {'arg' => \&listnichost_check_args, 'compute' => \&listnichost_compute_args, 'exec' => \&listnichost_do},
			"getmap" => {'arg' => \&getmap_check_args, 'compute' => \&getmap_compute_args, 'exec' => \&getmap_do}
		    ); 

sub writeLogFile($$) {
	if (($log_crit & $_[0]) == 0) {
		return ;
	}
	if ($log_mode == 0) {
		print $_[1];
	} elsif ($log_mode == 1) {
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time());
		open (LOG, ">> ".$LOG) || print "can't write $LOG: $!";
		printf LOG "%04d-%02d-%02d %02d:%02d:%02d - %s", $year+1900, $mon+1, $mday, $hour, $min, $sec, $_[1];
		close LOG;
	} elsif ($log_mode == 2) {
		syslog LOG_ERR, $_[1] if ($_[0] == LOG_ESXD_ERROR);
		syslog LOG_INFO, $_[1] if ($_[0] == LOG_ESXD_INFO);
	}
}

sub connect_vsphere {
	writeLogFile(LOG_ESXD_INFO, "Vsphere connection in progress\n");
	eval {
		$SIG{ALRM} = sub { die('TIMEOUT'); };
		alarm($TIMEOUT_VSPHERE);
		$session1 = Vim->new(service_url => $service_url);
		$session1->login(
        		user_name => $username,
        		password => $password);
		alarm(0);
	};
	if($@) {
		writeLogFile(LOG_ESXD_ERROR, "No response from VirtualCentre server\n") if($@ =~ /TIMEOUT/);
		writeLogFile(LOG_ESXD_ERROR, "You need to upgrade HTTP::Message!\n") if($@ =~ /HTTP::Message/);
		writeLogFile(LOG_ESXD_ERROR, "Login to VirtualCentre server failed: $@");
		return 1;
	}
#	eval {
#		$session_id = Vim::get_session_id();
#	};
#	if($@) {
#		writeLogFile("Can't get session_id: $@\n");
#		return 1;
#	}
	return 0;
}

sub print_response {
	print "$global_id|" . $_[0];
}

sub output_add($$$$) {
	my ($output_str, $output_append, $delim, $str) = (shift, shift, shift, shift);
	$$output_str .= $$output_append . $str;
	$$output_append = $delim;
}

sub simplify_number{
	my ($number, $cnt) = @_;
	$cnt = 2 if (!defined($cnt));
	return sprintf("%.${cnt}f", "$number");
}

sub convert_number {
	my ($number) = shift(@_);
	$number =~ s/\,/\./;
	return $number;
}

sub get_views {
	my $results;

	eval {
		$results = $session1->get_views(mo_ref_array => $_[0], properties => $_[1]);
	};
	if ($@) {
		writeLogFile(LOG_ESXD_ERROR, "$@");
		my $lerror = $@;
		$lerror =~ s/\n/ /g;
		print_response("-1|Error: " . $lerror . "\n");
		return undef;
	}
	return $results;
}

sub get_perf_metric_ids {
	my $perf_names = $_[0];
	my @filtered_list;
   
	foreach (@$perf_names) {
		if (defined($perfcounter_cache{$_->{'label'}})) {
			foreach my $instance (@{$_->{'instances'}}) {
				my $metric = PerfMetricId->new(counterId => $perfcounter_cache{$_->{'label'}}{'key'},
							       instance => $instance);
				push @filtered_list, $metric;
			}
		} else {
			writeLogFile(LOG_ESXD_ERROR, "Metric '" . $_->{'label'} . "' unavailable.\n");
		}
	}
	return \@filtered_list;
}

sub generic_performance_values_historic {
	my ($view, $perfs, $interval) = @_;
	my $counter = 0;
	my %results;

	eval {
		my @perf_metric_ids = get_perf_metric_ids($perfs);

		my (@t) = gmtime(time() - $interval);
		my $start = sprintf("%04d-%02d-%02dT%02d:%02d:00Z",
			(1900+$t[5]),(1+$t[4]),$t[3],$t[2],$t[1]);
 		my $perf_query_spec = PerfQuerySpec->new(entity => $view,
					 metricId => @perf_metric_ids,
					 format => 'normal',
					 intervalId => $interval,
					 startTime => $start
					);
					#maxSample => 1);
		my $perfdata = $perfmanager_view->QueryPerf(querySpec => $perf_query_spec);
		foreach (@{$$perfdata[0]->value}) {
			$results{$_->id->counterId . ":" . (defined($_->id->instance) ? $_->id->instance : "")} = $_->value;
		}
	};
	if ($@) {
		writeLogFile(LOG_ESXD_ERROR, "$@");
		return undef;
	}
	return \%results;
}

sub cache_perf_counters {
	eval {
		$perfmanager_view = $session1->get_view(mo_ref => $session1->get_service_content()->perfManager, properties => ['perfCounter', 'historicalInterval']);
		foreach (@{$perfmanager_view->perfCounter}) {
			my $label = $_->groupInfo->key . "." . $_->nameInfo->key . "." . $_->rollupType->val;
			$perfcounter_cache{$label} = {'key' => $_->key, 'unitkey' => $_->unitInfo->key};
			$perfcounter_cache_reverse{$_->key} = $label;
		}

		my $historical_intervals = $perfmanager_view->historicalInterval;

		foreach (@$historical_intervals) {
			if ($perfcounter_speriod == -1 || $perfcounter_speriod > $_->samplingPeriod) {
				$perfcounter_speriod = $_->samplingPeriod;
			}
		}
	};
	if ($@) {
		writeLogFile(LOG_ESXD_ERROR, "$@");
		return 1;
	}
	return 0;
}

sub get_entities_host {
	my ($view_type, $filters, $properties) = @_;
	my $entity_views;

	eval {
		$entity_views = $session1->find_entity_views(view_type => $view_type, properties => $properties, filter => $filters);
	};
	if ($@ =~ /decryption failed or bad record mac/) {
		writeLogFile(LOG_ESXD_ERROR, "$@");
		eval {
			$entity_views = $session1->find_entity_views(view_type => $view_type, properties => $properties, filter => $filters);
		};
		if ($@) {
			writeLogFile(LOG_ESXD_ERROR, "$@");
			my $lerror = $@;
			$lerror =~ s/\n/ /g;
			print_response("-1|Error: " . Data::Dumper::Dumper($lerror) . "\n");
			return undef;
		}
	} elsif ($@) {
		writeLogFile(LOG_ESXD_ERROR, "$@");
		my $lerror = $@;
		$lerror =~ s/\n/ /g;
		print_response("-1|Error: " . $lerror . "\n");
		return undef;
	}
	if (!@$entity_views) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
		print_response($ERRORS{$MYERRORS{$status}} . "|Host does not exist.\n");
		return undef;
	}
	#eval {
	#	$$entity_views[0]->update_view_data(properties => $properties);
	#};
	#if ($@) {
	#	writeLogFile("$@");
	#	my $lerror = $@;
	#	$lerror =~ s/\n/ /g;
	#	print "-1|Error: " . $lerror . "\n";
	#	return undef;
	#}
	return $entity_views;
}

##############
# Health Function
##############

sub healthhost_check_args {
	my ($host) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	return 0;
}

sub healthhost_compute_args {
	my $lhost = $_[0];
	return ($lhost);
}

sub healthhost_do {
	my ($lhost) = @_;

	my %filters = ('name' => $lhost);
	my @properties = ('runtime.healthSystemRuntime.hardwareStatusInfo.cpuStatusInfo', 'runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}
	
	my $status = 0; # OK
	my $output_critical = '';
	my $output_critical_append = '';
	my $output_warning = '';
	my $output_warning_append = '';
	my $output = '';
	my $output_append = '';
	my $OKCount = 0;
	my $CAlertCount = 0;
	my $WAlertCount = 0;
	foreach my $entity_view (@$result) {
    		my $cpuStatusInfo = $entity_view->{'runtime.healthSystemRuntime.hardwareStatusInfo.cpuStatusInfo'};
		my $numericSensorInfo = $entity_view->{'runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo'};
		if (!defined($cpuStatusInfo)) {
			$status |= $MYERRORS_MASK{'CRITICAL'};
			output_add(\$output_critical, \$output_critical_append, ", ",
				"API error - unable to get cpuStatusInfo");
		}
		if (!defined($numericSensorInfo)) {
			$status |= $MYERRORS_MASK{'CRITICAL'};
			output_add(\$output_critical, \$output_critical_append, ", ",
				"API error - unable to get numericSensorInfo");
		}

		# CPU
		foreach (@$cpuStatusInfo) {
			if ($_->status->key =~ /^red$/i) {
				output_add(\$output_critical, \$output_critical_append, ", ",
					$_->name . ": " . $_->status->summary);
				$status |= $MYERRORS_MASK{'CRITICAL'};
				$CAlertCount++;
			} elsif ($_->status->key =~ /^yellow$/i) {
				output_add(\$output_warning, \$output_warning_append, ", ",
					$_->name . ": " . $_->status->summary);
				$status |= $MYERRORS_MASK{'WARNING'};
				$WAlertCount++;
			} else {
				$OKCount++;
			}
		}
		# Sensor
		foreach (@$numericSensorInfo) {
			if ($_->healthState->key =~ /^red$/i) {
				output_add(\$output_critical, \$output_critical_append, ", ",
					$_->sensorType . " sensor " . $_->name . ": ".$_->healthState->summary);
				$status |= $MYERRORS_MASK{'CRITICAL'};
				$CAlertCount++;
			} elsif ($_->healthState->key =~ /^yellow$/i) {
				output_add(\$output_warning, \$output_warning_append, ", ",
					$_->sensorType . " sensor " . $_->name . ": ".$_->healthState->summary);
				$status |= $MYERRORS_MASK{'WARNING'};
				$WAlertCount++;
			} else {
				$OKCount++;
			}
		}
	}

	if ($output_critical ne "") {
		$output .= $output_append . "CRITICAL - $CAlertCount health issue(s) found: $output_critical";
		$output_append = ". ";
	}
	if ($output_warning ne "") {
		$output .= $output_append . "WARNING - $WAlertCount health issue(s) found: $output_warning";
	}
	if ($status == 0) {
		$output = "All $OKCount health checks are green";
	}
	
	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# Datastores Function
############

sub datastores_check_args {
	my ($ds, $warn, $crit) = @_;
	if (!defined($ds) || $ds eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need datastore name\n");
		return 1;
	}
	if (defined($warn) && $warn !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be a positive number\n");
		return 1;
	} 
	if (defined($crit) && $crit !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: crit threshold must be a positive number\n");
		return 1;
	}
	if (defined($warn) && defined($crit) && $warn > $crit) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be lower than crit threshold\n");
		return 1;
	}
	return 0;
}

sub datastores_compute_args {
	my $ds = $_[0];
	my $warn = (defined($_[1]) ? $_[1] : 80);
	my $crit = (defined($_[2]) ? $_[2] : 90);
	return ($ds, $warn, $crit);
}

sub datastores_do {
	my ($ds, $warn, $crit) = @_;
	my %filters = ();
	my @properties = ('datastore');

	my $result = get_entities_host('Datacenter', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my @ds_array = ();
	foreach my $entity_view (@$result) {
		if (defined $entity_view->datastore) {
	 		   @ds_array = (@ds_array, @{$entity_view->datastore});
		}
	}

	@properties = ('summary');
	$result = get_views(\@ds_array, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $ds_find;
	foreach my $datastore (@$result) {
		if ($datastore->summary->accessible && $datastore->summary->name eq $ds) {
			$ds_find = $datastore;
			last;	
		}
	}

	my $output = '';
	my $status = 0; # OK
	if (defined($ds_find)) {
		my $dsName = $ds_find->summary->name;
		my $capacity = $ds_find->summary->capacity;
		my $free = $ds_find->summary->freeSpace;
		my $pct = ($capacity - $free) / $capacity * 100;

		my $usedD = ($capacity - $free) / 1024 / 1024 / 1024;
		my $sizeD = $capacity / 1024 / 1024 / 1024;
	
		$output = "Datastore $dsName - used ".sprintf("%.2f", $usedD)." Go / ".sprintf("%.2f", $sizeD)." Go (".sprintf("%.2f", $pct)." %) |used=".($capacity - $free)."o;;;0;".$capacity." size=".$capacity."o\n";
		if ($pct >= $warn) {
			$status |= $MYERRORS_MASK{'WARNING'};
		}
		if ($pct > $crit) {
			$status |= $MYERRORS_MASK{'CRITICAL'};
		}
	} else {
		$output = "Datastore '$ds' not found or summary not accessible.";
		$status |= $MYERRORS_MASK{'UNKNOWN'};
	}
	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# Maintenance Func
############

sub maintenancehost_check_args {
	my ($host) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	return 0;
}

sub maintenancehost_compute_args {
	my $lhost = $_[0];
	return ($lhost);
}

sub maintenancehost_do {
	my ($lhost) = @_;
	my %filters = ('name' => $lhost);
	my @properties = ('runtime.inMaintenanceMode');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output = '';

	foreach my $entity_view (@$result) {
		if ($entity_view->{'runtime.inMaintenanceMode'} ne "false") {
			$status |= $MYERRORS_MASK{'CRITICAL'};
			$output = "Server $lhost is on maintenance mode.";
		} else {
			$output = "Server $lhost is not on maintenance mode.";
		}
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# Status Func
############

sub statushost_check_args {
	my ($host) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	return 0;
}

sub statushost_compute_args {
	my $lhost = $_[0];
	return ($lhost);
}

sub statushost_do {
	my ($lhost) = @_;
	my %filters = ('name' => $lhost);
	my @properties = ('summary.overallStatus');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output = '';

	my %overallStatus = (
		'gray' => 'status is unknown',
 		'green' => 'is OK',
		'red' => 'has a problem',
		'yellow' => 'might have a problem',
	);
	my %overallStatusReturn = (
		'gray' => 'UNKNOWN',
		'green' => 'OK',
		'red' => 'CRITICAL',
		'yellow' => 'WARNING'
	);

	foreach my $entity_view (@$result) {
		my $status = $entity_view->{'summary.overallStatus'}->val;

		if (defined($status) && $overallStatus{$status}) {
			$output = "The Server '$lhost' " . $overallStatus{$status};
			if ($MYERRORS_MASK{$overallStatusReturn{$status}} != 0) {
				$status |= $MYERRORS_MASK{$overallStatusReturn{$status}};
			}
		} else {
			$output = "Can't interpret data...";
			$status |= $MYERRORS_MASK{'UNKNOWN'};
		}
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# CPUHost Func
############

sub cpuhost_check_args {
	my ($host, $warn, $crit) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	if (defined($warn) && $warn !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be a positive number\n");
		return 1;
	} 
	if (defined($crit) && $crit !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: crit threshold must be a positive number\n");
		return 1;
	}
	if (defined($warn) && defined($crit) && $warn > $crit) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be lower than crit threshold\n");
		return 1;
	}
	return 0;
}

sub cpuhost_compute_args {
	my $lhost = $_[0];
	my $warn = (defined($_[1]) ? $_[1] : 80);
	my $crit = (defined($_[2]) ? $_[2] : 90);
	return ($lhost, $warn, $crit);
}

sub cpuhost_do {
	my ($lhost, $warn, $crit) = @_;
	if (!($perfcounter_speriod > 0)) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
		print_response($ERRORS{$MYERRORS{$status}} . "|Can't retrieve perf counters.\n");
		return ;
	}

	my %filters = ('name' => $lhost);
	my @properties = ('hardware.cpuInfo.numCpuThreads');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my @instances = ('*');
	foreach my $index (0..($$result[0]->{'hardware.cpuInfo.numCpuThreads'} - 1)) {
		push @instances, $index;
	}


	my $values = generic_performance_values_historic($$result[0], 
						[{'label' => 'cpu.usage.average', 'instances' => \@instances}],
						$perfcounter_speriod);

	my $status = 0; # OK
	my $output = '';
	my $total_cpu_average = simplify_number(convert_number($values->{$perfcounter_cache{'cpu.usage.average'}->{'key'} . ":"}[0] * 0.01));
	
	if ($total_cpu_average >= $warn) {
		$status |= $MYERRORS_MASK{'WARNING'};
	}
	if ($total_cpu_average >= $crit) {
		$status |= $MYERRORS_MASK{'CRITICAL'};
	}

	$output = "Total Average CPU usage '$total_cpu_average%' on last " . ($perfcounter_speriod / 60) . "min | cpu_total=$total_cpu_average%;$warn;$crit;0;100";

	foreach my $id (sort { my ($cida, $cia) = split /:/, $a;
			       my ($cidb, $cib) = split /:/, $b;
                               $cia = -1 if (!defined($cia) || $cia eq "");
                               $cib = -1 if (!defined($cib) || $cib eq "");
			       $cia <=> $cib} keys %$values) {
		my ($counter_id, $instance) = split /:/, $id;
		if ($instance ne "") {
			$output .= " cpu$instance=" . simplify_number(convert_number($values->{$id}[0]) * 0.01) . "%;;0;100";
		}
	}
	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# NetHost Func
############

sub nethost_check_args {
	my ($host, $pnic, $warn, $crit) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	if (!defined($pnic) || $pnic eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need physical nic name\n");
		return 1;
	}
	if (defined($warn) && $warn !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be a positive number\n");
		return 1;
	}
	if (defined($crit) && $crit !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: crit threshold must be a positive number\n");
		return 1;
	}
	if (defined($warn) && defined($crit) && $warn > $crit) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be lower than crit threshold\n");
		return 1;
	}
	return 0;
}

sub nethost_compute_args {
	my $lhost = $_[0];
	my $pnic = $_[1];
	my $warn = (defined($_[2]) ? $_[2] : 80);
	my $crit = (defined($_[3]) ? $_[3] : 90);
	return ($lhost, $pnic, $warn, $crit);
}

sub nethost_do {
	my ($lhost, $pnic, $warn, $crit) = @_;
	if (!($perfcounter_speriod > 0)) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
		print_response($ERRORS{$MYERRORS{$status}} . "|Can't retrieve perf counters.\n");
		return ;
	}

	my %filters = ('name' => $lhost);
	my @properties = ('config.network.pnic');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}
	my %pnic_def = ();
	foreach (@{$$result[0]->{'config.network.pnic'}}) {
		if (defined($_->linkSpeed)) {
			$pnic_def{$_->device} = $_->linkSpeed->speedMb;
		}
	}

	if (!defined($pnic_def{$pnic})) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
                print $ERRORS{$MYERRORS{$status}} . "|Link '$pnic' not exist or down.\n";
		return ;
	}


	my $values = generic_performance_values_historic($$result[0], 
						[{'label' => 'net.received.average', 'instances' => [$pnic]},
						 {'label' => 'net.transmitted.average', 'instances' => [$pnic]}],
						$perfcounter_speriod);

	my $traffic_in = simplify_number(convert_number($values->{$perfcounter_cache{'net.received.average'}->{'key'} . ":" . $pnic}[0]));	
	my $traffic_out = simplify_number(convert_number($values->{$perfcounter_cache{'net.transmitted.average'}->{'key'} . ":" . $pnic}[0]));
	my $status = 0; # OK
	my $output = '';
	
	if (($traffic_in / 1024 * 8 * 100 / $pnic_def{$pnic}) >= $warn || ($traffic_out / 1024 * 8 * 100 / $pnic_def{$pnic}) >= $warn) {
		$status |= $MYERRORS_MASK{'WARNING'};
	}
	if (($traffic_in / 1024 * 8 * 100 / $pnic_def{$pnic}) >= $crit || ($traffic_out / 1024 * 8 * 100 / $pnic_def{$pnic}) >= $crit) {
		$status |= $MYERRORS_MASK{'CRITICAL'};
	}

	$output = "Traffic In : " . simplify_number($traffic_in / 1024 * 8) . " Mb/s (" . simplify_number($traffic_in / 1024 * 8 * 100 / $pnic_def{$pnic}) . " %), Out : " . simplify_number($traffic_out / 1024 * 8) . " Mb/s (" . simplify_number($traffic_out / 1024 * 8 * 100 / $pnic_def{$pnic}) . " %)";
	$output .= "|traffic_in=" . ($traffic_in * 1024 * 8) . "b/s traffic_out=" . (($traffic_out * 1024 * 8)) . "b/s";

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# MemHost Func
############

sub memhost_check_args {
	my ($host, $warn, $crit) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	if (defined($warn) && $warn !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be a positive number\n");
		return 1;
	}
	if (defined($crit) && $crit !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: crit threshold must be a positive number\n");
		return 1;
	}
	if (defined($warn) && defined($crit) && $warn > $crit) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be lower than crit threshold\n");
		return 1;
	}
	return 0;
}

sub memhost_compute_args {
	my $lhost = $_[0];
	my $warn = (defined($_[1]) ? $_[1] : 80);
	my $crit = (defined($_[2]) ? $_[2] : 90);
	return ($lhost, $warn, $crit);
}

sub memhost_do {
	my ($lhost, $warn, $crit) = @_;
	if (!($perfcounter_speriod > 0)) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
		print_response($ERRORS{$MYERRORS{$status}} . "|Can't retrieve perf counters.\n");
		return ;
	}

	my %filters = ('name' => $lhost);
	my @properties = ('summary.hardware.memorySize');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $memory_size = $$result[0]->{'summary.hardware.memorySize'};


	my $values = generic_performance_values_historic($$result[0], 
						[{'label' => 'mem.consumed.average', 'instances' => ['']},
						 {'label' => 'mem.overhead.average', 'instances' => ['']}],
						$perfcounter_speriod);

	my $mem_used = simplify_number(convert_number($values->{$perfcounter_cache{'mem.consumed.average'}->{'key'} . ":"}[0]));	
	my $mem_overhead = simplify_number(convert_number($values->{$perfcounter_cache{'mem.overhead.average'}->{'key'} . ":"}[0]));
	my $status = 0; # OK
	my $output = '';
	
	if ($mem_used * 100 / ($memory_size / 1024) >= $warn) {
		$status |= $MYERRORS_MASK{'WARNING'};
	}
	if ($mem_used * 100 / ($memory_size / 1024) >= $crit) {
		$status |= $MYERRORS_MASK{'CRITICAL'};
	}

	$output = "Memory used : " . simplify_number($mem_used / 1024 / 1024) . " Go - size : " . simplify_number($memory_size / 1024 / 1024 / 1024) . " Go - percent : " . simplify_number($mem_used * 100 / ($memory_size / 1024)) . " %";
	$output .= "|used=" . ($mem_used * 1024) . "o;" . simplify_number($memory_size * $warn / 100, 0) . ";" . simplify_number($memory_size * $crit / 100, 0) . ";0;" . ($memory_size) . " size=" . $memory_size . "o" . " overhead=" . ($mem_overhead * 1024) . "o";

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# SwapHost Func
############

sub swaphost_check_args {
	my ($host, $warn, $crit) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	if (defined($warn) && $warn !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be a positive number\n");
		return 1;
	}
	if (defined($crit) && $crit !~ /^-?(?:\d+\.?|\.\d)\d*\z/) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: crit threshold must be a positive number\n");
		return 1;
	}
	if (defined($warn) && defined($crit) && $warn > $crit) {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: warn threshold must be lower than crit threshold\n");
		return 1;
	}
	return 0;
}

sub swaphost_compute_args {
	my $lhost = $_[0];
	my $warn = (defined($_[1]) ? $_[1] : 0.8);
	my $crit = (defined($_[2]) ? $_[2] : 1);
	return ($lhost, $warn, $crit);
}

sub swaphost_do {
	my ($lhost, $warn, $crit) = @_;
	if (!($perfcounter_speriod > 0)) {
		my $status |= $MYERRORS_MASK{'UNKNOWN'};
		print_response($ERRORS{$MYERRORS{$status}} . "|Can't retrieve perf counters.\n");
		return ;
	}

	my %filters = ('name' => $lhost);
	#my @properties = ('summary');
	my @properties = ();
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $values = generic_performance_values_historic($$result[0], 
						[{'label' => 'mem.swapinRate.average', 'instances' => ['']},
						 {'label' => 'mem.swapoutRate.average', 'instances' => ['']}],
						$perfcounter_speriod);

	my $swap_in = simplify_number(convert_number($values->{$perfcounter_cache{'mem.swapinRate.average'}->{'key'} . ":"}[0]));
        my $swap_out = simplify_number(convert_number($values->{$perfcounter_cache{'mem.swapoutRate.average'}->{'key'} . ":"}[0]));
        my $status = 0; # OK
        my $output = '';

        if (($swap_in / 1024) >= $warn || ($swap_out / 1024) >= $warn) {
                $status |= $MYERRORS_MASK{'WARNING'};
        }
        if (($swap_in / 1024) >= $crit || ($swap_out / 1024) >= $crit) {
                $status |= $MYERRORS_MASK{'CRITICAL'};
        }

        $output = "Swap In : " . simplify_number($swap_in / 1024 * 8) . " Mb/s , Swap Out : " . simplify_number($swap_out / 1024 * 8) . " Mb/s ";
        $output .= "|swap_in=" . ($swap_in * 1024 * 8) . "b/s swap_out=" . (($swap_out * 1024 * 8)) . "b/s";

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}


############
# List Host Func
############

sub listhost_check_args {
	return 0;
}

sub listhost_compute_args {
	return undef;
}

sub listhost_do {
	my %filters = ();
	my @properties = ('name');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output = 'Host List: ';
	my $output_append = "";

	foreach my $entity_view (@$result) {
		$output .= $output_append . $entity_view->{name};
		$output_append = ', ';
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# List Datastore Func
############

sub listdatastore_check_args {
	return 0;
}

sub listdatastore_compute_args {
	return undef;
}

sub listdatastore_do {
	my ($ds, $warn, $crit) = @_;
	my %filters = ();
	my @properties = ('datastore');

	my $result = get_entities_host('Datacenter', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my @ds_array = ();
	foreach my $entity_view (@$result) {
		if (defined $entity_view->datastore) {
	 		   @ds_array = (@ds_array, @{$entity_view->datastore});
		}
	}

	@properties = ('summary');
	$result = get_views(\@ds_array, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output = 'Datastore List: ';
	my $output_append = "";
	foreach my $datastore (@$result) {
		if ($datastore->summary->accessible) {
			$output .= $output_append . "'" . $datastore->summary->name . "'";
			$output_append = ', ';
		}
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############
# List Host Func
############

sub listnichost_check_args {
	my ($host) = @_;
	if (!defined($host) || $host eq "") {
		writeLogFile(LOG_ESXD_ERROR, "ARGS error: need hostname\n");
		return 1;
	}
	return 0;
}

sub listnichost_compute_args {
	my $lhost = $_[0];
	return ($lhost);
}

sub listnichost_do {
	my ($lhost) = @_;
	my %filters = ('name' => $lhost);
	my @properties = ('config.network.pnic');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output_up = 'Nic Up List: ';
	my $output_down = 'Nic Down List: ';
	my $output_up_append = "";
	my $output_down_append = "";
	foreach (@{$$result[0]->{'config.network.pnic'}}) {
		if (defined($_->linkSpeed)) {
			$output_up .= $output_up_append . "'" . $_->device . "'";
			$output_up_append = ', ';
		} else {
			$output_down .= $output_down_append . "'" . $_->device . "'";
			$output_down_append = ', ';
		}
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output_up. $output_down.\n");
}

############
# Get Map Func
############

sub getmap_check_args {
	return 0;
}

sub getmap_compute_args {
	my $lhost = $_[0];
	return ($lhost);
}

sub getmap_do {
	my ($lhost) = @_;
	my %filters = ();
	if (defined($lhost) and $lhost ne "") {
		%filters = ('name' => $lhost);
	}
	my @properties = ('name', 'vm');
	my $result = get_entities_host('HostSystem', \%filters, \@properties);
	if (!defined($result)) {
		return ;
	}

	my $status = 0; # OK
	my $output = '';
	my $output_append = "";

	foreach my $entity_view (@$result) {
		$output .= $output_append . "ESX Host '" . $entity_view->name . "': ";
		my @vm_array = ();
		if (defined $entity_view->vm) {
	 		   @vm_array = (@vm_array, @{$entity_view->vm});
		}

		@properties = ('name', 'summary.runtime.powerState');
		my $result2 = get_views(\@vm_array, \@properties);
		if (!defined($result)) {
			return ;
		}
		
		my $output_append2 = '';
		foreach my $vm (@$result2) {
			if ($vm->{'summary.runtime.powerState'}->val eq "poweredOn") {
				$output .= $output_append2 . "[" . $vm->name . "]";
				$output_append2 = ', ';
			}
		}
		$output_append = ". ";
	}

	print_response($ERRORS{$MYERRORS{$status}} . "|$output\n");
}

############

sub catch_zap_term {
	writeLogFile(LOG_ESXD_INFO, "$$ Receiving order to stop...\n");
	$stop = 1;
}

sub REAPER {
	my $child_pid;

	while (($child_pid = waitpid(-1, &WNOHANG)) > 0) {
		$return_child{$child_pid} = {'status' => 1, 'rtime' => time()};
	}
	$SIG{CHLD} = \&REAPER;
}

sub verify_child {
	my $progress = 0;

	# Verify process
	foreach (keys %child_proc) {
		# Check ctime
		if (time() - $child_proc{$_}->{'ctime'} > $TIMEOUT) {
			my $handle = ${$child_proc{$_}->{'reading'}};
			print $writer_pipe_one "$_|-1|Timeout Process.\n";
			kill('INT', $child_proc{$_}->{'pid'});
			$read_select->remove($handle);
			close $handle;
			delete $child_proc{$_};
		} else {
			$progress++;
		}
	}
	# Clean old hash CHILD (security)
	foreach (keys %return_child) {
		if (time() - $return_child{$_}->{'rtime'} > 600) {
			writeLogFile(LOG_ESXD_INFO, "Clean Old return_child list = " . $_ . "\n");
			delete $return_child{$_};
		}
	}

	return $progress;
}

sub vsphere_handler {
	my $timeout_process;
	$read_select = new IO::Select();
	$read_select->add($reader_pipe_two);
	while (1) {
		my $progress = verify_child();

		#####
		# Manage ending
		#####
		if ($stop && $timeout_process > $TIMEOUT_KILL) {
			writeLogFile(LOG_ESXD_ERROR, "Kill child not gently.\n");
			foreach (keys %child_proc) {
				kill('INT', $child_proc{$_}->{'pid'});
			}
			$progress = 0;
		}
		if ($stop && !$progress) {
			if ($vsphere_connected) {
				eval {
					$session1->logout();
				};
			}
			print $writer_pipe_one "STOPPED\n";
			exit (0);
		}

		###
		# Manage vpshere connection
		###
		if (defined($last_time_vsphere) && defined($last_time_check) && $last_time_vsphere < $last_time_check) {
			writeLogFile(LOG_ESXD_ERROR, "Deconnect\n");
			$vsphere_connected = 0;
			eval {
				$session1->logout();
			};
		}
		if ($vsphere_connected == 0) {
			if (!connect_vsphere()) {
				writeLogFile(LOG_ESXD_INFO, "Vsphere connection ok\n");
				writeLogFile(LOG_ESXD_INFO, "Create perf counters cache in progress\n");
				if (!cache_perf_counters()) {
					$last_time_vsphere = time();
					$keeper_session_time = time();
					$vsphere_connected = 1;
					writeLogFile(LOG_ESXD_INFO, "Create perf counters cache done\n");
				}
			}
		}

		###
		# Manage session time
		###
		if (defined($keeper_session_time) && (time() - $keeper_session_time) > ($REFRESH_KEEPER_SESSION * 60)) {
			my $stime;

			eval {
				$stime = $session1->get_service_instance()->CurrentTime();
				$keeper_session_time = time();
			};
			if ($@) {
				writeLogFile(LOG_ESXD_ERROR, "$@");
				writeLogFile(LOG_ESXD_ERROR, "Ask a new connection");
				# Ask a new connection
				$last_time_check = time();
			} else {
				writeLogFile(LOG_ESXD_INFO, "Get current time = " . Data::Dumper::Dumper($stime));
			}
		}

		my $data_element;
		my @rh_set;
		if ($vsphere_connected == 0) {
			sleep(5);
		}
		if ($stop == 0) {
			@rh_set = $read_select->can_read(30);
		} else {
			sleep(1);
			$timeout_process++;
			@rh_set = $read_select->can_read(0);
		}
		foreach my $rh (@rh_set) {
			if ($rh == $reader_pipe_two && !$stop) {
				$data_element = <$rh>;
				chomp $data_element;
				if ($data_element =~ /^STOP$/) {
					$stop = 1;
					$timeout_process = 0;
					next;
				}

				my ($id) = split(/\|/, $data_element);
				if ($vsphere_connected) {
					writeLogFile(LOG_ESXD_INFO, "vpshere handler asking: $data_element\n");
					$child_proc{$id} = {'ctime' => time()};
				
					my $reader;
					my $writer;
					pipe($reader, $writer);
					$writer->autoflush(1);

					$read_select->add($reader);
					$child_proc{$id}->{'reading'} = \*$reader;
					$child_proc{$id}->{'pid'} = fork;
					if (!$child_proc{$id}->{'pid'}) {
						# Child	
						close $reader;
						open STDOUT, '>&', $writer;
						my ($id, $name, @args) = split /\|/, $data_element;
						$global_id = $id;
						$checks_descr{$name}->{'exec'}($checks_descr{$name}->{'compute'}(@args));
						exit(0);
					} else {
						# Parent
						close $writer;
					}
				} else {
					print $writer_pipe_one "$id|-1|Vsphere connection error.\n";
				}
			} else {
				# Read pipe
				my $output = <$rh>;
				$read_select->remove($rh);
				close $rh;
				$output =~ s/^(.*?)\|//;
				my $lid = $1;
				if ($output =~ /^-1/) {
					$last_time_check = $child_proc{$lid}->{'ctime'};
				}
				chomp $output;
				print $writer_pipe_one "$lid|$output\n";
				delete $return_child{$child_proc{$lid}->{'pid'}};
				delete $child_proc{$lid};
			}
		}	
	}
}

$SIG{TERM}  = \&catch_zap_term;
$SIG{CHLD} = \&REAPER;

if ($log_mode == 1) {
	open my $centesx_fh, '>>', $LOG;
	open STDOUT, '>&', $centesx_fh;
	open STDERR, '>&', $centesx_fh;
}
if ($log_mode == 2) {
	openlog $0, LOG_PID, $log_facility;
}

pipe($reader_pipe_one, $writer_pipe_one);
pipe($reader_pipe_two, $writer_pipe_two);
$writer_pipe_one->autoflush(1);
$writer_pipe_two->autoflush(1);

my $server = IO::Socket::INET->new( Proto => "tcp",
			         LocalPort => $port,
    				 Listen => SOMAXCONN,
    				 Reuse => 1);
if (!$server) {
	writeLogFile(LOG_ESXD_ERROR, "Can't setup server: $!\n");
	exit(1);
}

$child_vpshere_pid = fork();
if (!$child_vpshere_pid) {
	close $reader_pipe_one;
	close $writer_pipe_two;
	vsphere_handler();
	exit(0);
}
close $writer_pipe_one;
close $reader_pipe_two;

$read_select = new IO::Select();
$read_select->add($server);
$read_select->add($reader_pipe_one);
writeLogFile(LOG_ESXD_INFO, "[Server accepting clients]\n");
while (1) {

	my @rh_set = $read_select->can_read(30);
	if ($stop == 1) {
		writeLogFile(LOG_ESXD_INFO, "Send STOP command to thread.\n");
		print $writer_pipe_two "STOP\n";
		$stop = 2;
	}
	foreach my $rh (@rh_set) {
		if (!$stop && $rh == $server) {
			my $client;

			# Connect to accept
			$client = $rh->accept();
			$client->autoflush(1);
			$counter++;
			$sockets{fileno($client)} = {"obj" => \$client, "ctime" => time(), "counter" => $counter};
			$read_select->add($client);
			next;
		} elsif ($rh == $reader_pipe_one) {
			# Return to read
			my $data_element = <$rh>;
			chomp $data_element;
			if ($data_element =~ /^STOPPED$/) {
				writeLogFile(LOG_ESXD_INFO, "Thread has stopped\n");
				exit(0);
			}
			# Verify responde queue
			#print "Response queue = $data_element\n";
			my @results = split(/\|/, $data_element);
			my ($id, $counter) = split(/\./, $results[0]);
			if (!defined($sockets{$id}) || $counter != $sockets{$id}->{'counter'}) {
				writeLogFile(LOG_ESXD_INFO, "Too much time to get response.\n");
				next;
			}

			writeLogFile(LOG_ESXD_INFO, "response = $data_element\n");
			$data_element =~ s/^.*?\|//;
			${$sockets{$id}->{'obj'}}->send($data_element . "\n");
			$read_select->remove(${$sockets{$id}->{"obj"}});
			close ${$sockets{$id}->{"obj"}};
			delete $sockets{$id};
		} else {
			# Socket
			my $line = <$rh>;
			if (defined($line) && $line ne "") {
				chomp $line;
				my ($name, @args) = split /\|/, $line;
				if (!defined($checks_descr{$name})) {
					$rh->send("3|Unknown method name '$name'\n");
					delete $sockets{fileno($rh)};
					$read_select->remove($rh);
					close $rh;
					next;
				}
				if ($checks_descr{$name}->{'arg'}(@args)) {
					$rh->send("3|Params error '$name'\n");
					delete $sockets{fileno($rh)};
					$read_select->remove($rh);
					close $rh;
					next;
				}

				print $writer_pipe_two fileno($rh) . "." . $sockets{fileno($rh)}->{'counter'} . "|$line\n";
			} else {
				delete $sockets{fileno($rh)};
				$rh->send("3|Need arguments\n");
				$read_select->remove($rh);
				close $rh;
			}
		}
	}

	# Verify socket 
	foreach (keys %sockets) {
		if (time() - $sockets{$_}->{'ctime'} > $TIMEOUT) {
			writeLogFile(LOG_ESXD_INFO, "Timeout returns.\n");
			${$sockets{$_}->{'obj'}}->send("3|TIMEOUT\n");
			$read_select->remove(${$sockets{$_}->{"obj"}});
			close ${$sockets{$_}->{"obj"}};
			delete $sockets{$_};
		}
	}

}

exit(0);
