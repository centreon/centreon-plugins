#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"centreon/plugins/alternative/FatPackerOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::FatPackerOptions;
  
  use base qw(centreon::plugins::options);
  
  use strict;
  use warnings;
  use Pod::Usage;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              my $pp = $_->{package} . ".pm";
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh,
                        -verbose => 99, 
                        -sections => $_->{sections});
              
              close $str_fh;
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS

$fatpacked{"centreon/plugins/alternative/Getopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_GETOPT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::Getopt;
  
  use strict;
  use warnings;
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  BEGIN {
      @EXPORT    = qw(&GetOptions);
      @EXPORT_OK = qw();
  }
  
  use vars @EXPORT, @EXPORT_OK;
  
  our $warn_message = 0;
  
  sub get_assigned_value {
      my (%options) = @_;
      
      if (!defined($options{val}) || $options{val} eq '') {
          # Add defined also. Hardened code: already see: $ARGV[6] = undef for example
          if ($options{pos} + 1 < $options{num_args} && defined($ARGV[$options{pos} + 1]) && $ARGV[$options{pos} + 1] !~ /^--/) {
              my $val = $ARGV[$options{pos} + 1];
              splice @ARGV, $options{pos} + 1, 1;
              return ($options{num_args} - 1, $val);
          } else {
              return ($options{num_args}, '');
          }
      }
      
      return ($options{num_args}, $options{val});
  }
  
  sub GetOptions {
      my (%opts) = @_;
  
      my $search_str = ',' . join(',', keys %opts) . ',';
      my $num_args = scalar(@ARGV);
      for (my $i = 0; $i < $num_args;) {
          if (defined($ARGV[$i]) && $ARGV[$i] =~ /^--(.*?)(?:=|$)((?s).*)/) {
              my ($option, $value) = ($1, $2);
  
              # The special argument "--" forces an end of option-scanning.
              # All arguments placed after are stored in a list with the special option key '_double_dash_'.
              if ($option eq '' && $value eq '') {
                  my @values = splice @ARGV, $i + 1, $num_args - $i - 1;
                  push @{${$opts{'_double_dash_'}}}, @values;
                  splice @ARGV, $i, 1;
                  last;
              }
  
              # find type of option
              if ($search_str !~ /,((?:[^,]*?\|){0,}$option(?:\|.*?){0,}(:.*?){0,1}),/) {
  
                  # for old format plugins (with run function) that not allowed list-counters options
                  if($option =~ /list-counters/){
                      warn "list-counters option not available yet for this mode." if ($warn_message == 1);
                  }else{
                      warn "Unknown option: $option" if ($warn_message == 1);
                  }
                  $i++;
                  next;
              }
  
              my ($option_selected, $type_opt) = ($1, $2);
              if (!defined($type_opt)) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned ne '0') {
                      ${$opts{$option_selected}} = 1;
                  }
              } elsif ($type_opt =~ /:s$/) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  ${$opts{$option_selected}} = $assigned;
              } elsif ($type_opt =~ /:s\@$/) {
                  ${$opts{$option . $type_opt}} = [] if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  push @{${$opts{$option_selected}}}, $assigned;
              } elsif ($type_opt =~ /:s\%$/) {
                  ${$opts{$option . $type_opt}} = {} if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned =~ /^(.*?)=(.*)/) {
                      ${$opts{$option_selected}}->{$1} = $2;
                  }
              } 
              
              splice @ARGV, $i, 1;
              $num_args--;
          } else {
              warn "argument $ARGV[$i] alone" if ($warn_message == 1 && $i != 0 && defined($ARGV[$i]));
              $i++;
          }
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_GETOPT

$fatpacked{"centreon/plugins/backend/http/curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_CURL';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::curl;
  
  use strict;
  use warnings;
  use URI;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'curl-opt:s@' => { name => 'curl_opt' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'BACKEND CURL OPTIONS', once => 1);
      }
  
      $self->{output} = $options{output};
  
      $self->{curl_log} = $options{curl_logger};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output},
          module => 'Net::Curl::Easy',
          error_msg => "Cannot load module 'Net::Curl::Easy'."
      );
      centreon::plugins::misc::mymodule_load(
          output => $self->{output},
          module => 'centreon::plugins::backend::http::curlconstants',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::curlconstants'."
      );
      $self->{constant_cb} = \&centreon::plugins::backend::http::curlconstants::get_constant_value;
  
      foreach (('unknown_status', 'warning_status', 'critical_status')) {
          if (defined($options{request}->{$_})) {
              $options{request}->{$_} =~ s/%\{http_code\}/\$values->{code}/g;
          }
      }
  
      if (!defined($options{request}->{curl_opt})) {
          $options{request}->{curl_opt} = [];
      }
  }
  
  my $http_code_explained = {
      100 => 'Continue',
      101 => 'Switching Protocols',
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      306 => '(Unused)',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Long',
      415 => 'Unsupported Media Type',
      416 => 'Requested Range Not Satisfiable',
      417 => 'Expectation Failed',
      450 => 'Timeout reached', # custom code
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported'
  };
  
  sub cb_debug {
      my ($easy, $type, $data, $uservar) = @_;
  
      my $msg = '';
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_TEXT')) {
          $msg = sprintf("== Info: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_HEADER_OUT')) {
          $msg = sprintf("=> Send header: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_DATA_OUT')) {
          $msg = sprintf("=> Send data: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_HEADER_IN')) {
          $msg = sprintf("=> Recv header: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_DATA_IN')) {
          $msg = sprintf("=> Recv data: %s", $data);
      }
      return 0 if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_SSL_DATA_OUT'));
      return 0 if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_SSL_DATA_IN'));
  
      $uservar->{output}->output_add(long_msg => $msg, debug => 1);
      return 0;
  }
  
  sub curl_setopt {
      my ($self, %options) = @_;
  
      eval {
          $self->{curl_easy}->setopt($options{option}, $options{parameter});
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "curl setopt error: '" . $@ . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set_method {
      my ($self, %options) = @_;
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => undef);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => undef);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPGET'), parameter => 1);
  
      my $skip_log_post = 0;
      # POST inferred by CURLOPT_POSTFIELDS
      if ($options{content_type_forced} == 1) {
          if (defined($options{request}->{query_form_post})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => $options{request}->{query_form_post});
              $self->{curl_log}->log("--data-raw", $options{request}->{query_form_post});
              $skip_log_post = 1;
          }
      } elsif (defined($options{request}->{post_params})) {
          my $uri_post = URI->new();
          $uri_post->query_form($options{request}->{post_params});
          my $urlencodedheader = 'Content-Type: application/x-www-form-urlencoded';
          push @{$options{headers}}, $urlencodedheader;
  
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => $uri_post->query);
          $self->{curl_log}->log("-H", $urlencodedheader);
  
          $self->{curl_log}->log("--data-raw", $uri_post->query);
          $skip_log_post = 1;
      }
  
      if ($options{request}->{method} eq 'GET') {
          # no curl_log call because GET is the default value
          return;
      }
  
      if ($options{request}->{method} eq 'POST') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POST'), parameter => 1);
          $self->{curl_log}->log('-X', $options{request}->{method}) unless $skip_log_post;
          return;
      }
  
      $self->{curl_log}->log('-X', $options{request}->{method});
      if ($options{request}->{method} eq 'PUT') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
      if ($options{request}->{method} eq 'DELETE') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
      if ($options{request}->{method} eq 'PATCH') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
  }
  
  sub set_auth {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{credentials})) {
          if (defined($options{request}->{basic})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_BASIC'));
              $self->{curl_log}->log('--basic');
          } elsif (defined($options{request}->{ntlmv2})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_NTLM'));
              $self->{curl_log}->log('--ntlm');
          } elsif (defined($options{request}->{digest})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_DIGEST'));
              $self->{curl_log}->log('--digest');
          }else {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_ANY'));
              $self->{curl_log}->log('--anyauth');
          }
          my $userpassword = $options{request}->{username}  . ':' . $options{request}->{password};
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_USERPWD'), parameter => $userpassword);
          $self->{curl_log}->log('--user', $userpassword);
      }
  
      if (defined($options{request}->{cert_file}) &&  $options{request}->{cert_file} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERT'), parameter => $options{request}->{cert_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLKEY'), parameter => $options{request}->{key_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_KEYPASSWD'), parameter => $options{request}->{cert_pwd});
  
          $self->{curl_log}->log('--cert', $options{request}->{cert_file});
          $self->{curl_log}->log('--key', $options{request}->{key_file});
          $self->{curl_log}->log('--pass', $options{request}->{cert_pwd}) if defined $options{request}->{cert_pwd} && $options{request}->{cert_pwd} ne '';
      }
  
      if (defined($options{request}->{cert_pkcs12})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERTTYPE'), parameter => "P12");
          $self->{curl_log}->log('--cert-type', 'p12');
      } else {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERTTYPE'), parameter => "PEM");
          # no curl_log call because PEM is the default value
      }
  }
  
  sub set_form {
      my ($self, %options) = @_;
  
      if (!defined($self->{form_loaded})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Net::Curl::Form',
              error_msg => "Cannot load module 'Net::Curl::Form'."
          );
          $self->{form_loaded} = 1;
      }
  
      my $form = Net::Curl::Form->new();
      foreach (@{$options{form}}) {
          my %args = ();
          $args{ $self->{constant_cb}->(name => 'CURLFORM_COPYNAME()') } = $_->{copyname}
              if (defined($_->{copyname}));
          $args{ $self->{constant_cb}->(name => 'CURLFORM_COPYCONTENTS()') } = $_->{copycontents}
              if (defined($_->{copycontents}));
          $form->add(%args);
  
          $self->{curl_log}->log("--form-string", $_->{copyname}."=".$_->{copycontents})
              if defined($_->{copyname}) && defined($_->{copycontents});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPPOST()'), parameter => $form);
  }
  
  sub set_proxy {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{proxyurl}) && $options{request}->{proxyurl} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_PROXY'), parameter => $options{request}->{proxyurl});
          $self->{curl_log}->log("--proxy", $options{request}->{proxyurl});
      }
  
      if (defined($options{request}->{proxypac}) && $options{request}->{proxypac} ne '') {
          $self->{output}->add_option_msg(short_msg => 'Unsupported proxypac option');
          $self->{output}->option_exit();
      }
  }
  
  sub set_extra_curl_opt {
      my ($self, %options) = @_;
  
      my $entries = {};
      foreach (@{$options{request}->{curl_opt}}) {
          my ($key, $value) = split /=>/;
          $key = centreon::plugins::misc::trim($key);
  
          if (!defined($entries->{$key})) {
              $entries->{$key} = { val => [], constants => [], force_array => 0 };
          }
  
          $value = centreon::plugins::misc::trim($value);
  
          # Here we want to convert a string containing curl options into a single value or into
          # an array of values depending on whether it begins with '[' and ends with ']'.
          # We also remove the quotes.
          # for example:
          #
          # $opt = ["CURLOPT_SSL_VERIFYPEER =>[opt1,'opt2','opt3']"];
          # is converted to a Perl array like this:
          # $VAR1 = [
          #  'opt1',
          #  'opt2',
          #  'opt3'
          # ];
          #
          # $opt = [ "CURLOPT_SSL_VERIFYPEER => 'opt1'" ];
          # is converted to:
          # $VAR1 = 'opt1';
          if ($value =~ /^\[(.*)\]$/) {
              $entries->{$key}->{force_array} = 1;
              $value = centreon::plugins::misc::trim($1);
              push @{$entries->{$key}->{constants}}, map { $_ = centreon::plugins::misc::trim($_); s/^'(.*)'$/$1/; $_  } split ',', $value;
          } else {
              push @{$entries->{$key}->{constants}}, $value =~ /^'(.*)'$/ ? $1 : $value;
          }
  
          if ($value  =~ /^CURLOPT|CURL/) {
              $value = $self->{constant_cb}->(name => $value);
          }
  
          push @{$entries->{$key}->{val}}, $value; 
      }
  
      foreach (keys %$entries) {
          my $key = $_;
  
          if ($self->{curl_log}->is_enabled()) {
              $self->{curl_log}->convert_curlopt_to_cups_parameter(
                  key => $key,
                  parameter => $entries->{$key}->{constants},
              );
          }
  
          if (/^CURLOPT|CURL/) {
              $key = $self->{constant_cb}->(name => $_);
          }
  
          my $parameter;
          if ($entries->{$_}->{force_array} == 1 || scalar(@{$entries->{$_}->{val}}) > 1) {
              $parameter = $entries->{$_}->{val};
          } else {
              $parameter = pop @{$entries->{$_}->{val}};
          }
          $self->curl_setopt(option => $key, parameter => $parameter);
  
      }
  }
  
  sub cb_get_header {
      my ($easy, $header, $uservar) = @_;
  
      $header =~ s/[\r\n]//g;
      if ($header =~ /^[\r\n]*$/) {
          $uservar->{nheaders}++;
      } else {
          $uservar->{response_headers}->[$uservar->{nheaders}] = {}
              if (!defined($uservar->{response_headers}->[$uservar->{nheaders}]));
          if ($header =~  /^(\S(?:.*?))\s*:\s*(.*)/) {
              my $header_name = lc($1);
              $uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name} = []
                  if (!defined($uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name}));
              push @{$uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name}}, $2;
          } else {
             $uservar->{response_headers}->[$uservar->{nheaders}]->{response_line} = $header; 
          }
      }
  
      return length($_[1]);
  }
  
  sub request {
      my ($self, %options) = @_;
  
      # Enable curl logger when debug mode is on
      $self->{curl_log}->init( enabled => $self->{output}->is_debug() );
  
      if (!defined($self->{curl_easy})) {
          $self->{curl_easy} = Net::Curl::Easy->new();
      }
  
      my $url;
      if (defined($options{request}->{full_url})) {
          $url = $options{request}->{full_url};
      } elsif (defined($options{request}->{port}) && $options{request}->{port} =~ /^[0-9]+$/) {
          $url = $options{request}->{proto}. "://" . $options{request}->{hostname} . ':' . $options{request}->{port} . $options{request}->{url_path};
      } else {
          $url = $options{request}->{proto}. "://" . $options{request}->{hostname} . $options{request}->{url_path};
      }
  
      my $uri = URI->new($url);
      if (defined($options{request}->{get_params})) {
          $uri->query_form($options{request}->{get_params});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_URL'), parameter => $uri);
  
      $self->{curl_log}->log($uri);
  
      if ($self->{output}->is_debug()) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_DEBUGFUNCTION'), parameter => \&cb_debug);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_DEBUGDATA'), parameter => $self);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_VERBOSE'), parameter => 1);
  
          $self->{curl_log}->log('--verbose');
      }
  
      if (defined($options{request}->{timeout}) && $options{request}->{timeout} =~ /\d/) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_TIMEOUT'), parameter => $options{request}->{timeout});
          $self->{curl_log}->log("--max-time", $options{request}->{timeout});
      }
  
      if (defined($options{request}->{cookies_file})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_COOKIEFILE'), parameter => $options{request}->{cookies_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_COOKIEJAR'), parameter => $options{request}->{cookies_file});
          $self->{curl_log}->log('--cookie', $options{request}->{cookies_file});
          $self->{curl_log}->log('--cookie-jar', $options{request}->{cookies_file});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FOLLOWLOCATION'), parameter => 1);
      if (defined($options{request}->{no_follow})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FOLLOWLOCATION'), parameter => 0);
      } else {
          $self->{curl_log}->log('-L');
      }
  
      if (defined($options{request}->{http_peer_addr}) && $options{request}->{http_peer_addr} ne '') {
          $url =~ /^(?:http|https):\/\/(.*?)(\/|\:|$)/;
          my $resolve = $1 . ':' . $options{request}->{port_force} . ':' . $options{request}->{http_peer_addr};
          $self->{curl_easy}->setopt(
              $self->{constant_cb}->(name => 'CURLOPT_RESOLVE'),
              [$resolve]
          );
          $self->{curl_log}->log('--resolve', $resolve);
      }    
  
      my $headers = [];
      my $content_type_forced = 0;
      foreach my $key (keys %{$options{request}->{headers}}) {
          my $header = $key . ':' . (defined($options{request}->{headers}->{$key}) ? ' '.$options{request}->{headers}->{$key} : '');
          push @$headers, $header;
          if ($key =~ /content-type/i) {
              $content_type_forced = 1;
          }
          $self->{curl_log}->log("-H", $header);
      }
  
      $self->set_method(%options, content_type_forced => $content_type_forced, headers => $headers);
  
      if (defined($options{request}->{form})) {
          $self->set_form(form => $options{request}->{form});
      }
  
      if (scalar(@$headers) > 0) {
          $self->{curl_easy}->setopt($self->{constant_cb}->(name => 'CURLOPT_HTTPHEADER'), $headers);
      }
  
      if (defined($options{request}->{cacert_file}) && $options{request}->{cacert_file} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CAINFO'), parameter => $options{request}->{cacert_file});
          $self->{curl_log}->log('--cacert', $options{request}->{cacert_file});
      }
      if (defined($options{request}->{insecure})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSL_VERIFYPEER'), parameter => 0);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSL_VERIFYHOST'), parameter => 0);
          $self->{curl_log}->log('--insecure');
      }
  
      $self->set_auth(%options);
      $self->set_proxy(%options);
      $self->set_extra_curl_opt(%options);
      $self->{response_body} = '';
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FILE'), parameter => \$self->{response_body});
      $self->{nheaders} = 0;
      $self->{response_headers} = [{}];
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HEADERDATA'), parameter => $self);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HEADERFUNCTION'), parameter => \&cb_get_header);
  
      if (defined($options{request}->{certinfo}) && $options{request}->{certinfo} == 1) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CERTINFO'), parameter => 1);
          # no curl_log call because there is no equivalent in command line
      }
  
      $self->{response_code} = undef;
  
      if ($self->{curl_log}->is_enabled()) {
          $self->{output}->output_add(long_msg => 'curl request [curl backend]: ' . $self->{curl_log}->get_log());
      }
  
      eval {
          $self->{curl_easy}->perform();
      };
      if ($@) {
          my $err = $@;
          if (ref($@) eq "Net::Curl::Easy::Code") {
              my $num = $@;
              if ($num == $self->{constant_cb}->(name => 'CURLE_OPERATION_TIMEDOUT')) {
                  $self->{response_code} = 450;
              }
          }
  
          if (!defined($self->{response_code})) {
              $self->{output}->add_option_msg(short_msg => 'curl perform error : ' . $err);
              $self->{output}->option_exit();
          }
      }
  
      $self->{response_code} = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_RESPONSE_CODE'))
          if (!defined($self->{response_code}));
  
      # Check response
      my $status = 'ok';
      if (defined($options{request}->{critical_status}) && $options{request}->{critical_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{critical_status}, values => { code => $self->{response_code} })) {
          $status = 'critical';
      } elsif (defined($options{request}->{warning_status}) && $options{request}->{warning_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{warning_status}, values => { code => $self->{response_code} })) {
          $status = 'warning';
      } elsif (defined($options{request}->{unknown_status}) && $options{request}->{unknown_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{unknown_status}, values => { code => $self->{response_code} })) {
          $status = 'unknown';
      }
  
      if (!$options{request}->{silently_fail} && !$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          my $short_msg = $self->{response_code} . ' ' . 
              (defined($http_code_explained->{$self->{response_code}}) ? $http_code_explained->{$self->{response_code}} : 'unknown');
  
          $self->{output}->output_add(
              severity => $status,
              short_msg => $short_msg
          );
          $self->{output}->display();
          $self->{output}->exit();
      }
  
      return $self->{response_body};
  }
  
  sub get_headers {
      my ($self, %options) = @_;
  
      my $headers = '';
      foreach (keys %{$self->{response_headers}->[$options{nheader}]}) {
          next if (/response_line/);
          foreach my $value (@{$self->{response_headers}->[$options{nheader}]->{$_}}) {
              $headers .= "$_: " . $value . "\n";
          }
      }
  
      return $headers;
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(nheader => 0);
      }
  
      return undef
          if (!defined($self->{response_headers}->[0]->{ lc($options{name}) }));
      return wantarray ? @{$self->{response_headers}->[0]->{ lc($options{name}) }} : $self->{response_headers}->[0]->{ lc($options{name}) }->[0];
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(nheader => -1);
      }
  
      return undef
          if (!defined($self->{response_headers}->[-1]->{ lc($options{name}) }));
      return wantarray ? @{$self->{response_headers}->[-1]->{ lc($options{name}) }} : $self->{response_headers}->[-1]->{ lc($options{name}) }->[0];
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{response_code};
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return defined($http_code_explained->{$self->{response_code}}) ? $http_code_explained->{$self->{response_code}} : 'Unknown code';
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      my $certs = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_CERTINFO'));
      return ('pem', $certs->[0]->{Cert});
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      # TIME_T = 7.61.0
      my $resolve = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_NAMELOOKUP_TIME'));
      my $connect = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_CONNECT_TIME'));
      my $appconnect = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_APPCONNECT_TIME'));
      my $start = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_STARTTRANSFER_TIME'));
      my $total = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_TOTAL_TIME'));
      my $times = {
          resolve => $resolve * 1000,
          connect => ($connect - $resolve) * 1000,
          transfer => ($total - $start) * 1000
      };
      if ($appconnect > 0) {
          $times->{tls} = ($appconnect - $connect) * 1000;
          $times->{processing} = ($start - $appconnect) * 1000;
      } else {
          $times->{processing} = ($start - $connect) * 1000;
      }
  
      return $times;
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP Curl backend layer.
  
  =head1 SYNOPSIS
  
  HTTP Curl backend layer.
  
  =head1 BACKEND CURL OPTIONS
  
  =over 8
  
  =item B<--curl-opt>
  
  Set CURL Options (--curl-opt="CURLOPT_SSL_VERIFYPEER => 0" --curl-opt="CURLOPT_SSLVERSION => CURL_SSLVERSION_TLSv1_1" ).
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_BACKEND_HTTP_CURL

$fatpacked{"centreon/plugins/backend/http/curlconstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_CURLCONSTANTS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::curlconstants;
  
  use strict;
  use warnings;
  use Net::Curl::Easy qw(:constants);
  use Net::Curl::Form qw(:constants);
  
  sub get_constant_value {
      my (%options) = @_;
  
      return eval $options{name};
  }
  
  1;
CENTREON_PLUGINS_BACKEND_HTTP_CURLCONSTANTS

$fatpacked{"centreon/plugins/backend/http/lwp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_LWP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::lwp;
  
  use strict;
  use warnings;
  use centreon::plugins::backend::http::useragent;
  use URI;
  use IO::Socket::SSL;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'ssl:s'      => { name => 'ssl' },
              'ssl-opt:s@' => { name => 'ssl_opt' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'BACKEND LWP OPTIONS', once => 1);
      }
  
      $self->{output} = $options{output};
      $self->{ua} = undef;
      $self->{debug_handlers} = 0;
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      foreach (('unknown_status', 'warning_status', 'critical_status')) {
          if (defined($options{request}->{$_})) {
              $options{request}->{$_} =~ s/%\{http_code\}/\$values->{code}/g;
          }
      }
  
      $self->{ssl_context} = '';
      if (!defined($options{request}->{ssl_opt})) {
          $options{request}->{ssl_opt} = [];
      }
      if (defined($options{request}->{ssl}) && $options{request}->{ssl} ne '') {
          push @{$options{request}->{ssl_opt}}, 'SSL_version => ' . $options{request}->{ssl};
      }
      if (defined($options{request}->{cert_file}) && !defined($options{request}->{cert_pkcs12})) {
          push @{$options{request}->{ssl_opt}}, 'SSL_use_cert => 1';
          push @{$options{request}->{ssl_opt}}, 'SSL_cert_file => "' . $options{request}->{cert_file} . '"';
          push @{$options{request}->{ssl_opt}}, 'SSL_key_file => "' . $options{request}->{key_file} . '"'
               if (defined($options{request}->{key_file}));
          push @{$options{request}->{ssl_opt}}, 'SSL_ca_file => "' . $options{request}->{cacert_file} . '"'
              if (defined($options{request}->{cacert_file}));
      }
      if ($options{request}->{insecure}) {
          push @{$options{request}->{ssl_opt}}, 'SSL_verify_mode => SSL_VERIFY_NONE';
      }
  
      my $append = '';
      foreach (@{$options{request}->{ssl_opt}}) {
          if ($_ ne '') {
              $self->{ssl_context} .= $append . $_;
              $append = ', ';
          }
      }
  }
  
  sub set_proxy {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{proxypac}) && $options{request}->{proxypac} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'HTTP::ProxyPAC',
              error_msg => "Cannot load module 'HTTP::ProxyPAC'."
          );
          my ($pac, $pac_uri);
          eval {
              if ($options{request}->{proxypac} =~ /^(http|https):\/\//) {
                  $pac_uri = URI->new($options{request}->{proxypac});
                  $pac = HTTP::ProxyPAC->new($pac_uri);
              } else {
                  $pac = HTTP::ProxyPAC->new($options{request}->{proxypac});
              }
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => 'issue to load proxypac: ' . $@);
              $self->{output}->option_exit();
          }
          my $res = $pac->find_proxy($options{url});
          if (defined($res->direct) && $res->direct != 1) {
              my $proxy_uri = URI->new($res->proxy);
              $proxy_uri->userinfo($pac_uri->userinfo) if (defined($pac_uri->userinfo));
              $self->{ua}->proxy(['http', 'https'], $proxy_uri->as_string);
          }
      }
      if (defined($options{request}->{proxyurl}) && $options{request}->{proxyurl} ne '') {
          my $proxyurl = $options{request}->{proxyurl};
          if ($options{request}->{proto} eq "https" ||
              (defined($options{request}->{full_url}) && $options{request}->{full_url} =~ /^https/)) {
              $proxyurl = 'connect://' . $2 if ($proxyurl =~ /^(http|https):\/\/(.*)/);
          }
          $self->{ua}->proxy(['http', 'https'], $proxyurl);
      }
  }
  
  sub request {
      my ($self, %options) = @_;
  
      my %user_agent_params = (keep_alive => 1);
      if (defined($options{request}->{certinfo}) && $options{request}->{certinfo} == 1) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'LWP::ConnCache',
              error_msg => "Cannot load module 'LWP::ConnCache'."
          );
          $self->{cache} = LWP::ConnCache->new();
          $self->{cache}->total_capacity(1);
          %user_agent_params = (conn_cache => $self->{cache});
      }
  
      my $request_options = $options{request};
      if (!defined($self->{ua})) {
          my $timeout;
          $timeout = $1 if (defined($request_options->{timeout}) && $request_options->{timeout} =~ /(\d+)/);
          $self->{ua} = centreon::plugins::backend::http::useragent->new(
              %user_agent_params,
              protocols_allowed => ['http', 'https'], 
              timeout => $timeout,
              credentials => $request_options->{credentials},
              username => $request_options->{username}, 
              password => $request_options->{password}
          );
          if (defined($request_options->{cookies_file})) {
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output},
                  module => 'HTTP::Cookies',
                  error_msg => "Cannot load module 'HTTP::Cookies'."
              );
              $self->{ua}->cookie_jar(
                  HTTP::Cookies->new(
                      file => $request_options->{cookies_file},
                      autosave => 1
                  )
              );
          }
      }
  
      if ($self->{output}->is_debug() && $self->{debug_handlers} == 0) {
          $self->{debug_handlers} = 1;
          $self->{ua}->add_handler('request_send', sub {
              my ($response, $ua, $handler) = @_;
  
              $self->{output}->output_add(long_msg => '======> request send', debug => 1);
              $self->{output}->output_add(long_msg => $response->as_string, debug => 1);
              return ; 
          });
          $self->{ua}->add_handler("response_done", sub { 
              my ($response, $ua, $handler) = @_;
  
              $self->{output}->output_add(long_msg => '======> response done', debug => 1);
              $self->{output}->output_add(long_msg => $response->as_string, debug => 1);
              return ;
          });
      }
  
      if (defined($request_options->{no_follow})) {
          $self->{ua}->requests_redirectable(undef);
      } else {
          $self->{ua}->requests_redirectable([ 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH' ]);
      }
      if (defined($request_options->{http_peer_addr})) {
          push @LWP::Protocol::http::EXTRA_SOCK_OPTS, PeerAddr => $request_options->{http_peer_addr};
      }
  
      my ($req, $url);
      if (defined($request_options->{full_url})) {
          $url = $request_options->{full_url};
      } elsif (defined($request_options->{port}) && $request_options->{port} =~ /^[0-9]+$/) {
          $url = $request_options->{proto}. '://' . $request_options->{hostname} . ':' . $request_options->{port} . $request_options->{url_path};
      } else {
          $url = $request_options->{proto}. '://' . $request_options->{hostname} . $request_options->{url_path};
      }
  
      my $uri = URI->new($url);
      if (defined($request_options->{get_params})) {
          $uri->query_form($request_options->{get_params});
      }
  
      $req = HTTP::Request->new($request_options->{method}, $uri);
  
      my $content_type_forced = 0;
      foreach my $key (keys %{$request_options->{headers}}) {
          $req->header($key => $request_options->{headers}->{$key});
          if ($key =~ /content-type/i) {
              $content_type_forced = 1;
          }
      }
  
      if ($content_type_forced == 1) {
          $req->content($request_options->{query_form_post});
      } elsif (defined($options{request}->{post_params})) {
          my $uri_post = URI->new();
          $uri_post->query_form($request_options->{post_params});
          $req->content_type('application/x-www-form-urlencoded');
          $req->content($uri_post->query);
      }
  
      if (defined($request_options->{form})) {
          $self->{output}->add_option_msg(short_msg => 'unsupported form param');
          $self->{output}->option_exit();
      }
  
      if (defined($request_options->{credentials}) && defined($request_options->{ntlmv2})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Authen::NTLM',
              error_msg => "Cannot load module 'Authen::NTLM'."
          );
          Authen::NTLM::ntlmv2(1);
      }
  
      if (defined($request_options->{credentials}) && (defined($request_options->{basic}) || defined($request_options->{digest}))) {
          $req->authorization_basic($request_options->{username}, $request_options->{password});
      }
  
      $self->set_proxy(request => $request_options, url => $url);
  
      if (defined($request_options->{cert_pkcs12}) && $request_options->{cert_file} ne '' && $request_options->{cert_pwd} ne '') {
          eval 'use Net::SSL'; die $@ if $@;
          $ENV{HTTPS_PKCS12_FILE} = $request_options->{cert_file};
          $ENV{HTTPS_PKCS12_PASSWORD} = $request_options->{cert_pwd};
      }
  
      if (defined($self->{ssl_context}) && $self->{ssl_context} ne '') {
          my $context = new IO::Socket::SSL::SSL_Context(eval $self->{ssl_context});
          IO::Socket::SSL::set_default_context($context);
      }
  
      $self->{response} = $self->{ua}->request($req);
  
      $self->{response_code} = $self->{response}->code();
      $self->{response_message} = $self->{response}->message();
      $self->{headers} = $self->{response}->headers();
  
      if ($self->{response_code} == 500) {
          my $client_warning = $self->get_header(name => 'Client-Warning');
          if (defined($client_warning) && $client_warning eq 'Internal response' && $self->{response_message} =~ /connection timed out/mi) {
              $self->{response_code} = 450;
              $self->{response_message} = 'Timeout reached';
          }
      }
  
      # Check response
      my $status = 'ok';
      if (defined($request_options->{critical_status}) && $request_options->{critical_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{critical_status}, values => { code => $self->{response_code} })) {
          $status = 'critical';
      } elsif (defined($request_options->{warning_status}) && $request_options->{warning_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{warning_status}, values => { code => $self->{response_code} })) {
          $status = 'warning';
      } elsif (defined($request_options->{unknown_status}) && $request_options->{unknown_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{unknown_status}, values => { code => $self->{response_code} })) {
          $status = 'unknown';
      }
      if (!$request_options->{silently_fail} && !$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          my $short_msg = $self->{response}->status_line;
          if ($short_msg =~ /^401/) {
              $short_msg .= ' (' . $1 . ' authentication expected)' if (defined($self->{response}->www_authenticate) &&
                  $self->{response}->www_authenticate =~ /(\S+)/);
          }
  
          $self->{output}->output_add(
              severity => $status,
              short_msg => $short_msg
          );
          $self->{output}->display();
          $self->{output}->exit();
      }
  
      return $self->{response}->content;
  }
  
  sub get_headers {
      my ($self, %options) = @_;
  
      my $headers = '';
      foreach ($options{response}->header_field_names()) {
          my $value = $options{response}->header($_);
          $headers .= "$_: " . (defined($value) ? $value : '') . "\n";
      }
  
      return $headers;
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      my @redirects = $self->{response}->redirects();
      if (!defined($options{name})) {
          return $self->get_headers(response => defined($redirects[0]) ? $redirects[0] : $self->{response});
      }
  
      return
          defined($redirects[0]) ? 
          $redirects[0]->headers()->header($options{name}) :
          $self->{headers}->header($options{name})
      ;
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(response => $self->{response});
      }
      return $self->{headers}->header($options{name});
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{response_code};
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return $self->{response_message};
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      my ($con) = $self->{cache}->get_connections('https');
      return ('socket', $con);
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      return undef;
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP LWP backend layer.
  
  =head1 SYNOPSIS
  
  HTTP LWP backend layer.
  
  =head1 BACKEND LWP OPTIONS
  
  =over 8
  
  =item B<--ssl-opt>
  
  Set SSL Options (--ssl-opt="SSL_version => TLSv1" --ssl-opt="SSL_verify_mode => SSL_VERIFY_NONE").
  
  =item B<--ssl>
  
  Set SSL version (--ssl=TLSv1).
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_BACKEND_HTTP_LWP

$fatpacked{"centreon/plugins/backend/http/useragent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_USERAGENT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::useragent;
  
  use strict;
  use warnings;
  use base 'LWP::UserAgent';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self = LWP::UserAgent::new(@_);
      $self->agent("centreon::plugins::backend::http::useragent");
  
      $self->{credentials} = $options{credentials} if defined($options{credentials});
      $self->{username} = $options{username} if defined($options{username});
      $self->{password} = $options{password} if defined($options{password});
  
      return $self;
  }
  
  sub get_basic_credentials {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->{username}, $self->{password} if $self->{credentials} and wantarray;
      return $self->{username} . ':' . $self->{password} if $self->{credentials};
      return undef;
  }
  
  1;
CENTREON_PLUGINS_BACKEND_HTTP_USERAGENT

$fatpacked{"centreon/plugins/constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_CONSTANTS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  #
  
  package centreon::plugins::constants;
  
  use strict;
  use warnings;
  use Exporter qw(import);
  
  use constant {
      BUFFER_CREATION => -1,
      NO_VALUE => -10,
  
      MSG_JSON_DECODE_ERROR => 'Cannot decode response (add --debug option to display returned content)'
  };
  
  our %EXPORT_TAGS = (
      values => [ qw(NO_VALUE BUFFER_CREATION) ],
      messages => [ qw(MSG_JSON_DECODE_ERROR) ]
  );
  $EXPORT_TAGS{all} = [ map { @$_ } values %EXPORT_TAGS ];
  
  our @EXPORT_OK = @{$EXPORT_TAGS{all}};
  
  1;
CENTREON_PLUGINS_CONSTANTS

$fatpacked{"centreon/plugins/curllogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_CURLLOGGER';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::curllogger;
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{log_as_curl} = [];
      $self->{is_log_as_curl} = 0;
  
      # As this is only used for debugging purposes, we disable it if the ShellQuote
      # module is missing
      eval "use String::ShellQuote";
      if ($@) {
          $self->{is_log_as_curl} = -1;
      }
  
      $self;
  }
  
  sub init {
      my ($self, %options) = @_;
  
      $self->{log_as_curl} = [];
      return if $self->{is_log_as_curl} == -1;
  
      $self->{is_log_as_curl} = $options{enabled} || 0;
  }
  
  sub is_enabled {
      my ($self) = @_;
  
      return $self->{is_log_as_curl} == 1;
  }
  
  sub log {
      my ($self, @params) = @_;
  
      return unless $self->{is_log_as_curl} == 1 && @params;
  
      push @{$self->{log_as_curl}}, shell_quote(@params);
  }
  
  sub get_log {
      my ($self) = @_;
  
      return "curl ".join ' ', @{$self->{log_as_curl}};
  }
  
  # Conversion of some parameters manually passed to the set_extra_curl_opt function
  # into their command-line equivalents. Only the parameters used in the plugin code
  # are handled. If new parameters are added, this hash must be updated.
  # The hash contains curl parameters CURLOPT_*. Its keys map to either a hash when
  # multiple values are handled, or directly to an array when only one response is
  # supported. The placeholder <value> is replaced by the provided value.
  # Eg: "CURLOPT_POSTREDIR => CURL_REDIR_POST_ALL" will produce: --post301 --post302 --post303
  #     "CURLOPT_SSL_VERIFYPEER => 0" will produce: --insecure
  #     "CURLOPT_AWS_SIGV4 => 'osc'" will produce: --aws-sigv4 osc
  our %curlopt_to_parameter = (
     'CURLOPT_POSTREDIR' => { 'CURL_REDIR_POST_ALL' => [ '--post301', '--post302', '--post303', ],
                              'CURL_REDIR_POST_301' => [ '--post301' ],
                              'CURL_REDIR_POST_302' => [ '--post302' ],
                              'CURL_REDIR_POST_303' => [ '--post303' ],
                            },
     'CURLOPT_SSLVERSION' => { 'CURL_SSLVERSION_TLSv1_0' => [ '--tlsv1.0' ],
                               'CURL_SSLVERSION_TLSv1_1' => [ '--tlsv1.1' ],
                               'CURL_SSLVERSION_TLSv1_2' => [ '--tlsv1.2' ],
                               'CURL_SSLVERSION_TLSv1_3' => [ '--tlsv1.3' ],
                             },
     'CURLOPT_SSL_VERIFYPEER' => { '0' => [ '--insecure' ] },
     'CURLOPT_SSL_VERIFYHOST' => { '0' => [ '--insecure' ] },
  
     'CURLOPT_AWS_SIGV4' => [ '--aws-sigv4', '<value>' ],
  );
  
  sub convert_curlopt_to_cups_parameter {
      my ($self, %options) = @_;
  
      my $key = $options{key};
  
      return unless exists $curlopt_to_parameter{$key};
  
      # we want an array of parameters
      my $parameters = ref $options{parameter} eq 'ARRAY' ? $options{parameter} : [ $options{parameter} ] ;
  
      my @cups_parameters ;
      if (ref $curlopt_to_parameter{$key} eq 'ARRAY') {
          @cups_parameters = map { s/<value>/$parameters->[0]/; $_ } @{$curlopt_to_parameter{$key}};
      } else {
          foreach my $parameter (@$parameters) {
              if (exists $curlopt_to_parameter{$key}->{$parameter}) {
                  push @cups_parameters, @{$curlopt_to_parameter{$key}->{$parameter}};
              } elsif ($parameter =~ /^-/) {
                  push @cups_parameters, $parameter;
              }
          }
      }
      $self->log($_) for @cups_parameters;
  }
  
  1;
  
CENTREON_PLUGINS_CURLLOGGER

$fatpacked{"centreon/plugins/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_HTTP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::http;
  
  use strict;
  use warnings;
  
  use centreon::plugins::curllogger;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'http-peer-addr:s'  => { name => 'http_peer_addr' },
              'proxyurl:s'        => { name => 'proxyurl' },
              'proxypac:s'        => { name => 'proxypac' },
              'insecure'          => { name => 'insecure' },
              'http-backend:s'    => { name => 'http_backend' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'HTTP GLOBAL OPTIONS');
      }
  
      my $curllogger = centreon::plugins::curllogger->new();
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output},
          module => 'centreon::plugins::backend::http::lwp',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::lwp'."
      );
      $self->{backend_lwp} = centreon::plugins::backend::http::lwp->new(%options);
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output},
          module => 'centreon::plugins::backend::http::curl',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::curl'."
      );
      $self->{backend_curl} = centreon::plugins::backend::http::curl->new(%options, curl_logger => $curllogger);
  
      $self->{default_backend} = defined($options{default_backend}) && $options{default_backend} ne '' ?
          $options{default_backend} : 'lwp';
      $self->{output} = $options{output};
      $self->{options} = {
          proto => 'http',
          url_path => '/',
          timeout => 5,
          method => 'GET',
          unknown_status => '%{http_code} < 200 or %{http_code} >= 300',
          warning_status => undef,
          critical_status => undef,
      };
  
      $self->{add_headers} = {};
      return $self;
  }
  
  sub set_options {
      my ($self, %options) = @_;
  
      $self->{options} = { %{$self->{options}} };
      foreach (keys %options) {
          $self->{options}->{$_} = $options{$_} if (defined($options{$_}));
      }
  }
  
  sub add_header {
      my ($self, %options) = @_;
  
      $self->{add_headers}->{$options{key}} = $options{value};
  }
  
  sub remove_header {
      my ($self, %options) = @_;
  
      delete $self->{add_headers}->{$options{key}} if (defined($self->{add_headers}->{$options{key}}));
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      $options{request}->{http_backend} = $self->{default_backend}
          if (!defined($options{request}->{http_backend}) || $options{request}->{http_backend} eq '');
      $self->{http_backend} = $options{request}->{http_backend};
      if ($self->{http_backend} !~ /^\s*lwp|curl\s*$/i) {
          $self->{output}->add_option_msg(short_msg => "Unsupported http backend specified '" . $self->{http_backend} . "'.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{request}->{$self->{http_backend} . '_backend_options'})) {
          foreach (keys %{$options{request}->{$self->{http_backend} . '_backend_options'}}) {
              $options{request}->{$_} = $options{request}->{$self->{http_backend} . '_backend_options'}->{$_};
          }
      }
  
      if (($options{request}->{proto} ne 'http') && ($options{request}->{proto} ne 'https')) {
          $self->{output}->add_option_msg(short_msg => "Unsupported protocol specified: '(" . $options{request}->{proto} . ")'. . Use either https or http.");
          $self->{output}->option_exit();
      }
      if (!defined($options{request}->{hostname})) {
          $self->{output}->add_option_msg(short_msg => "Please set the hostname option");
          $self->{output}->option_exit();
      }
      if ((defined($options{request}->{credentials})) && (!defined($options{request}->{username}) || !defined($options{request}->{password}))) {
          $self->{output}->add_option_msg(short_msg => "You need to set --username= and --password= options when --credentials is used");
          $self->{output}->option_exit();
      }
      if ((defined($options{request}->{cert_pkcs12})) && (!defined($options{request}->{cert_file}) && !defined($options{request}->{cert_pwd}))) {
          $self->{output}->add_option_msg(short_msg => "You need to set --cert-file= and --cert-pwd= options when --pkcs12 is used");
          $self->{output}->option_exit();
      }
  
      $options{request}->{port_force} = $self->get_port();
  
      $options{request}->{headers} = {};
      if (defined($options{request}->{header})) {
          foreach (@{$options{request}->{header}}) {
              if (/^(:.+?|.+?):\s*(.*)/) {
                  $options{request}->{headers}->{$1} = $2;
              }
          }
      }
      foreach (keys %{$self->{add_headers}}) {
          $options{request}->{headers}->{$_} = $self->{add_headers}->{$_};
      }
  
      foreach my $method (('get', 'post')) {
          if (defined($options{request}->{$method . '_param'})) {
              $options{request}->{$method . '_params'} = {};
              foreach (@{$options{request}->{$method . '_param'}}) {
                  if (/^([^=]+)={0,1}(.*)$/s) {
                      my $key = $1;
                      my $value = defined($2) ? $2 : 1;
                      if (defined($options{request}->{$method . '_params'}->{$key})) {
                          if (ref($options{request}->{$method . '_params'}->{$key}) ne 'ARRAY') {
                              $options{request}->{$method . '_params'}->{$key} = [ $options{request}->{$method . '_params'}->{$key} ];
                          }
                          push @{$options{request}->{$method . '_params'}->{$key}}, $value;
                      } else {
                          $options{request}->{$method . '_params'}->{$key} = $value;
                      }
                  }
              }
          }
      }
  
      $self->{'backend_' . $self->{http_backend}}->check_options(%options);
  }
  
  sub get_port {
      my ($self, %options) = @_;
  
      my $port = '';
      if (defined($self->{options}->{port}) && $self->{options}->{port} ne '') {
          $port = $self->{options}->{port};
      } else {
          $port = 80 if ($self->{options}->{proto} eq 'http');
          $port = 443 if ($self->{options}->{proto} eq 'https');
      }
  
      return $port;
  }
  
  sub get_port_request {
      my ($self, %options) = @_;
  
      my $port = '';
      if (defined($self->{options}->{port}) && $self->{options}->{port} ne '') {
          $port = $self->{options}->{port};
      }
      return $port;
  }
  
  sub request {
      my ($self, %options) = @_;
  
      my $request_options = { %{$self->{options}} };
      foreach (keys %options) {
          $request_options->{$_} = $options{$_} if (defined($options{$_}));
      }
      $self->check_options(request => $request_options);
  
      return $self->{'backend_' . $self->{http_backend}}->request(request => $request_options);
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_first_header(%options);
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_header(%options);
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_code();
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_message();
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_certificate();
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_times();
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP abstraction layer.
  
  =head1 SYNOPSIS
  
  HTTP abstraction layer for lwp and curl backends
  
  =head1 HTTP GLOBAL OPTIONS
  
  =over 8
  
  =item B<--http-peer-addr>
  
  Set the address you want to connect to. Useful if hostname is only a vhost, to avoid IP resolution.
  
  =item B<--proxyurl>
  
  Proxy URL. Example: http://my.proxy:3128
  
  =item B<--proxypac>
  
  Proxy PAC file (can be a URL or a local file).
  
  =item B<--insecure>
  
  Accept insecure SSL connections.
  
  =item B<--http-backend>
  
  Perl library to use for HTTP transactions.
  Possible values are: lwp (default) and curl.
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_HTTP

$fatpacked{"centreon/plugins/misc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MISC';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::misc;
  
  use strict;
  use warnings;
  use utf8;
  use JSON::XS;
  use Safe;
  use Encode;
  
  use Exporter 'import';
  use feature 'state';
  
  our @EXPORT_OK = qw/change_seconds
                      flatten_arrays
                      flatten_to_hash
                      graphql_escape
                      is_empty
                      json_encode
                      json_decode
                      slurp_file
                      value_of/;
  
  sub execute {
      my (%options) = @_;
      
      if ($^O eq 'MSWin32') {
          return windows_execute(%options, timeout => $options{options}->{timeout});
      } else {
          return unix_execute(%options);
      }
  }
  
  sub windows_execute {
      my (%options) = @_;
      my $result;
      my ($stdout, $pid, $ended) = ('');
      my ($exit_code, $cmd);
  
      $cmd = $options{command_path} . '/' if (defined($options{command_path}));
      $cmd .= $options{command} . ' ' if (defined($options{command}));
      $cmd .= $options{command_options} if (defined($options{command_options}));
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Win32::Job',
          error_msg => "Cannot load module 'Win32::Job'."
      );
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Time::HiRes',
          error_msg => "Cannot load module 'Time::HiRes'."
      );
  
      $| = 1;
      pipe FROM_CHILD, TO_PARENT or do {
          $options{output}->add_option_msg(short_msg => "Internal error: can't create pipe from child to parent: $!");
          $options{output}->option_exit();
      };
      my $job = Win32::Job->new;
      my $stderr = 'NUL';
      $stderr = \*TO_PARENT if ($options{output}->is_debug());
      if (!($pid = $job->spawn(undef, $cmd,
                         { stdin => 'NUL',
                           stdout => \*TO_PARENT,
                           stderr => $stderr }))) {
          $options{output}->add_option_msg(short_msg => "Internal error: execution issue: $^E");
          $options{output}->option_exit();
      }
      close TO_PARENT;
  
      my $ein = '';
      vec($ein, fileno(FROM_CHILD), 1) = 1;
      $job->watch(
          sub {            
              my ($buffer);
              my $time = $options{timeout};
              my $last_time = Time::HiRes::time();
              $ended = 0;
              while (select($ein, undef, undef, $options{timeout})) {
                  if (sysread(FROM_CHILD, $buffer, 16384)) {
                      $buffer =~ s/\r//g;
                      $stdout .= $buffer;
                  } else {
                      $ended = 1;
                      last;
                  }
                  $options{timeout} -= Time::HiRes::time() - $last_time;
                  last if ($options{timeout} <= 0);         
                  $last_time = Time::HiRes::time();
              }
              return 1 if ($ended == 0);
              return 0;
          },
          0.1
      );
  
      $result = $job->status;
      close FROM_CHILD;    
  
      if ($ended == 0) {
          $options{output}->add_option_msg(short_msg => 'Command too long to execute (timeout)...');
          $options{output}->option_exit();
      }
      chomp $stdout;
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $result->{$pid}->{exitcode});
      }
  
      if ($result->{$pid}->{exitcode} != 0) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
  
      return ($stdout, $result->{$pid}->{exitcode});
  }
  
  sub unix_execute {
      my (%options) = @_;
      my $cmd = '';
      my $args = [];
      my ($lerror, $stdout, $exit_code);
  
      my $redirect_stderr = 1;
      $redirect_stderr = $options{redirect_stderr} if (defined($options{redirect_stderr}));
      my $wait_exit = 1;
      $wait_exit = $options{wait_exit} if (defined($options{wait_exit}));
  
      # Build command line
      # Can choose which command is done remotely (can filter and use local file)
      if (defined($options{options}->{remote}) && 
          ($options{options}->{remote} eq '' || !defined($options{label}) || $options{label} =~ /$options{options}->{remote}/)) {
          my $sub_cmd;
  
          $cmd = $options{options}->{ssh_path} . '/' if (defined($options{options}->{ssh_path}));
          $cmd .= $options{options}->{ssh_command} if (defined($options{options}->{ssh_command}));
  
          foreach (@{$options{options}->{ssh_option}}) {
              if (/^(.*?)(?:=(.*))?$/) {
                  push @$args, $1 if (defined($1));
                  push @$args, $2 if (defined($2));
              }
          }
  
          if (defined($options{options}->{ssh_address}) && $options{options}->{ssh_address} ne '') {
              push @$args, $options{options}->{ssh_address};
          } else {
              push @$args, $options{options}->{hostname};
          }
  
          if (defined($options{options}->{ssh_option_eol})) {
              foreach (@{$options{options}->{ssh_option_eol}}) {
                  if (/^(.*?)(?:=(.*))?$/) {
                      push @$args, $1 if (defined($1));
                      push @$args, $2 if (defined($2));
                  }
              }
          }
  
          $sub_cmd = 'sudo ' if (defined($options{sudo}));
          $sub_cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $sub_cmd .= $options{command} . ' ' if (defined($options{command}));
          $sub_cmd .= $options{command_options} if (defined($options{command_options}));
          # On some equipment. Cannot get a pseudo terminal
          if (defined($options{ssh_pipe}) && $options{ssh_pipe} == 1) {
              $cmd = "echo '" . $sub_cmd . "' | " . $cmd . ' ' . join(' ', @$args);
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          } else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  arguments => [@$args, $sub_cmd],
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      } else {
          $cmd = 'sudo ' if (defined($options{sudo}));
          $cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $cmd .= $options{command} if (defined($options{command}));
          $cmd .= ' ' . $options{command_options} if (defined($options{command_options}));
  
          if (defined($options{no_shell_interpretation}) and $options{no_shell_interpretation} ne '') {
              my @args = split(' ',$cmd);
              ($lerror, $stdout, $exit_code) = backtick(
                  command         => $args[0],
                  arguments       => [@args[1.. $#args]],
                  timeout         => $options{options}->{timeout},
                  wait_exit       => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
          else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command         => $cmd,
                  timeout         => $options{options}->{timeout},
                  wait_exit       => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      }
  
      if (defined($options{options}->{show_output}) && 
          ($options{options}->{show_output} eq '' || (defined($options{label}) && $options{label} eq $options{options}->{show_output}))) {
          print $stdout;
          exit $exit_code;
      }
  
      $stdout =~ s/\r//g;
      if ($lerror <= -1000) {
          $options{output}->add_option_msg(short_msg => $stdout);
          $options{output}->option_exit();
      }
  
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $exit_code);
      }
  
      if ($exit_code != 0 && (!defined($options{no_errors}) || !defined($options{no_errors}->{$exit_code}))) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
  
      return $stdout;
  }
  
  sub mymodule_load {
      my (%options) = @_;
      my $file;
      ($file = ($options{module} =~ /\.pm$/ ? $options{module} : $options{module} . '.pm')) =~ s{::}{/}g;
  
      eval {
          local $SIG{__DIE__} = 'IGNORE';
          require $file;
          $file =~ s{/}{::}g;
          $file =~ s/\.pm$//;
      };
      if ($@) {
          return 1 if (defined($options{no_quit}) && $options{no_quit} == 1);
          $options{output}->add_option_msg(long_msg => $@);
          $options{output}->add_option_msg(short_msg => $options{error_msg});
          $options{output}->option_exit();
      }
      return wantarray ? (0, $file) : 0;
  }
  
  sub backtick {
      my %arg = (
          command => undef,
          arguments => [],
          timeout => 30,
          wait_exit => 0,
          redirect_stderr => 0,
          @_,
      );
      my @output;
      my $pid;
      my $return_code;
  
      my $sig_do;
      if ($arg{wait_exit} == 0) {
          $sig_do = 'IGNORE';
          $return_code = undef;
      } else {
          $sig_do = 'DEFAULT';
      }
      local $SIG{CHLD} = $sig_do;
      $SIG{TTOU} = 'IGNORE';
      $| = 1;
  
      if (!defined($pid = open( KID, "-|" ))) {
          return (-1001, "Cant fork: $!", -1);
      }
  
      if ($pid) {
          
          eval {
             local $SIG{ALRM} = sub { die "Timeout by signal ALARM\n"; };
             alarm( $arg{timeout} );
             while (<KID>) {
                 chomp;
                 push @output, $_;
             }
  
             alarm(0);
          };
  
          if ($@) {
              if ($pid != -1) {
                  kill -9, $pid;
              }
  
              alarm(0);
              return (-1000, 'Command too long to execute (timeout)...', -1);
          } else {
              if ($arg{wait_exit} == 1) {
                  # We're waiting the exit code                
                  waitpid($pid, 0);
                  $return_code = ($? >> 8);
              }
              close KID;
          }
      } else {
          # child
          # set the child process to be a group leader, so that
          # kill -9 will kill it and all its descendents
          # We have ignore SIGTTOU to let write background processes
          setpgrp( 0, 0 );
  
          if ($arg{redirect_stderr} == 1) {
              open STDERR, '>&STDOUT';
          }
          if (scalar(@{$arg{arguments}}) <= 0) {
              exec($arg{command});
          } else {
              exec($arg{command}, @{$arg{arguments}});
          }
          # Exec is in error. No such command maybe.
          exit(127);
      }
  
      return (0, join("\n", @output), $return_code);
  }
  
  sub is_empty {
      my $value = shift;
      if (!defined($value) or $value eq '') {
          return 1;
      }
      return 0;
  }
  
  # Return the value of a complex perl variable (hash, array...) or a default value if it not defined.
  # The returned value will never be undef.
  # I.g:  value_of($hash, '->{key}->{subkey}', 'default')
  #       value_of($array, '->[0]', 'default')
  #       value_of($complex, '->{key}->[0]->{subkey}', 'default')
  sub value_of($$;$) {
      my ($variable, $expression, $default) = @_;
      $default //= '';
  
      return $default unless defined $variable;
  
      state $safe = do { my $s = Safe->new();
                         $s->share('$v');
                         $s;
                       };
      our $v = $variable;
      my $value = $safe->reval("\$v$expression", 1);
  
      return defined $value ? $value : $default;
  }
  
  sub trim {
      my ($value) = $_[0];
      
      # Sometimes there is a null character
      $value =~ s/\x00$//;
      $value =~ s/^[ \t\n]+//;
      $value =~ s/[ \t\n]+$//;
      return $value;
  }
  
  sub powershell_encoded {
      require Encode;
      require MIME::Base64;
      my $bytes = Encode::encode('utf16LE', $_[0]);
      return MIME::Base64::encode_base64($bytes, '');
  }
  
  sub powershell_escape {
      my ($value) = $_[0];
      $value =~ s/`/``/g;
      $value =~ s/#/`#/g;
      $value =~ s/'/`'/g;
      $value =~ s/"/`"/g;
      return $value;
  }
  
  sub graphql_escape($) {
      my ($value) = $_[0];
      $value =~ s/"/\\"/g;
      return $value;
  }
  
  # Returns an array from arrays containing values separated by $separator
  sub flatten_arrays($;$) {
      my ($array_of_values, $separator) = @_;
      $separator //= ',';
  
      return [ ] unless ref $array_of_values eq 'ARRAY';
  
      return [ map { split $separator } @{$array_of_values} ];
  }
  
  # Returns an hash from arrays containing values separated by $separator
  # Values are set to $default (1 if not defined)
  sub flatten_to_hash($;$;$) {
      my ($array_of_values, $separator, $default) = @_;
      $separator //= ',';
      $default //= 1;
  
      return { } unless ref $array_of_values eq 'ARRAY';
  
      return { map { $_ => $default } map { split $separator } @{$array_of_values} };
  }
  
  sub minimal_version {
      my ($version_src, $version_dst) = @_;
          
      # No Version. We skip   
      if (!defined($version_src) || !defined($version_dst) || 
          $version_src !~ /^[0-9]+(?:\.[0-9\.]+)*$/ || $version_dst !~ /^[0-9x]+(?:\.[0-9x]+)*$/) {
          return 1;
      }
    
      my @version_src = split /\./, $version_src;
      my @versions = split /\./, $version_dst;
      for (my $i = 0; $i < scalar(@versions); $i++) {
          return 1 if ($versions[$i] eq 'x');
          return 1 if (!defined($version_src[$i]));
          $version_src[$i] =~ /^([0-9]*)/;
          next if ($versions[$i] == int($1));
          return 0 if ($versions[$i] > int($1));
          return 1 if ($versions[$i] < int($1));
      }
      
      return 1;
  }
  
  sub change_seconds {
      my %options = @_;
      my ($str, $str_append) = ('', '');
      my $periods = [
          { unit => 'y', value => 31556926 },
          { unit => 'M', value => 2629743 },
          { unit => 'w', value => 604800 },
          { unit => 'd', value => 86400 },
          { unit => 'h', value => 3600 },
          { unit => 'm', value => 60 },
          { unit => 's', value => 1 },
      ];
      my %values = ('y' => 1, 'M' => 2, 'w' => 3, 'd' => 4, 'h' => 5, 'm' => 6, 's' => 7);
      my $sign = '';
      if ($options{value} < 0) {
          $sign = '-';
          $options{value} = abs($options{value});
      }
      
      foreach (@$periods) {
          next if (defined($options{start}) && $values{$_->{unit}} < $values{$options{start}});
          my $count = int($options{value} / $_->{value});
  
          next if ($count == 0);
          $str .= $str_append . $count . $_->{unit};
          $options{value} = $options{value} % $_->{value};
          $str_append = ' ';
      }
  
      if ($str eq '') {
          $str = $options{value};
          $str .= $options{start} if (defined($options{start}));
      }
      return $sign . $str;
  }
  
  sub scale_bytesbit {
      my (%options) = @_;
      
      my $base = 1024;
      if (defined($options{dst_unit}) && defined($options{src_unit})) {
          $options{value} *= 8 if ($options{dst_unit} =~ /b/ && $options{src_unit} =~ /B/);
          $options{value} /= 8 if ($options{dst_unit} =~ /B/ && $options{src_unit} =~ /b/);
          if ($options{dst_unit} =~ /b/) {
              $base = 1000;
          }
      }
          
      my %expo = ('' => 0, k => 1, m => 2, g => 3, t => 4, p => 5, e => 6);
      my ($src_expo, $dst_expo) = (0, 0);
      $src_expo = $expo{lc($options{src_quantity})} if (defined($options{src_quantity}) && $options{src_quantity} =~ /[kmgtpe]/i);
      if ($options{dst_unit} eq 'auto') {
          my @auto = ('', 'k', 'm', 'g', 't', 'p', 'e');
          my $i = defined($options{src_quantity}) ? $expo{$options{src_quantity}} : 0;
          for (; $i < scalar(@auto); $i++) {
              last if ($options{value} < $base);
              $options{value} = $options{value} / $base;
          }
  
          return ($options{value}, $auto[$i], $options{src_unit});
      } elsif (defined($options{dst_quantity}) && ($options{dst_quantity} eq '' || $options{dst_quantity} =~ /[kmgtpe]/i )) {
          my $dst_expo = $expo{lc($options{dst_quantity})};
          if ($dst_expo - $src_expo > 0) {
              $options{value} = $options{value} / ($base ** ($dst_expo - $src_expo));
          } elsif ($dst_expo - $src_expo < 0) {
              $options{value} = $options{value} * ($base ** (($dst_expo - $src_expo) * -1));
          }
      }
      
      return $options{value};
  }
  
  sub convert_bytes {
      my (%options) = @_;
  
      my %expo = (k => 1, m => 2, g => 3, t => 4, p => 5);
      my ($value, $unit) = ($options{value}, $options{unit});
      if (defined($options{pattern})) {
          return undef if ($value !~ /$options{pattern}/);
          $value = $1;
          $unit = $2;
      }
      
      my $base = defined($options{network}) ? 1000 : 1024;    
      if ($unit =~ /([kmgtp])i?b/i) {
          $value = $value * ($base ** $expo{lc($1)});
      }
  
      return $value;
  }
  
  sub convert_fahrenheit {
      my (%options) = @_;
  
      return ($options{value} - 32) / 1.8;
  }
  
  sub expand_exponential {
      my (%options) = @_;
  
      return $options{value} unless ($options{value} =~ /^(.*)e([-+]?)(.*)$/);
      my ($num, $sign, $exp) = ($1, $2, $3);
      my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
      return sprintf("%${sig}f", $options{value});
  }
  
  sub alert_triggered {
      my (%options) = @_;
  
      my ($rv_warn, $warning) = parse_threshold(threshold => $options{warning});
      my ($rv_crit, $critical) = parse_threshold(threshold => $options{critical});
  
      foreach ([$rv_warn, $warning], [$rv_crit, $critical]) {
          next if ($_->[0] == 0);
  
          if ($_->[1]->{arobase} == 0 && ($options{value} < $_->[1]->{start} || $options{value} > $_->[1]->{end})) {
              return 1;
          } elsif ($_->[1]->{arobase}  == 1 && ($options{value} >= $_->[1]->{start} && $options{value} <= $_->[1]->{end})) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub parse_threshold {
      my (%options) = @_;
  
      my $perf = trim($options{threshold});
      my $perf_result = { arobase => 0, infinite_neg => 0, infinite_pos => 0, start => '', end => '' };
  
      my $global_status = 1;    
      if ($perf =~ /^(\@?)((?:~|(?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?|):)?((?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?)?$/) {
          $perf_result->{start} = $2 if (defined($2));
          $perf_result->{end} = $3 if (defined($3));
          $perf_result->{arobase} = 1 if (defined($1) && $1 eq '@');
          $perf_result->{start} =~ s/[\+:]//g;
          $perf_result->{end} =~ s/\+//;
          if ($perf_result->{start} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{start} = scale_bytesbit(
                  value => $perf_result->{start},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{end} = scale_bytesbit(
                  value => $perf_result->{end},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} eq '') {
              $perf_result->{end} = 1e500;
              $perf_result->{infinite_pos} = 1;
          }
          $perf_result->{start} = 0 if ($perf_result->{start} eq '');      
          $perf_result->{start} =~ s/,/\./;
          $perf_result->{end} =~ s/,/\./;
          
          if ($perf_result->{start} eq '~') {
              $perf_result->{start} = -1e500;
              $perf_result->{infinite_neg} = 1;
          }
      } else {
          $global_status = 0;
      }
  
      return ($global_status, $perf_result);
  }
  
  sub get_threshold_litteral {
      my (%options) = @_;
  
      my $perf_output = ($options{arobase} == 1 ? '@' : '') . 
          (($options{infinite_neg} == 0) ? $options{start} : '~') . 
          ':' . 
          (($options{infinite_pos} == 0) ? $options{end} : '');
      return $perf_output;
  }
  
  sub set_timezone {
      my (%options) = @_;
  
      return {} if (!defined($options{name}) || $options{name} eq '');
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'DateTime::TimeZone',
          error_msg => "Cannot load module 'DateTime::TimeZone'."
      );
      if (DateTime::TimeZone->is_valid_name($options{name})) {
          return { time_zone => DateTime::TimeZone->new(name => $options{name}) };
      }
  
      # try to manage syntax (:Pacific/Noumea for example)
      if ($options{name} =~ /^:(.*)$/ && DateTime::TimeZone->is_valid_name($1)) {
          return { time_zone => DateTime::TimeZone->new(name => $1) };
      }
  
      return {};
  }
  
  sub uniq {
      my %seen;
  
      return grep { !$seen{$_}++ } @_;
  }
  
  sub eval_ssl_options {
      my (%options) = @_;
  
      my $ssl_context = {};
      return $ssl_context if (!defined($options{ssl_opt}));
      
      my ($rv) = centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Safe',
          no_quit => 1
      );
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'IO::Socket::SSL',
          no_quit => 1
      );
  
      my $safe;
      if ($rv == 0) {
          $safe = Safe->new();
          $safe->permit_only(':base_core', 'rv2gv', 'padany');
          $safe->share('$values');
          $safe->share('$assign_var');
          $safe->share_from('IO::Socket::SSL', [
              'SSL_VERIFY_NONE', 'SSL_VERIFY_PEER', 'SSL_VERIFY_FAIL_IF_NO_PEER_CERT', 'SSL_VERIFY_CLIENT_ONCE',
              'SSL_RECEIVED_SHUTDOWN', 'SSL_SENT_SHUTDOWN',
              'SSL_OCSP_NO_STAPLE', 'SSL_OCSP_MUST_STAPLE', 'SSL_OCSP_FAIL_HARD', 'SSL_OCSP_FULL_CHAIN', 'SSL_OCSP_TRY_STAPLE'
          ]);
      }
      
      foreach (@{$options{ssl_opt}}) {
          if (/(SSL_[A-Za-z_]+)\s+=>\s*(\S+)/) {
              my ($label, $eval) = ($1, $2);
  
              our $assign_var;
              if (defined($safe)) {
                  $safe->reval("\$assign_var = $eval", 1);
                  if ($@) {
                      die 'Unsafe code evaluation: ' . $@;
                  }
              } else {
                  eval "\$assign_var = $eval";
              }
  
              $ssl_context->{$label} = $assign_var;
          }
      }
  
      return $ssl_context;
  }
  
  sub slurp_file {
      my (%options) = @_;
  
      my $content = do {
          local $/ = undef;
          if (!open my $fh, '<', $options{file}) {
              $options{output}->add_option_msg(short_msg => "Could not open file $options{file}: $!");
              $options{output}->option_exit();
          }
          <$fh>;
      };
  
      return $content;
  }
  
  sub sanitize_command_param {
      my (%options) = @_;
  
      return if (!defined($options{value}));
  
      $options{value} =~ s/[`;!&|]//g;
      return $options{value};
  }
  
  my $security_file = '/etc/centreon-plugins/security.json';
  my $whitelist_file = '/etc/centreon-plugins/whitelist.json';
  if ($^O eq 'MSWin32') {
      $security_file = 'C:/Program Files/centreon-plugins/security.json';
      $whitelist_file = 'C:/Program Files/centreon-plugins/whitelist.json';
  }
  
  sub check_security_command {
      my (%options) = @_;
  
      return 0 if (!(
          (defined($options{command}) && $options{command} ne '') ||
          (defined($options{command_options}) && $options{command_options} ne '') ||
          (defined($options{command_path}) && $options{command_path} ne ''))
      );
  
      return 0 if (! -r "$security_file" || -z "$security_file");
  
      my $content = slurp_file(output => $options{output}, file => $security_file);
  
      my $security;
      eval {
          $security = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode security file content');
          $options{output}->option_exit();
      }
  
      if (defined($security->{block_command_overload}) && $security->{block_command_overload} == 1) {
          $options{output}->add_option_msg(short_msg => 'Cannot overload command (security)');
          $options{output}->option_exit();
      }
  
      return 0;
  }
  
  sub check_security_whitelist {
      my (%options) = @_;
  
      my $command = $options{command};
      $command = $options{command_path} . '/' . $options{command} if (defined($options{command_path}) && $options{command_path} ne '');
      $command .= ' ' . $options{command_options} if (defined($options{command_options}) && $options{command_options} ne '');
  
      return 0 if (! -r "$security_file" || -z "$security_file");
  
      my $content = slurp_file(output => $options{output}, file => $security_file);
  
      my $security;
      eval {
          $security = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode security file content');
          $options{output}->option_exit();
      }
  
      return 0 if (!defined($security->{whitelist_enabled}) || $security->{whitelist_enabled} !~ /^(?:1|true)$/i);
  
      if (! -r "$whitelist_file") {
          $options{output}->add_option_msg(short_msg => 'Cannot read whitelist security file content');
          $options{output}->option_exit();
      }
  
      if (-z "$whitelist_file") {
          $options{output}->add_option_msg(short_msg => 'Cannot execute command (security)');
          $options{output}->option_exit();
      }
  
      $content = slurp_file(output => $options{output}, file => $whitelist_file);
  
      my $whitelist;
      eval {
          $whitelist = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode whitelist security file content');
          $options{output}->option_exit();
      }
  
      my $matched = 0;
      foreach (@$whitelist) {
          if ($command =~ /$_/) {
              $matched = 1;
              last;
          }
      }
  
      if ($matched == 0) {
          $options{output}->add_option_msg(short_msg => 'Cannot execute command (security)');
          $options{output}->option_exit();
      }
  
      return 0;
  }
  
  sub json_decode {
      my ($content, %options) = @_;
  
      $content =~ s/\r//mg;
  
      $content = decode('UTF-8', $content, Encode::FB_DEFAULT);
  
      my $decoder = JSON::XS->new;
  
      # this option
      if ($options{booleans_as_strings}) {
          # boolean_values() is not available on old versions of JSON::XS (Alma 8 still provides v3.04)
          if (JSON::XS->can('boolean_values')) {
              $decoder = $decoder->boolean_values("false", "true");
          } else {
              # if boolean_values is not available, perform a dirty substitution of booleans
              $content =~ s/"(\w+)"\s*:\s*(true|false)(\s*,?)/"$1": "$2"$3/gm;
          }
      }
  
      my $object = eval { $decoder->decode($content) };
  
      if ($@) {
          # To keep compatibilty with old json_decode:
          # If 'output' not set, print error on STDERR unless 'silence' is set
          # Otherwise print error on 'output' and exit unless 'no_exit' is set
          my $msg = $options{errstr} // "Cannot decode JSON string: $@";
  
          if ($options{output}) {
              $options{output}->option_exit(short_msg => $msg)
                  unless $options{no_exit};
  
              $options{output}->output_add(long_msg => $msg, debug => 1);
          } else {
              warn "$msg\n" unless $options{silence};
          }
  
          return undef;
      }
  
      return $object;
  }
  
  sub json_encode {
      my ($object) = @_;
  
      $object =~ s/\r//mg;
      my $encoded;
      eval {
          $encoded = encode_json($object);
      };
      if ($@) {
          print STDERR 'Cannot encode object to JSON. Error message: ' . $@;
          return undef;
      }
  
      return $encoded;
  }
  
  sub is_local_ip($) {
      my ($ip) = @_;
  
      return 0 unless $ip;
  
      return 1 if $ip =~ /^127\./;
      return 1 if $ip =~ /^10\./;
      return 1 if $ip =~ /^192\.168\./;
      return 1 if $ip =~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./;
      return 1 if $ip =~ /^169\.254\./;
      return 1 if $ip eq '0.0.0.0';
  
      return 0;
  }
  
  # This function is used with "sort", it sorts an array of IP addresses.
  # $_[0] and $_[1] correspond to Perl's special variables $a and $b used by sort.
  # I can't use $a and $b directly here, otherwise Perl generates a warning: "uninitialized value".
  sub sort_ips($$) {
      my @a = split /\./, $_[0];
      my @b = split /\./, $_[1];
      return $a[0] <=> $b[0] || $a[1] <=> $b[1] || $a[2] <=> $b[2] || $a[3] <=> $b[3]
  }
  
  # function to assess if a string has to be excluded given an include regexp and an exclude regexp
  sub is_excluded {
      my ($string, $include_regexp, $exclude_regexp) = @_;
      return 1 unless defined($string);
      return 1 if (defined($exclude_regexp) && $exclude_regexp ne '' && $string =~ /$exclude_regexp/);
      return 0 if (!defined($include_regexp) || $include_regexp eq '' || $string =~ /$include_regexp/);
  
      return 1;
  }
  
  1;
  
  
  =head1 NAME
  
  centreon::plugins::misc - A collection of miscellaneous utility functions for Centreon plugins.
  
  =head1 SYNOPSIS
  
      use centreon::plugins::misc;
  
      my $result = centreon::plugins::misc::execute(
          command => 'ls',
          command_options => '-l'
      );
  
  =head1 DESCRIPTION
  
  The `centreon::plugins::misc` module provides a variety of utility functions that can be used in Centreon plugins. These functions include command execution, string manipulation, file handling, and more.
  
  =head1 METHODS
  
  =head2 execute
  
      my $result = centreon::plugins::misc::execute(%options);
  
  Executes a command and returns the result.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 windows_execute
  
      my ($stdout, $exit_code) = centreon::plugins::misc::windows_execute(%options);
  
  Executes a command on Windows and returns the output and exit code.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 unix_execute
  
      my $stdout = centreon::plugins::misc::unix_execute(%options);
  
  Executes a command on Unix and returns the output.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =item * C<wait_exit> - bool.
  
  =item * C<redirect_stderr> - bool.
  
  =item * C<sudo> - bool prepend sudo to the command executed.
  
  =item * C<no_shell_interpretation> - bool don't use sh interpolation on command executed
  
  
  =back
  
  =back
  
  =head2 mymodule_load
  
      my $result = centreon::plugins::misc::mymodule_load(%options);
  
  Loads a Perl module dynamically.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<module> - The module to load.
  
  =item * C<error_msg> - Error message to display if the module cannot be loaded.
  
  =back
  
  =back
  
  =head2 backtick
  
      my ($status, $output, $exit_code) = centreon::plugins::misc::backtick(%options);
  
  Executes a command using backticks and returns the status, output, and exit code.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<arguments> - Arguments for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 is_empty
  
      my $is_empty = centreon::plugins::misc::is_empty($value);
  
  Checks if a value is empty.
  
  =over 4
  
  =item * C<$value> - The value to check.
  
  =back
  
  =head2 value_of
  
      my $value = centreon::plugins::misc::value_of($variable, $expression, $default);
  
  Return the value of a complex perl variable (hash, array...) or a default value if it not defined.
  
  =over 4
  
  =item * C<$value> - The return value.
  
  =item * C<$expression> - The expression to test.
  
  =item * C<$default> - The default value to return if expression is not defined (optional).
  
  =back
  
  =head2 trim
  
      my $trimmed_value = centreon::plugins::misc::trim($value);
  
  Trims whitespace from a string.
  
  =over 4
  
  =item * C<$value> - The string to trim.
  
  =back
  
  =head2 powershell_encoded
  
      my $encoded = centreon::plugins::misc::powershell_encoded($value);
  
  Encodes a string for use in PowerShell.
  
  =over 4
  
  =item * C<$value> - The string to encode.
  
  =back
  
  =head2 powershell_escape
  
      my $escaped = centreon::plugins::misc::powershell_escape($value);
  
  Escapes special characters in a string for use in PowerShell.
  
  =over 4
  
  =item * C<$value> - The string to escape.
  
  =back
  
  =head2 graphql_escape
  
      my $escaped = centreon::plugins::misc::graphql_escape($value);
  
  Escapes special characters in a string for use in GraphQL query.
  
  =over 4
  
  =item * C<$value> - The string to escape.
  
  =back
  
  =head2 flatten_arrays
  
      my $array = centreon::plugins::misc::flatten_arrays($arrays, $separator);
  
  Returns an array from arrays containing values separated by a separator ( default comma ).
  
  =over 4
  
  =item * C<$arrays> - Arrays to expand.
  
  =item * C<$separator> - Separator ( comma if undef ).
  
  =back
  
  =head2 flatten_to_hash
  
      my $hash = centreon::plugins::misc::flatten_to_hash($arrays, $separator, $default);
  
  Returns a hash from arrays containing values separated by a separator ( default comma ). Values are set to optional parameter $default ( 1 if undef ).
  
  =over 4
  
  =item * C<$arrays> - Arrays to expand.
  
  =item * C<$separator> - Separator ( comma if undef ).
  
  =item * C<$default> - Default value ( 1 if undef ).
  
  =back
  
  =head2 minimal_version
  
      my $is_minimal = centreon::plugins::misc::minimal_version($version_src, $version_dst);
  
  Checks if a version is at least a specified version.
  
  =over 4
  
  =item * C<$version_src> - The source version.
  
  =item * C<$version_dst> - The destination version.
  
  =back
  
  =head2 change_seconds
  
      my $formatted_time = centreon::plugins::misc::change_seconds(%options);
  
  Converts seconds into a human-readable format.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The number of seconds.
  
  =item * C<start> - The starting unit.
  
  =back
  
  =back
  
  =head2 scale_bytesbit
  
      my $scaled_value = centreon::plugins::misc::scale_bytesbit(%options);
  
  Scales a value between bytes and bits.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to scale.
  
  =item * C<src_unit> - The source unit.
  
  =item * C<dst_unit> - The destination unit.
  
  =back
  
  =back
  
  =head2 convert_bytes
  
      my $bytes = centreon::plugins::misc::convert_bytes(%options);
  
  Converts a value to bytes.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to convert.
  
  =item * C<unit> - The unit of the value.
  
  =back
  
  =back
  
  =head2 convert_fahrenheit
  
      my $celsius = centreon::plugins::misc::convert_fahrenheit(%options);
  
  Converts a temperature from Fahrenheit to Celsius.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The temperature in Fahrenheit.
  
  =back
  
  =back
  
  =head2 expand_exponential
  
      my $expanded = centreon::plugins::misc::expand_exponential(%options);
  
  Expands an exponential value to its full form.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The exponential value.
  
  =back
  
  =back
  
  =head2 alert_triggered
  
      my $is_triggered = centreon::plugins::misc::alert_triggered(%options);
  
  Checks if an alert is triggered based on thresholds.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to check.
  
  =item * C<warning> - The warning threshold.
  
  =item * C<critical> - The critical threshold.
  
  =back
  
  =back
  
  =head2 parse_threshold
  
      my ($status, $threshold) = centreon::plugins::misc::parse_threshold(%options);
  
  Parses a threshold string.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<threshold> - The threshold string.
  
  =back
  
  =back
  
  =head2 get_threshold_litteral
  
      my $threshold_str = centreon::plugins::misc::get_threshold_litteral(%options);
  
  Returns the literal representation of a threshold.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<arobase> - Indicates if the threshold is inclusive.
  
  =item * C<start> - The start of the threshold.
  
  =item * C<end> - The end of the threshold.
  
  =back
  
  =back
  
  =head2 set_timezone
  
      my $timezone = centreon::plugins::misc::set_timezone(%options);
  
  Sets the timezone.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<name> - The name of the timezone.
  
  =back
  
  =back
  
  =head2 uniq
  
      my @unique = centreon::plugins::misc::uniq(@values);
  
  Returns a list of unique values.
  
  =over 4
  
  =item * C<@values> - The list of values.
  
  =back
  
  =head2 eval_ssl_options
  
      my $ssl_context = centreon::plugins::misc::eval_ssl_options(%options);
  
  Evaluates SSL options.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<ssl_opt> - The SSL options.
  
  =back
  
  =back
  
  =head2 slurp_file
  
      my $content = centreon::plugins::misc::slurp_file(%options);
  
  Reads the content of a file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<file> - The file to read.
  
  =back
  
  =back
  
  =head2 sanitize_command_param
  
      my $sanitized = centreon::plugins::misc::sanitize_command_param(%options);
  
  Sanitizes a command parameter.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to sanitize.
  
  =back
  
  =back
  
  =head2 check_security_command
  
      my $status = centreon::plugins::misc::check_security_command(%options);
  
  Checks the security of a command.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to check.
  
  =item * C<command_options> - Options for the command.
  
  =back
  
  =back
  
  =head2 check_security_whitelist
  
      my $status = centreon::plugins::misc::check_security_whitelist(%options);
  
  Checks if a command is in the security whitelist.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to check.
  
  =item * C<command_options> - Options for the command.
  
  =back
  
  =back
  
  =head2 json_decode
  
      my $decoded = centreon::plugins::misc::json_decode($content, %options);
  
  Decodes a JSON string.
  
  =over 4
  
  =item * C<$content> - The JSON string to decode and transform into an object.
  
  =item * C<%options> - Options passed to the function.
  
  =over 4
  
  =item * C<booleans_as_strings> - Defines whether booleans must be converted to C<true>/C<false> strings instead of
  JSON:::PP::Boolean values. C<1> => strings, C<0> => booleans.
  
  =item * C<errstr> - Custom error message to display if JSON string cannot be decoded.
  
  =item * C<output> - Output object to use for displaying errors.
  
  =item * C<no_exit> - Do not exit if there is an error and C<output> is defined.
  
  =item * C<silence> - Do not print error on STDERR if C<output> is not defined.
  
  =back
  
  =back
  
  =head2 json_encode
  
      my $encoded = centreon::plugins::misc::json_encode($object);
  
  Encodes an object to a JSON string.
  
  =over 4
  
  =item * C<$object> - The object to encode.
  
  =back
  
  =head2 is_local_ip
  
      my $is_local = centreon::plugins::misc::is_local_ip($ip);
  
  Returns 1 if an IPv4 IP is within a local address range.
  
  =over 4
  
  =item * C<$ip> - IP to test.
  
  =back
  
  =head2 sort_ips
  
      my @array = ( '192.168.0.3', '127.0.0.1' );
      @array = sort centreon::plugins::misc::sort_ips @array;
  
  Returns a sorted array.
  
  =over 4
  
  =item * C<@array> - An array containing IPs to be sorted.
  
  =back
  
  =head2 is_excluded
  
      my $excluded = is_excluded($string, $include_regexp, $exclude_regexp);
  
  Determines whether a string should be excluded based on include and exclude regular expressions.
  
  =over 4
  
  =item * C<$string> - The string to evaluate. If undefined, the function returns 1 (excluded).
  
  =item * C<$include_regexp> - A regular expression to include the string.
  
  =item * C<$exclude_regexp> - A regular expression to exclude the string. If defined and matches the string, the function returns 1 (excluded).
  
  =back
  
  Returns 1 if the string is excluded, 0 if it is included.
  The string is excluded if $exclude_regexp is defined and matches the string, or if $include_regexp is defined and does
  not match the string. The string will also be excluded if it is undefined.
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
CENTREON_PLUGINS_MISC

$fatpacked{"centreon/plugins/mode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MODE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::mode;
  
  use strict;
  use warnings;
  use centreon::plugins::perfdata;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      $self->{perfdata} = centreon::plugins::perfdata->new(output => $options{output});
      
      %{$self->{option_results}} = ();
      @{$self->{option_extras}} = @{$options{options}->{extra_arguments}};
      $self->{output} = $options{output};
      $self->{output}->use_new_perfdata(value => 1)
          if (defined($options{force_new_perfdata}) && $options{force_new_perfdata} == 1);
      $self->{mode} = $options{mode};
      $self->{version} = '1.0';
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # options{default} = { mode_xxx => { option_name => option_value }, }
      %{$self->{option_results}} = %{$options{option_results}};
      # Manage default value
      return if (!defined($options{default}));
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              foreach my $value (keys %{$options{default}->{$_}}) {
                  if (!defined($self->{option_results}->{$value})) {
                      $self->{option_results}->{$value} = $options{default}->{$_}->{$value};
                  }
              }
          }
      }
  }
  
  sub version {
      my ($self, %options) = @_;
      
      $self->{output}->add_option_msg(short_msg => "Mode Version: " . $self->{version});
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
  }
  
  1;
  
  
CENTREON_PLUGINS_MODE

$fatpacked{"centreon/plugins/multi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MULTI';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::multi;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'modes-exec:s'   => { name => 'modes_exec' },
          'option-mode:s@' => { name => 'option_mode' }
      });
      $self->{options} = $options{options};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (!defined($self->{option_results}->{modes_exec})) {
          $self->{output}->add_option_msg(short_msg => "Need to specify --modes-exec option.");
          $self->{output}->option_exit(); 
      }
      $self->{options_mode_extra} = {};
      if (defined($self->{option_results}->{option_mode})) {
          foreach (@{$self->{option_results}->{option_mode}}) {
              next if (! /^(.+?),(.*)$/);
              $self->{options_mode_extra}->{$1} = [] if (!defined($self->{options_mode_extra}->{$1}));
              push @{$self->{options_mode_extra}->{$1}}, $2;
          }
      }
  
      $self->{modes} = $options{modes};
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{output}->parameter(attr => 'nodisplay', value => 1);
      $self->{output}->parameter(attr => 'noexit_die', value => 1);
      $self->{output}->use_new_perfdata(value => 1);
  
      my @modes = split /,/, $self->{option_results}->{modes_exec};
      foreach (@modes) {
          next if (!defined($self->{modes}->{$_}));
          eval {
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output},
                  module => $self->{modes}->{$_}, 
                  error_msg => "Cannot load module --mode $_"
              );
              @ARGV = (@{$self->{options_mode_extra}->{$_}}) if (defined($self->{options_mode_extra}->{$_}));
              $self->{output}->mode(name => $_);
  
              my $mode = $self->{modes}->{$_}->new(options => $self->{options}, output => $self->{output}, mode => $_);
              $self->{options}->parse_options();
              my $option_results = $self->{options}->get_options();
              $mode->check_options(option_results => $option_results, %options);
              $mode->run(%options);
          };
          if ($@) {
              $self->{output}->output_add(long_msg => 'eval result mode ' . $_ . ': ' . $@, debug => 1);
          }
      }
  
      $self->{output}->mode(name => 'multi');
      $self->{output}->parameter(attr => 'nodisplay', value => 0);
      $self->{output}->parameter(attr => 'noexit_die', value => 0);
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check multiple modes at once.
  
  =over 8
  
  =item B<--modes-exec>
  
  Modes to use, separated by commas.
  Example for linux: --modes-exec=cpu,memory,storage,interfaces
  
  =item B<--option-mode>
  
  Define options for the modes selected in --modes-exec.
  The option can be used several times.
  E.g.: to define two options for the interfaces mode and one for the storage mode:
  --option-mode='interfaces,--statefile-dir=/tmp' --option-mode='interfaces,--add-traffic' --option-mode='storage,--statefile-dir=/tmp'
  
  =back
  
  =cut
CENTREON_PLUGINS_MULTI

$fatpacked{"centreon/plugins/options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OPTIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::options;
  
  use Pod::Usage;
  use strict;
  use warnings;
  
  my $alternative = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{pod_where_loaded} = 0;
      $self->{sanity} = 0;
      $self->{options_stored} = {};
      $self->{options} = {};
      @{$self->{pod_package}} = ();
      $self->{pod_packages_once} = {};
      $self->{extra_arguments} = [];
  
      if ($alternative == 0) {
          require Getopt::Long;
          Getopt::Long->import();
          Getopt::Long::Configure("pass_through");
          Getopt::Long::Configure('bundling');
          Getopt::Long::Configure('no_auto_abbrev');
      } else {
          require centreon::plugins::alternative::Getopt;
          $centreon::plugins::alternative::Getopt::warn_message = 0;
          centreon::plugins::alternative::Getopt->import();
      }
  
      return $self;
  }
  
  sub set_sanity {
      my ($self, %options) = @_;
  
      if ($alternative == 0) {
          Getopt::Long::Configure('no_pass_through');
      } else {
          $centreon::plugins::alternative::Getopt::warn_message = 1;
      }
  
      $self->{sanity} = 1;
  }
  
  sub set_output {
      my ($self, %options) = @_;
  
      $self->{output} = $options{output};
  }
  
  sub display_help {
      my ($self, %options) = @_;
  
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          my $where = $self->pod_where(package => $_->{package});
  
          {
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(
                  -exitval => 'NOEXIT', -input => $where,
                  -verbose => 99, 
                  -sections => $_->{sections}
              ) if (defined($where));
          }
  
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  sub add_help {
      my ($self, %options) = @_;
      # $options{package} = string package
      # $options{sections} = string sections
      # $options{help_first} = put at the beginning
      # $options{once} = put help only one time for a package
  
      if (defined($options{once}) && defined($self->{pod_packages_once}->{$options{package}})) {
          return ;
      }
  
      if (defined($options{help_first})) {
          unshift @{$self->{pod_package}}, {package => $options{package}, sections => $options{sections}};
      } else {
          push @{$self->{pod_package}}, { package => $options{package}, sections => $options{sections} };
      }
  
      $self->{pod_packages_once}->{$options{package}} = 1;
  }
  
  sub add_options {
      my ($self, %options) = @_;
      # $options{arguments} = ref to hash table with string and name to store (example: { 'mode:s' => { name => 'mode', default => 'defaultvalue' )
  
      foreach (keys %{$options{arguments}}) {
          if (defined($options{arguments}->{$_}->{redirect})) {
              $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{redirect}};
              next;
          }
  
          if (defined($options{arguments}->{$_}->{default})) {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = $options{arguments}->{$_}->{default};
          } else {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = undef;
          }
          
          $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{name}};
      }
  }
  
  sub parse_options {
      my $self = shift;
      #%{$self->{options_stored}} = ();
  
      my $save_warn_handler;
      if ($self->{sanity} == 1) {
          $save_warn_handler = $SIG{__WARN__};
          $SIG{__WARN__} = sub {
              $self->{output}->add_option_msg(short_msg => $_[0]);
              $self->{output}->option_exit(nolabel => 1);
          };
      }
  
      # Store all arguments placed after the special argument "--" in the 'extra_arguments' list
      $self->{options}->{'_double_dash_'} = \$self->{extra_arguments};
  
      GetOptions(
         %{$self->{options}}
      );
      %{$self->{options}} = ();
  
      $SIG{__WARN__} = $save_warn_handler if ($self->{sanity} == 1);
  }
  
  sub pod_where {
      my ($self, %options) = @_;
  
      if ($self->{pod_where_loaded} == 0) {
          $self->{pod_where_loaded} = 1;
          my ($code) = centreon::plugins::misc::mymodule_load(
              module => 'Pod::Find',
              no_quit => 1
          );
          if ($code) {
              $code = centreon::plugins::misc::mymodule_load(
                  module => 'Pod::Simple::Search',
                  no_quit => 1
              );
              die "Cannot load module 'Pod::Simple::Search'" if ($code);
              $self->{pod_where_loaded} = 2;
              $self->{pod_simple_search} = Pod::Simple::Search->new();
              $self->{pod_simple_search}->inc(1);
          }
      }
  
      if ($self->{pod_where_loaded} == 1) {
          return Pod::Find::pod_where({-inc => 1}, $options{package});
      }
      
      return $self->{pod_simple_search}->find($options{package});
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{options_stored}->{$options{argument}};
  }
  
  sub get_options {
      my $self = shift;
  
      return $self->{options_stored};
  }
  
  sub clean {
      my $self = shift;
  
      $self->{options_stored} = {};
  }
  
  1;
  
CENTREON_PLUGINS_OPTIONS

$fatpacked{"centreon/plugins/output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OUTPUT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::output;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{options})) {
          print "Class Output: Need to specify 'options' argument to load.\n";
          exit 3;
      }
  
      $options{options}->add_options(arguments => {
          'explode-perfdata-max:s@' => { name => 'explode_perfdata_max' },
          'range-perfdata:s'        => { name => 'range_perfdata' },
          'filter-perfdata:s'       => { name => 'filter_perfdata' },
          'filter-perfdata-adv:s'   => { name => 'filter_perfdata_adv' },
          'change-perfdata:s@'      => { name => 'change_perfdata' },
          'extend-perfdata:s@'      => { name => 'extend_perfdata' },
          'extend-perfdata-group:s@'=> { name => 'extend_perfdata_group' },
          'change-exit:s@'          => { name => 'change_exit' },
          'change-short-output:s@'  => { name => 'change_short_output' },
          'change-long-output:s@'   => { name => 'change_long_output' },
          'change-output-adv:s@'    => { name => 'change_output_adv' },
          'use-new-perfdata'        => { name => 'use_new_perfdata' },
          'filter-uom:s'            => { name => 'filter_uom' },
          'verbose'                 => { name => 'verbose' },
          'debug'                   => { name => 'debug' },
          'debug-stream'            => { name => 'debug_stream' },
          'opt-exit:s'              => { name => 'opt_exit', default => 'unknown' },
          'output-xml'              => { name => 'output_xml' },
          'output-json'             => { name => 'output_json' },
          'output-ignore-perfdata'  => { name => 'output_ignore_perfdata' },
          'output-ignore-label'     => { name => 'output_ignore_label' },
          'output-openmetrics'      => { name => 'output_openmetrics' },
          'output-file:s'           => { name => 'output_file' },
          'disco-format'            => { name => 'disco_format' },
          'disco-show'              => { name => 'disco_show' },
          'float-precision:s'       => { name => 'float_precision', default => 8 },
          'source-encoding:s'       => { name => 'source_encoding' , default => 'UTF-8' }
      });
  
      $self->{option_results} = {};
      $self->{option_msg} = [];
  
      $self->{nodisplay} = 0;
      $self->{noexit_die} = 0;
  
      $self->{is_output_xml} = 0;
      $self->{is_output_json} = 0;
      $self->{errors} = {OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, PENDING => 4};
      $self->{errors_num} = {0 => 'OK', 1 => 'WARNING', 2 => 'CRITICAL', 3 => 'UNKNOWN', 4 => 'PENDING'};
      $self->{myerrors} = {0 => "OK", 1 => "WARNING", 3 => "UNKNOWN", 7 => "CRITICAL"};
      $self->{myerrors_mask} = {CRITICAL => 7, WARNING => 1, UNKNOWN => 3, OK => 0};
      $self->{global_short_concat_outputs} = {OK => undef, WARNING => undef, CRITICAL => undef, UNKNOWN => undef, UNQUALIFIED_YET => undef};
      $self->{global_short_outputs} = {OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [], UNQUALIFIED_YET => []};
      $self->{global_long_output} = [];
      $self->{perfdatas} = [];
      $self->{explode_perfdatas} = {};
      $self->{change_perfdata} = {};
      $self->{explode_perfdata_total} = 0;
      $self->{range_perfdata} = 0;
      $self->{global_status} = 0;
      $self->{encode_import} = 0;
      $self->{perlqq} = 0;
      $self->{safe_test} = 0;
  
      $self->{disco_elements} = [];
      $self->{disco_entries} = [];
  
      $self->{plugin} = '';
      $self->{mode} = '';
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
  
      %{$self->{option_results}} = %{$options{option_results}};
      $self->{option_results}->{opt_exit} = lc($self->{option_results}->{opt_exit});
      if (!$self->is_litteral_status(status => $self->{option_results}->{opt_exit})) {
          $self->add_option_msg(short_msg => "Unknown value '" . $self->{option_results}->{opt_exit}  . "' for --opt-exit.");
          $self->option_exit(exit_litteral => 'unknown');
      }
      # Go in XML Mode
      if ($self->is_disco_show() || $self->is_disco_format()) {
          # By Default XML
          if (!defined($self->{option_results}->{output_json})) {
              $self->{option_results}->{output_xml} = 1;
          }
      }
  
      if (defined($self->{option_results}->{range_perfdata})) {
          $self->{range_perfdata} = $self->{option_results}->{range_perfdata};
          $self->{range_perfdata} = 1 if ($self->{range_perfdata} eq '');
          if ($self->{range_perfdata} !~ /^[012]$/) {
              $self->add_option_msg(short_msg => "Wrong range-perfdata option '" . $self->{range_perfdata} . "'");
              $self->option_exit();
          }
      }
  
      if (defined($self->{option_results}->{change_output_adv})) {
          foreach (@{$self->{option_results}->{change_output_adv}}) {
              my ($expr, $short_output, $exit_code) = split /,/;
              next if (!defined($expr) || $expr eq '');
  
              $expr =~ s/%\{(.*?)\}/\$values->{$1}/g;
              $expr =~ s/%\((.*?)\)/\$values->{$1}/g;
  
              if ( defined($exit_code) && $exit_code ne '' && defined( $self->{errors}->{uc($exit_code)} ) ) {
                  $exit_code = uc($exit_code);
              } else {
                  $exit_code = undef;
              }
  
              $self->{change_output_adv} = [] if (!defined($self->{change_output_adv}));
              push @{$self->{change_output_adv}}, {
                  expr => $expr,
                  short_output => $short_output,
                  exit_code => $exit_code
              };
          }
      }
  
      if (defined($self->{option_results}->{change_exit})) {
          $self->{change_exit} = {};
          foreach (@{$self->{option_results}->{change_exit}}) {
              my ($src, $dst) = split(/=/);
              next if (!defined($src) || !defined($self->{errors}->{ uc($src) }));
              next if (!defined($dst) || !defined($self->{errors}->{ uc($dst) }));
              $self->{change_exit}->{uc($src)} = uc($dst);
          }
      }
  
      if (defined($self->{option_results}->{explode_perfdata_max})) {
          if (${$self->{option_results}->{explode_perfdata_max}}[0] eq '') {
              $self->{explode_perfdata_total} = 2;
          } else {
              $self->{explode_perfdata_total} = 1;
              foreach (@{$self->{option_results}->{explode_perfdata_max}}) {
                  my ($perf_match, $perf_result) = split /,/;
                  if (!defined($perf_result)) {
                      $self->add_option_msg(short_msg => "Wrong explode-perfdata-max option '" . $_ . "' (syntax: match,value)");
                      $self->option_exit();
                  }
                  $self->{explode_perfdatas}->{$perf_match} = $perf_result;
              }
          }
      }
  
      if (defined($self->{option_results}->{filter_perfdata_adv}) && $self->{option_results}->{filter_perfdata_adv} ne '') {
          $self->{option_results}->{filter_perfdata_adv} =~ s/%\{(.*?)\}/\$values->{$1}/g;
          $self->{option_results}->{filter_perfdata_adv} =~ s/%\((.*?)\)/\$values->{$1}/g;
          $self->{option_results}->{filter_perfdata_adv} =~ s/alert_triggered\(\)/alert_triggered\(%\$values\)/g;
      }
  
      $self->load_perfdata_extend_args();
      $self->{option_results}->{use_new_perfdata} = 1 if (defined($self->{option_results}->{output_openmetrics}));
  
      $self->{source_encoding} = (!defined($self->{option_results}->{source_encoding}) || $self->{option_results}->{source_encoding} eq '') ?
          'UTF-8' : $self->{option_results}->{source_encoding};
  }
  
  sub add_option_msg {
      my ($self, %options) = @_;
      # $options{short_msg} = string msg
      # $options{long_msg} = string msg
      $options{severity} = 'UNQUALIFIED_YET';
  
      $self->output_add(%options);
  }
  
  sub set_ignore_label {
      my ($self, %options) = @_;
  
      $self->{option_results}->{output_ignore_label} = 1;
  }
  
  sub set_status {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
  
      # Nothing to do for 'UNQUALIFIED_YET'
      if (!$self->{myerrors_mask}->{uc($options{exit_litteral})}) {
          return ;
      }
      $self->{global_status} |= $self->{myerrors_mask}->{uc($options{exit_litteral})};
  }
  
  sub output_add {
      my ($self, %params) = @_;
      my %args = (
          severity => 'OK',
          separator => ' - ',
          debug => 0,
          short_msg => undef,
          long_msg => undef,
      );
      my $options = { %args, %params };
  
      if (defined($options->{short_msg})) {
          chomp $options->{short_msg};
          if (defined($self->{global_short_concat_outputs}->{uc($options->{severity})})) {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} .= $options->{separator} . $options->{short_msg};
          } else {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} = $options->{short_msg};
          }
  
          push @{$self->{global_short_outputs}->{uc($options->{severity})}}, $options->{short_msg};
          $self->set_status(exit_litteral => $options->{severity});
      }
  
      if (defined($options->{long_msg})) {
          chomp $options->{long_msg};
  
          push @{$self->{global_long_output}}, $options->{long_msg} if ($options->{debug} == 0 || defined($self->{option_results}->{debug}));
          print $options->{long_msg} . "\n" if (defined($self->{option_results}->{debug_stream}));
      }
  }
  
  sub perfdata_add {
      my ($self, %options) = @_;
  
      my $perfdata = {
          label => '', value => '', unit => '', warning => '', critical => '', min => '', max => '', mode => $self->{mode}
      };
      foreach (keys %options) {
          next if (!defined($options{$_}));
          $perfdata->{$_} = $options{$_};
      }
  
      if ((defined($self->{option_results}->{use_new_perfdata}) || defined($options{force_new_perfdata})) &&
          defined($options{nlabel})) {
          $perfdata->{label} = $options{nlabel};
      }
      if (defined($options{instances})) {
          $options{instances} = [$options{instances}] if (!ref($options{instances}));
          my ($external_instance_separator, $internal_instance_separator) = ('#', '~');
          if (defined($self->{option_results}->{use_new_perfdata}) || defined($options{force_new_perfdata})) {
              $perfdata->{label} = join('~', @{$options{instances}}) . '#' . $perfdata->{label};
          } else {
              $perfdata->{label} .= '_' . join('_', @{$options{instances}});
          }
      }
  
      $perfdata->{label} =~ s/'/''/g;
      push @{$self->{perfdatas}}, $perfdata;
  }
  
  sub filter_perfdata {
      my ($self, %options) = @_;
  
      return 1 if (
          defined($self->{option_results}->{filter_perfdata}) &&
          $options{perf}->{label} !~ /$self->{option_results}->{filter_perfdata}/
      );
  
      return 1 if (
          defined($self->{option_results}->{filter_perfdata_adv}) &&
          $self->{option_results}->{filter_perfdata_adv} ne '' &&
          !$self->test_eval(test => $self->{option_results}->{filter_perfdata_adv}, values => $options{perf})
      );
  
      return 0;
  }
  
  sub range_perfdata {
      my ($self, %options) = @_;
  
      return if ($self->{range_perfdata} == 0);
      if ($self->{range_perfdata} == 1) {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} =~ s/^(@?)-?[0\.]+:/$1/;
          }
      } else {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} = '';
          }
      }
  }
  
  sub output_json {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my $json_content = {
          plugin => {
              name => $self->{plugin},
              mode => $self->{mode},
              exit => $options{exit_litteral},
              outputs => [],
              perfdatas => []
          }
      };
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 1,
                  msg => ($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_,
                  exit => $lcode_litteral
              };
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 2,
                  msg => $_
              };
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
  
              my %values = ();
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  $values{$key} = $perf->{$key};
              }
  
              push @{$json_content->{plugin}->{perfdatas}}, {
                  %values
              };
          }
      }
  
      print $self->{json_output}->encode($json_content);
  }
  
  sub output_xml {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my ($child_plugin_name, $child_plugin_mode, $child_plugin_exit, $child_plugin_output, $child_plugin_perfdata);
  
      my $root = $self->{xml_output}->createElement('plugin');
      $self->{xml_output}->setDocumentElement($root);
  
      $child_plugin_name = $self->{xml_output}->createElement('name');
      $child_plugin_name->appendText($self->{plugin});
  
      $child_plugin_mode = $self->{xml_output}->createElement('mode');
      $child_plugin_mode->appendText($self->{mode});
  
      $child_plugin_exit = $self->{xml_output}->createElement('exit');
      $child_plugin_exit->appendText($options{exit_litteral});
  
      $child_plugin_output = $self->{xml_output}->createElement('outputs');
      $child_plugin_perfdata = $self->{xml_output}->createElement('perfdatas');
  
      $root->addChild($child_plugin_name);
      $root->addChild($child_plugin_mode);
      $root->addChild($child_plugin_exit);
      $root->addChild($child_plugin_output);
      $root->addChild($child_plugin_perfdata);
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(1); # short
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText(($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_);
              $child_exit = $self->{xml_output}->createElement('exit');
              $child_exit->appendText($lcode_litteral);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_exit);
              $child_output->addChild($child_msg);
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              my ($child_output, $child_type, $child_msg);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(2); # long
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText($_);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_msg);
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
  
              my ($child_perfdata);
              $child_perfdata = $self->{xml_output}->createElement('perfdata');
              $child_plugin_perfdata->addChild($child_perfdata);
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  my $child = $self->{xml_output}->createElement($key);
                  $child->appendText($perf->{$key});
                  $child_perfdata->addChild($child);
              }
          }
      }
  
      print $self->{xml_output}->toString(1);
  }
  
  sub output_openmetrics {
      my ($self, %options) = @_;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'Time::HiRes',
          error_msg => "Cannot load module 'Time::HiRes'."
      );
  
      my $time_ms = int(Time::HiRes::time() * 1000);
      $self->change_perfdata();
  
      foreach my $perf (@{$self->{perfdatas}}) {
          next if ($self->filter_perfdata(perf => $perf));
  
          $perf->{unit} = '' if (
              defined($self->{option_results}->{filter_uom}) &&
              $perf->{unit} !~ /$self->{option_results}->{filter_uom}/
          );
          $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          my $label = $perf->{label};
          my $instance;
          if ($label =~ /^(.*?)#(.*)$/) {
              ($perf->{instance}, $label) = ($1, $2);
          }
          my ($bucket, $append) = ('{plugin="' . $self->{plugin} . '",mode="' . $perf->{mode} . '"', '');
          foreach ('unit', 'warning', 'critical', 'min', 'max', 'instance') {
              if (defined($perf->{$_}) && $perf->{$_} ne '') {
                  $bucket .= ',' . $_ . '="' . $perf->{$_} . '"';
              }
          }
          $bucket .= '}';
  
          print $label . $bucket . ' ' . $perf->{value} . ' ' . $time_ms . "\n";
      }
  }
  
  sub output_txt_short_display {
      my ($self, %options) = @_;
  
      if (defined($self->{global_short_concat_outputs}->{CRITICAL})) {
          print (($options{nolabel} == 0 ? 'CRITICAL: ' : '') . $self->{global_short_concat_outputs}->{CRITICAL} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{WARNING})) {
          print (($options{nolabel} == 0 ? 'WARNING: ' : '') . $self->{global_short_concat_outputs}->{WARNING} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{UNKNOWN})) {
          print (($options{nolabel} == 0 ? 'UNKNOWN: ' : '') . $self->{global_short_concat_outputs}->{UNKNOWN} . " ");
      }
      if (uc($options{exit_litteral}) eq 'OK') {
          print (($options{nolabel} == 0 ? 'OK: ' : '') . (defined($self->{global_short_concat_outputs}->{OK}) ? $self->{global_short_concat_outputs}->{OK} : '') . " ");
      }
  }
  
  sub output_txt_short {
      my ($self, %options) = @_;
  
      if (!defined($self->{option_results}->{change_short_output}) && 
          !defined($self->{change_output_adv})) {
          $self->output_txt_short_display(%options);
          return ;
      }
  
      my $stdout = '';
      {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          $self->output_txt_short_display(%options);
      }
  
      foreach (@{$self->{option_results}->{change_short_output}}) {
           my ($pattern, $replace, $modifier) = split /~/;
           next if (!defined($pattern));
           $replace = '' if (!defined($replace));
           $modifier = '' if (!defined($modifier));
           eval "\$stdout =~ s{$pattern}{$replace}$modifier";
      }
  
      my $exit = defined($options{exit_litteral}) ? uc($options{exit_litteral}) : uc($self->{myerrors}->{ $self->{global_status} });
      foreach (@{$self->{change_output_adv}}) {
          if ($self->test_eval(test => $_->{expr}, values => { short_output => $stdout, exit_code => $self->{errors}->{$exit} })) {
              if (defined($_->{short_output}) && $_->{short_output} ne '') {
                  $stdout = $_->{short_output};
              }
              if (defined($_->{exit_code}) && $_->{exit_code} ne '') {
                  $self->{coa_save_exit_code} = $_->{exit_code};
              }
          }
      }
  
      print $stdout;
  }
  
  sub output_txt {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
  
      return if ($self->{nodisplay} == 1);
  
      if (defined($self->{global_short_concat_outputs}->{UNQUALIFIED_YET})) {
          $self->output_add(severity => uc($options{exit_litteral}), short_msg => $self->{global_short_concat_outputs}->{UNQUALIFIED_YET});
      }
  
      $self->output_txt_short(%options);
  
      if ($force_ignore_perfdata == 0) {
          my $pipe = 0;
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
                  $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              if ($pipe == 0) {
                  print '|';
                  $pipe = 1;
              }
              print " '" . $perf->{label} . "'=" . $perf->{value} . $perf->{unit} . ';' . $perf->{warning} . ';' . $perf->{critical} . ';' . $perf->{min} . ';' . $perf->{max};
          }
      }
  
      print "\n";
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          if (scalar(@{$self->{global_long_output}})) {
              print join("\n", @{$self->{global_long_output}});
              print "\n";
          }
      }
  }
  
  sub change_long_output {
      my ($self, %options) = @_;
  
      return if (!(defined($self->{option_results}->{verbose}) || $options{force_long_output} == 1));
      return if (!defined($self->{option_results}->{change_long_output}));
  
      my $long_output = join("\n", @{$self->{global_long_output}});
  
      foreach (@{$self->{option_results}->{change_long_output}}) {
          my ($pattern, $replace, $modifier) = split /~/;
          next if (!defined($pattern));
          $replace = '' if (!defined($replace));
          $modifier = '' if (!defined($modifier));
          eval "\$long_output =~ s{$pattern}{$replace}$modifier";
      }
  
      $self->{global_long_output} = [split(/\n/, $long_output)];
  }
  
  sub display {
      my ($self, %options) = @_;
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
      my $force_ignore_perfdata = ((defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) || $self->{option_results}->{output_ignore_perfdata}) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      $force_long_output = 1 if (defined($self->{option_results}->{debug}));
  
      if (defined($self->{option_results}->{output_openmetrics})) {
          $self->perfdata_add(nlabel => 'plugin.mode.status', value => $self->{errors}->{$self->{myerrors}->{$self->{global_status}}});
      }
  
      if (defined($self->{option_results}->{change_long_output})) {
          $self->change_long_output(force_long_output => $force_long_output);
      }
  
      return if ($self->{nodisplay} == 1);
  
      if (defined($self->{option_results}->{output_file})) {
          if (!open (STDOUT, '>', $self->{option_results}->{output_file})) {
              $self->output_add(
                  severity => 'UNKNOWN',
                  short_msg => "cannot open file  '" . $self->{option_results}->{output_file} . "': $!"
              );
          }
      }
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(
                  exit_litteral => $self->get_litteral_status(),
                  nolabel => $nolabel,
                  force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
              );
              return ;
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(
                  exit_litteral => $self->get_litteral_status(),
                  nolabel => $nolabel,
                  force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
              );
              return ;
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->output_openmetrics();
          return ;
      }
  
      $self->output_txt(
          exit_litteral => $self->get_litteral_status(),
          nolabel => $nolabel,
          force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
      );
  }
  
  sub die_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
      # ignore long output in the following case
      $self->{option_results}->{verbose} = undef;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub option_exit {
      my ($self, %options) = @_;
  
      $self->add_option_msg(short_msg => $options{short_msg}) if defined $options{short_msg};
  
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->set_status(exit_litteral => $exit_litteral);
          $self->output_openmetrics();
          $self->exit(exit_litteral => $exit_litteral);
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub exit {
      my ($self, %options) = @_;
  
      if ($self->{noexit_die} == 1) {
          die 'exit';
      }
  
      my $exit;
      if (defined($options{exit_litteral})) {
          $exit = uc($options{exit_litteral});
      } else {
          $exit = $self->{myerrors}->{ $self->{global_status} };
      }
   
      if (defined($self->{coa_save_exit_code})) {
          $exit = $self->{coa_save_exit_code};
      }
      if (defined($self->{change_exit}) && defined($self->{change_exit}->{$exit})) {
          $exit = $self->{change_exit}->{$exit};
      }
      exit $self->{errors}->{$exit};
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{option_results}->{$options{option}};
  }
  
  sub get_most_critical {
      my ($self, %options) = @_;
      my $current_status = 0; # For 'OK'
  
      foreach (@{$options{status}}) {
          if ($self->{myerrors_mask}->{uc($_)} > $current_status) {
              $current_status = $self->{myerrors_mask}->{uc($_)};
          }
      }
      return $self->{myerrors}->{$current_status};
  }
  
  sub get_litteral_status {
      my ($self, %options) = @_;
  
      if (defined($options{status})) {
          if (defined($self->{errors_num}->{$options{status}})) {
              return $self->{errors_num}->{$options{status}};
          }
          return $options{status};
      } else {
          return $self->{myerrors}->{$self->{global_status}};
      }
  }
  
  sub is_status {
      my ($self, %options) = @_;
      # $options{value} = string status
      # $options{litteral} = value is litteral
      # $options{compare} = string status
  
      if (defined($options{litteral})) {
          my $value = defined($options{value}) ? $options{value} : $self->get_litteral_status();
  
          if (uc($value) eq uc($options{compare})) {
              return 1;
          }
          return 0;
      }
  
      my $value = defined($options{value}) ? $options{value} : $self->{global_status};
      my $dec_val = $self->{myerrors_mask}->{$value};
      my $lresult = $value & $dec_val;
      # Need to manage 0
      if ($lresult > 0 || ($dec_val == 0 && $value == 0)) {
          return 1;
      }
      return 0;
  }
  
  sub is_litteral_status {
      my ($self, %options) = @_;
      # $options{status} = string status
  
      if (defined($self->{errors}->{uc($options{status})})) {
          return 1;
      }
  
      return 0;
  }
  
  sub create_json_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(
          no_quit => 1, module => 'JSON',
          error_msg => "Cannot load module 'JSON'.")
          ) {
          print "Cannot load module 'JSON'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_json} = 1;
      $self->{json_output} = JSON->new->utf8();
  }
  
  sub create_xml_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(
          no_quit => 1, module => 'XML::LibXML',
          error_msg => "Cannot load module 'XML::LibXML'.")
          ) {
          print "Cannot load module 'XML::LibXML'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_xml} = 1;
      $self->{xml_output} = XML::LibXML::Document->new('1.0', 'utf-8');
  }
  
  sub plugin {
      my ($self, %options) = @_;
      # $options{name} = string name
  
      if (defined($options{name})) {
          $self->{plugin} = $options{name};
      }
      return $self->{plugin};
  }
  
  sub mode {
      my ($self, %options) = @_;
  
      if (defined($options{name})) {
          $self->{mode} = $options{name};
      }
      return $self->{mode};
  }
  
  sub add_disco_format {
      my ($self, %options) = @_;
  
      push @{$self->{disco_elements}}, @{$options{elements}};
  }
  
  sub display_disco_format {
      my ($self, %options) = @_;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
  
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_elements}}) {
              my $child = $self->{xml_output}->createElement("element");
              $child->appendText($_);
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_elements}}) {
              push @{$json_content->{data}}, $_;
          }
  
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub display_disco_show {
      my ($self, %options) = @_;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
  
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_entries}}) {
              my $child = $self->{xml_output}->createElement('label');
              foreach my $key (keys %$_) {
                  # Encode all non printable chars as hexadecimal entities to produce valid XML
                  # I.e. "test ^H" becomes "test &#x8;"
                  my $val = $_->{$key};
                  $val=~s{([[:cntrl:]])}{"&#x".sprintf("%X",ord($1)).";"}ge;
                  $child->setAttribute($key, $val);
              }
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_entries}}) {
              my %values = ();
              foreach my $key (keys %$_) {
                  $values{$key} = $_->{$key};
              }
              push @{$json_content->{data}}, {%values};
          }
  
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub decode {
      my ($self, $value) = @_;
  
      if ($self->{encode_import} == 0) {
          # Some Perl version dont have the following module (like Perl 5.6.x)
          my $rv = centreon::plugins::misc::mymodule_load(
              no_quit => 1,
              module => 'Encode',
              error_msg => "Cannot load module 'Encode'."
          );
          return $value if ($rv);
  
          $self->{encode_import} = 1;
          eval '$self->{perlqq} = Encode::PERLQQ';
      }
  
      return centreon::plugins::misc::trim(Encode::decode($self->{source_encoding}, $value, $self->{perlqq}));
  }
  
  sub parameter {
      my ($self, %options) = @_;
  
      if (defined($options{attr})) {
          $self->{$options{attr}} = $options{value};
      }
      return $self->{$options{attr}};
  }
  
  sub add_disco_entry {
      my ($self, %options) = @_;
  
      push @{$self->{disco_entries}}, {%options};
  }
  
  sub is_disco_format {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_format})) {
          return 1;
      }
      return 0;
  }
  
  sub is_disco_show {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_show})) {
          return 1;
      }
      return 0;
  }
  
  sub is_verbose {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{verbose})) {
          return 1;
      }
      return 0;
  }
  
  sub is_debug {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{debug}) || defined($self->{option_results}->{debug_stream})) {
          return 1;
      }
      return 0;
  }
  
  sub load_eval {
      my ($self) = @_;
  
      my ($code) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'Safe',
          no_quit => 1
      );
      if ($code == 0) {
          $self->{safe} = Safe->new();
          $self->{safe}->share('$values');
          $self->{safe}->share('$assign_var');
          $self->{safe}->share_from('centreon::plugins::misc', ['alert_triggered']);
      }
  
      $self->{safe_test} = 1;
  }
  
  sub test_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
  
      my $result;
      if (defined($self->{safe})) {
          our $values = $options{values};
          $result = $self->{safe}->reval($options{test}, 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } elsif (defined($options{values})) {
          my $values = $options{values};
          {
              local $SIG{__WARN__} = sub {}; # ignore
  
              $result = eval "$options{test}";
              if ($@) {
                  die 'Code evaluation error: ' . $@;
              }
          }
      }
  
      return $result;
  }
  
  sub open_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
      our $values = $options{values};
      $self->{safe}->reval("$options{eval}", 1);
  
      return $values;
  }
  
  sub assign_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
  
      our $assign_var;
      if (defined($self->{safe})) {
          our $values = $options{values};
          $self->{safe}->reval("\$assign_var = $options{eval}", 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } else {
          my $values = $options{values};
          eval "\$assign_var = $options{eval}";
      }
  
      return $assign_var;
  }
  
  sub use_new_perfdata {
      my ($self, %options) = @_;
  
      $self->{option_results}->{use_new_perfdata} = $options{value}
          if (defined($options{value}));
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return 1;
      }
      return 0;
  }
  
  sub get_instance_perfdata_separator {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return '~';
      }
      return '_';
  }
  
  sub parse_pfdata_scale {
      my ($self, %options) = @_;
  
      # --extend-perfdata=traffic_in,,scale(Mbps),mbps
      my $args = { unit => 'auto' };
      if ($options{args} =~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s|auto)$/) {
          $args->{quantity} = defined($1) ? $1 : '';
          $args->{unit} = $2;
      } elsif ($options{args} ne '') {
          return 1;
      }
  
      return (0, $args);
  }
  
  sub parse_pfdata_math {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,math(current + 10 - 100, 1)
      my $args = { math => undef, apply_threshold => 0 };
      my ($math, $apply_threshold) = split /\|/, $options{args};
      if ($math =~ /^((?:[\s\.\-\+\*\/0-9\(\)]|current)+)$/) {
          $args->{math} = $1;
      } elsif ($options{args} ne '') {
          return 1;
      }
  
      if (defined($apply_threshold) && $apply_threshold =~ /^\s*(0|1)\s*$/ ) {
          $args->{apply_threshold} = $1;
      }
  
      return (0, $args);
  }
  
  sub parse_pfdata_eval {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,eval(%(label) =~ s/a/A/g)
      my $args = { expr => $options{args} };
      $args->{expr} =~ s/%\{(.*?)\}/\$values->{$1}/g;
      $args->{expr} =~ s/%\((.*?)\)/\$values->{$1}/g;
      return (0, $args);
  }
  
  sub parse_group_pfdata {
      my ($self, %options) = @_;
  
      $options{args} =~ s/^\s+//;
      $options{args} =~ s/\s+$//;
      my $args = { pattern_pf => $options{args} };
      return $args;
  }
  
  sub parse_pfdata_min {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_max {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_average {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_sum {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub apply_pfdata_scale {
      my ($self, %options) = @_;
  
      return if (${$options{perf}}->{unit} !~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s)$/);
  
      my ($src_quantity, $src_unit) = ($1, $2);
      my ($value, $dst_quantity, $dst_unit) = centreon::plugins::misc::scale_bytesbit(
          value => ${$options{perf}}->{value},
          src_quantity => $src_quantity, src_unit => $src_unit, dst_quantity => $options{args}->{quantity}, dst_unit => $options{args}->{unit}
      );
      ${$options{perf}}->{value} = sprintf('%.2f', $value);
      if (defined($dst_unit)) {
         ${$options{perf}}->{unit} = $dst_quantity . $dst_unit;
      } else {
          ${$options{perf}}->{unit} = $options{args}->{quantity} . $options{args}->{unit};
      }
  
      if (defined(${$options{perf}}->{max}) && ${$options{perf}}->{max} ne '') {
          ($value) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{max},
              src_quantity => $src_quantity, src_unit => $src_unit,
              dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
              dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          ${$options{perf}}->{max} = sprintf('%.2f', $value);
      }
  
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              ($result->{start}) = centreon::plugins::misc::scale_bytesbit(value => $result->{start},
                  src_quantity => $src_quantity, src_unit => $src_unit,
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              ($result->{end}) = centreon::plugins::misc::scale_bytesbit(value => $result->{end},
                  src_quantity => $src_quantity, src_unit => $src_unit,
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  }
  
  sub apply_pfdata_invert {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
  
      ${$options{perf}}->{value} = ${$options{perf}}->{max} - ${$options{perf}}->{value};
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
          $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
          $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $tmp->{end} = ${$options{perf}}->{max} - $result->{start};
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $tmp->{start} = ${$options{perf}}->{max} - $result->{end};
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
      }
  }
  
  sub apply_pfdata_percent {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
  
      ${$options{perf}}->{value} = sprintf('%.2f', ${$options{perf}}->{value} * 100 / ${$options{perf}}->{max});
      ${$options{perf}}->{unit} = '%';
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $result->{start} = sprintf('%.2f', $result->{start} * 100 / ${$options{perf}}->{max});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $result->{end} = sprintf('%.2f', $result->{end} * 100 / ${$options{perf}}->{max});
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_eval {
      my ($self, %options) = @_;
  
      ${$options{perf}} = $self->open_eval(eval => $options{args}->{expr}, values => ${$options{perf}});
  }
  
  sub apply_pfdata_math {
      my ($self, %options) = @_;
  
      my $math = $options{args}->{math};
      $math =~ s/current/\$value/g;
  
      my $value = ${$options{perf}}->{value};
      eval "\${\$options{perf}}->{value} = $math";
  
      return if ($options{args}->{apply_threshold} == 0);
  
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $value = $result->{start};
              eval "\$result->{start} = $math";
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $value = $result->{end};
              eval "\$result->{end} = $math";
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_min {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my $min;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $min = $self->{perfdatas}->[$i]->{value}
              if (!defined($min) || $min > $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $min
          if (defined($min));
  }
  
  sub apply_pfdata_max {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my $max;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $max = $self->{perfdatas}->[$i]->{value}
              if (!defined($max) || $max < $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $max
          if (defined($max));
  }
  
  sub apply_pfdata_sum {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = $sum
          if ($num > 0);
  }
  
  sub apply_pfdata_average {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = sprintf("%.2f", ($sum / $num))
          if ($num > 0);
  }
  
  sub apply_perfdata_thresholds {
      my ($self, %options) = @_;
  
      foreach (('warning', 'critical')) {
          next if (!defined($options{$_}));
  
          my @thresholds = split(':', $options{$_}, -1);
          for (my $i = 0; $i < scalar(@thresholds); $i++) {
              if ($thresholds[$i] =~ /(\d+(?:\.\d+)?)\s*%/) {
                  if (!defined($options{max}) || $options{max} eq '') {
                      $thresholds[$i] = '';
                      next;
                  }
                  $thresholds[$i] = $1 * $options{max} / 100;
              } elsif ($thresholds[$i] =~ /(\d+(?:\.\d+)?)/) {
                  $thresholds[$i] = $1;
              } else {
                  $thresholds[$i] = '';
              }
          }
  
          ${$options{perf}}->{$_} = join(':', @thresholds);
      }
  }
  
  sub load_perfdata_extend_args {
      my ($self, %options) = @_;
  
      foreach (
          [$self->{option_results}->{change_perfdata}, 1],
          [$self->{option_results}->{extend_perfdata}, 2],
          [$self->{option_results}->{extend_perfdata_group}, 3],
      ) {
          next if (!defined($_->[0]));
          foreach my $arg (@{$_->[0]}) {
              $self->parse_perfdata_extend_args(arg => $arg, type => $_->[1]);
          }
      }
  }
  
  sub parse_perfdata_extend_args {
      my ($self, %options) = @_;
  
      # --extend-perfdata=searchlabel,newlabel,method[,[newuom],[min],[max],[warning],[critical]]
      my ($pfdata_match, $pfdata_substitute, $method, $uom_sub, $min_sub, $max_sub, $warn_sub, $crit_sub) =
          split /,/, $options{arg};
      return if ((!defined($pfdata_match) || $pfdata_match eq '') && $options{type} != 3);
  
      $self->{pfdata_extends} = [] if (!defined($self->{pfdata_extends}));
      my $pfdata_extends = {
          pfdata_match => defined($pfdata_match) && $pfdata_match ne '' ? $pfdata_match : undef,
          pfdata_substitute => defined($pfdata_substitute) && $pfdata_substitute ne '' ? $pfdata_substitute : undef,
          uom_sub => defined($uom_sub) && $uom_sub ne '' ? $uom_sub : undef,
          min_sub => defined($min_sub) && $min_sub ne '' ? $min_sub : undef,
          max_sub => defined($max_sub) && $max_sub ne '' ? $max_sub : undef,
          warn_sub => defined($warn_sub) && $warn_sub ne '' ? $warn_sub : undef,
          crit_sub => defined($crit_sub) && $crit_sub ne '' ? $crit_sub : undef,
          type => $options{type}
      };
  
      if (defined($method) && $method ne '') {
          if ($method !~ /^\s*(invert|percent|scale|math|min|max|average|sum|eval)\s*\(\s*(.*?)\s*\)\s*$/) {
              $self->output_add(long_msg => "method in argument '$options{arg}' is unknown", debug => 1);
              return ;
          }
  
          $pfdata_extends->{method_name} = $1;
          my $args = $2;
          if (my $func = $self->can('parse_pfdata_' . $pfdata_extends->{method_name})) {
              (my $status, $pfdata_extends->{method_args}) = $func->($self, args => $args);
              if ($status == 1) {
                  $self->output_add(long_msg => "argument in method '$options{arg}' is unknown", debug => 1);
                  return ;
              }
          }
      }
  
      push @{$self->{pfdata_extends}}, $pfdata_extends;
  }
  
  sub apply_perfdata_explode {
      my ($self, %options) = @_;
  
      return if ($self->{explode_perfdata_total} == 0);
      foreach (@{$self->{perfdatas}}) {
          next if ($_->{max} eq '');
          if ($self->{explode_perfdata_total} == 2) {
              $self->perfdata_add(label => $_->{label} . '_max', value => $_->{max}, unit => $_->{unit});
              next;
          }
          foreach my $regexp (keys %{$self->{explode_perfdatas}}) {
              if ($_->{label} =~ /$regexp/) {
                  $self->perfdata_add(label => $self->{explode_perfdatas}->{$regexp}, value => $_->{max}, unit => $_->{unit});
                  last;
              }
          }
      }
  }
  
  sub apply_perfdata_extend {
      my ($self, %options) = @_;
  
      foreach my $extend (@{$self->{pfdata_extends}}) {
          my $new_pfdata = [];
  
          # Manage special case when type group and pfdata_match empty
          if ($extend->{type} == 3 && (!defined($extend->{pfdata_match}) || $extend->{pfdata_match} eq '')) {
              next if (!defined($extend->{pfdata_substitute}) || $extend->{pfdata_substitute} eq '');
              my $new_perf = {
                  label => $extend->{pfdata_substitute}, value => '',
                  unit => defined($extend->{uom_sub}) ? $extend->{uom_sub} : '',
                  warning => '', critical => '',
                  min => defined($extend->{min_sub}) ? $extend->{min_sub} : '',
                  max => defined($extend->{max_sub}) ? $extend->{max_sub} : ''
              };
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              $self->apply_perfdata_thresholds(
                  perf => \$new_perf,
                  warning => $extend->{warn_sub},
                  critical => $extend->{crit_sub},
                  max => $new_perf->{max}
              );
              if (length($new_perf->{value})) {
                  push @{$self->{perfdatas}}, $new_perf;
              }
              next;
          }
  
          for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
              next if ($self->{perfdatas}->[$i]->{label} !~ /$extend->{pfdata_match}/);
  
              my $new_perf = { %{$self->{perfdatas}->[$i]} };
              if ($extend->{type} == 3) {
                  $new_perf = { label => $self->{perfdatas}->[$i]->{label}, value => '', unit => '', warning => '', critical => '', min => '', max => '' };
              }
  
              if (defined($extend->{pfdata_substitute})) {
                  eval "\$new_perf->{label} =~ s{$extend->{pfdata_match}}{$extend->{pfdata_substitute}}";
              }
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              $new_perf->{unit} = $extend->{uom_sub} if (defined($extend->{uom_sub}));
              $new_perf->{min} = $extend->{min_sub} if (defined($extend->{min_sub}));
              $new_perf->{max} = $extend->{max_sub} if (defined($extend->{max_sub}));
              $self->apply_perfdata_thresholds(
                  perf => \$new_perf,
                  warning => $extend->{warn_sub},
                  critical => $extend->{crit_sub},
                  max => $new_perf->{max}
              );
  
              if ($extend->{type} == 1) {
                  $self->{perfdatas}->[$i] = $new_perf;
              } else {
                  push @$new_pfdata, $new_perf if (length($new_perf->{value}));
              }
          }
  
          push @{$self->{perfdatas}}, @$new_pfdata;
      }
  }
  
  sub change_perfdata {
      my ($self, %options) = @_;
  
      $self->apply_perfdata_extend();
      $self->apply_perfdata_explode();
  }
  
  1;
  
  
  =head1 NAME
  
  Output class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 OUTPUT OPTIONS
  
  =over 8
  
  =item B<--verbose>
  
  Display extended status information (long output).
  
  =item B<--debug>
  
  Display debug messages.
  
  =item B<--filter-perfdata>
  
  Filter perfdata that match the regexp.
  Example: adding --filter-perfdata='avg' will remove all metrics that do not contain
  'avg' from performance data.
  
  =item B<--filter-perfdata-adv>
  
  Filter perfdata based on a "if" condition using the following variables:
  label, value, unit, warning, critical, min, max.
  Variables must be written either %{variable} or %(variable).
  Example: adding --filter-perfdata-adv='not (%(value) == 0 and %(max) eq "")' will
  remove all metrics whose value equals 0 and that don't have a maximum value.
  
  =item B<--explode-perfdata-max>
  
  Create a new metric for each metric that comes with a maximum limit. The new
  metric will be named identically with a '_max' suffix.
  Example: it will split 'used_prct'=26.93%;0:80;0:90;0;100
  into 'used_prct'=26.93%;0:80;0:90;0;100 'used_prct_max'=100%;;;;
  
  =item B<--change-perfdata> B<--extend-perfdata>
  
  Change or extend perfdata.
  Syntax: --extend-perfdata=searchlabel,newlabel,target[,[<new-unit-of-mesure>],[min],[max]]
  
  Common examples:
  
  =over 4
  
  Convert storage free perfdata into used: --change-perfdata='free,used,invert()'
  
  Convert storage free perfdata into used: --change-perfdata='used,free,invert()'
  
  Scale traffic values automatically: --change-perfdata='traffic,,scale(auto)'
  
  Scale traffic values in Mbps: --change-perfdata='traffic_in,,scale(Mbps),mbps'
  
  Change traffic values in percent: --change-perfdata='traffic_in,,percent()'
  
  =back
  
  =item B<--extend-perfdata-group>
  
  Add new aggregated metrics (min, max, average or sum) for groups of metrics defined by a regex match on the metrics' names.
  Syntax: --extend-perfdata-group=regex,<names-of-new-metrics>,calculation[,[<new-unit-of-mesure>],[min],[max]]
  regex: regular expression
  <names-of-new-metrics>: how the new metrics' names are composed (can use $1, $2... for groups defined by () in regex).
  calculation: how the values of the new metrics should be calculated
  <new-unit-of-mesure> (optional): unit of measure for the new metrics
  min (optional): lowest value the metrics can reach
  max (optional): highest value the metrics can reach
  
  Common examples:
  
  =over 4
  
  Sum wrong packets from all interfaces (with interface need  --units-errors=absolute): --extend-perfdata-group=',packets_wrong,sum(packets_(discard|error)_(in|out))'
  
  Sum traffic by interface: --extend-perfdata-group='traffic_in_(.*),traffic_$1,sum(traffic_(in|out)_$1)'
  
  =back
  
  =item B<--change-short-output> B<--change-long-output>
  
  Modify the short/long output that is returned by the plugin.
  Syntax: --change-short-output=pattern~replacement~modifier
  Most commonly used modifiers are i (case insensitive) and g (replace all occurrences).
  Example: adding --change-short-output='OK~Up~gi' will replace all occurrences of 'OK', 'ok', 'Ok' or 'oK' with 'Up'
  
  =item B<--change-exit>
  
  Replace an exit code with one of your choice.
  Example: adding --change-exit=unknown=critical will result in a CRITICAL state
  instead of an UNKNOWN state.
  
  =item B<--change-output-adv>
  
  Replace short output and exit code based on a "if" condition using the following variables:
  short_output, exit_code.
  Variables must be written either %{variable} or %(variable).
  Example: adding --change-output-adv='%(short_ouput) =~ /UNKNOWN: No daemon/,OK: No daemon,OK' will 
  change the following specific UNKNOWN result to an OK result.
  
  =item B<--range-perfdata>
  
  Rewrite the ranges displayed in the perfdata. Accepted values:
  0: nothing is changed.
  1: if the lower value of the range is equal to 0, it is removed.
  2: remove the thresholds from the perfdata.
  
  =item B<--filter-uom>
  
  Mask the units when they don't match the given regular expression.
  
  =item B<--opt-exit>
  
  Replace the exit code in case of an execution error (i.e. wrong option provided,
  SSH connection refused, timeout, etc). Default: unknown.
  
  =item B<--output-ignore-perfdata>
  
  Remove all the metrics from the service. The service will still have a status
  and an output.
  
  =item B<--output-ignore-label>
  
  Remove the status label ("OK:", "WARNING:", "UNKNOWN:", CRITICAL:") from the
  beginning of the output.
  Example: 'OK: Ram Total:...' will become 'Ram Total:...'
  
  =item B<--output-xml>
  
  Return the output in XML format (to send to an XML API).
  
  =item B<--output-json>
  
  Return the output in JSON format (to send to a JSON API).
  
  =item B<--output-openmetrics>
  
  Return the output in OpenMetrics format (to send to a tool expecting this
  format).
  
  =item B<--output-file>
  
  Write output in file (can be combined with JSON, XML and OpenMetrics options).
  Example: --output-file=/tmp/output.txt will write the output in /tmp/output.txt.
  
  =item B<--disco-format>
  
  Applies only to modes beginning with 'list-'.
  Returns the list of available macros to configure a service discovery rule
  (formatted in XML).
  
  =item B<--disco-show>
  
  Applies only to modes beginning with 'list-'.
  Returns the list of discovered objects (formatted in XML) for service discovery.
  
  =item B<--float-precision>
  
  Define the float precision for thresholds (default: 8).
  
  =item B<--source-encoding>
  
  Define the character encoding of the response sent by the monitored resource
  Default: 'UTF-8'.
  
  =head1 DESCRIPTION
  
  B<output>.
  
  =cut
CENTREON_PLUGINS_OUTPUT

$fatpacked{"centreon/plugins/passwordmgr/centreonvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_CENTREONVAULT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::centreonvault;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::http;
  use JSON::XS;
  use MIME::Base64;
  use Crypt::OpenSSL::AES;
  use centreon::plugins::statefile;
  
  my $VAULT_PATH_REGEX = qr/^secret::hashicorp_vault::([^:]+)::(.+)$/;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr needs an 'output' argument that must be of type centreon::plugins::output.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          print "Class PasswordMgr needs an 'options' argument that must be of type centreon::plugins::options.\n";
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'vault-config:s'    => { name => 'vault_config',    default => '/etc/centreon-engine/centreonvault.json'},
          'vault-cache:s'     => { name => 'vault_cache',     default => '/var/lib/centreon/centplugins/centreonvault_session'},
          'vault-env-file:s'  => { name => 'vault_env_file',  default => '/usr/share/centreon/.env'},
      });
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'VAULT OPTIONS');
  
      $self->{output} = $options{output};
  
      # to access the vault, http protocol management is needed
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl', insecure => 1);
  
      # to store the token and its expiration date, a statefile is needed
      $self->{cache} = centreon::plugins::statefile->new();
  
      return $self;
  }
  
  sub extract_map_options {
      my ($self, %options) = @_;
  
      $self->{map_option} = [];
  
      # Parse all options to find '/# .*\:\:secret\:\:(.*)/' pattern in the options values and add entries in map_option
      foreach my $option (keys %{$options{option_results}}) {
          if (defined($options{option_results}{$option})) {
              next if ($option eq 'map_option');
              if (ref($options{option_results}{$option}) eq 'ARRAY') {
                  foreach (@{$options{option_results}{$option}}) {
                      if ($_ =~ $VAULT_PATH_REGEX) {
                          push (@{$self->{request_endpoint}}, "/v1/$1::$2");
                          push (@{$self->{map_option}}, $option."=%".$_);
                      }
                  }
              } else {
  
                  if (my ($path, $secret) = $options{option_results}{$option} =~ $VAULT_PATH_REGEX) {
                      push (@{$self->{request_endpoint}}, "/v1/" . $path . "::" . $secret);
                      push (@{$self->{map_option}}, $option."=%".$options{option_results}{$option});
                  }
              }
          }
      }
  }
  
  sub vault_settings {
      my ($self, %options) = @_;
  
      if (centreon::plugins::misc::is_empty($options{option_results}->{vault_config})) {
          $self->{output}->add_option_msg(short_msg => "Please provide a Centreon Vault configuration file path with --vault-config option");
          $self->{output}->option_exit();
      }
      if (! -f $options{option_results}->{vault_config}) {
          $self->{output}->add_option_msg(short_msg => "File '$options{option_results}->{vault_config}' could not be found.");
          $self->{output}->option_exit();
      }
      $self->{vault_cache}    = $options{option_results}->{vault_cache};
      $self->{vault_env_file} = $options{option_results}->{vault_env_file};
      $self->{vault_config}   = $options{option_results}->{vault_config};
  
  
      my $file_content = do {
          local $/ = undef;
          if (!open my $fh, "<", $options{option_results}->{vault_config}) {
              $self->{output}->add_option_msg(short_msg => "Could not read file $options{option_results}->{vault_config}: $!");
              $self->{output}->option_exit();
          }
          <$fh>;
      };
  
      # decode the JSON content of the file
      my $json = centreon::plugins::misc::json_decode($file_content);
      if (!defined($json)) {
          $self->{output}->add_option_msg(short_msg => "Cannot decode JSON : $file_content\n");
          $self->{output}->option_exit();
      }
  
      # set the default values
      $self->{vault}->{protocol} = 'https';
      $self->{vault}->{url} = '127.0.0.1';
      $self->{vault}->{port} = '8100';
  
      # define the list of expected attributes in the JSON file
      my @valid_json_options = (
          'protocol',
          'url',
          'port',
          'root_path',
          'token',
          'secret_id',
          'role_id'
      );
  
      # set the object fields when the json fields are not empty
      foreach my $valid_option (@valid_json_options) {
          $self->{vault}->{$valid_option} = $json->{$valid_option}
              if ( !centreon::plugins::misc::is_empty( $json->{ $valid_option } ) );
      }
  
      return 1;
  }
  
  sub get_decryption_key {
      my ($self, %options) = @_;
  
      # try getting APP_SECRET from the environment variables
      if ( !centreon::plugins::misc::is_empty($ENV{'APP_SECRET'}) ) {
          return $ENV{'APP_SECRET'};
      }
  
      # try getting APP_SECRET defined in the env file (default: /usr/share/centreon/.env) file
      my $fh;
      return undef if (!open $fh, "<", $self->{vault_env_file});
      for my $line (<$fh>) {
          if ($line =~ /^APP_SECRET=(.*)$/) {
              return $1;
          }
      }
  
      return undef;
  }
  
  sub extract_and_decrypt {
      my ($self, %options) = @_;
  
      my $input = decode_base64($options{data});
      my $key   = $options{key};
  
      # with AES-256, the IV length must 16 bytes
      my $iv_length = 16;
      # extract the IV, the hashed data, the encrypted data
      my $iv             = substr($input, 0, $iv_length);     # initialization vector
      my $hashed_data    = substr($input, $iv_length, 64);    # hmac of the original data, for integrity control
      my $encrypted_data = substr($input, $iv_length + 64);   # data to decrypt
  
      # Creating the AES decryption object
      my $cipher;
      eval {
          $cipher = Crypt::OpenSSL::AES->new(
              $key,
              {
                  'cipher'  => 'AES-256-CBC',
                  'iv'      => $iv
              }
          );
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "There was an error while creating the AES object: " . $@);
          $self->{output}->option_exit();
      }
  
      # Decrypting the data
      my $decrypted_data;
      eval {$decrypted_data = $cipher->decrypt($encrypted_data);};
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "There was an error while decrypting an AES-encrypted data: " . $@);
          $self->{output}->option_exit();
      }
  
      return $decrypted_data;
  }
  
  sub is_token_still_valid {
      my ($self) = @_;
      if (
              !defined($self->{auth})
              || centreon::plugins::misc::is_empty($self->{auth}->{token})
              || centreon::plugins::misc::is_empty($self->{auth}->{expiration_epoch})
              || $self->{auth}->{expiration_epoch} !~ /\d+/
              || $self->{auth}->{expiration_epoch} <= time()
      ) {
          $self->{output}->output_add(long_msg => "The token is missing or has expired or is invalid.", debug => 1);
          return undef;
      }
      $self->{output}->output_add(long_msg => "The cached token is still valid.", debug => 1);
      # Possible enhancement: check the token validity by calling this endpoint: /v1/auth/token/lookup-self
      # {"request_id":"XXXXX","lease_id":"","renewable":false,"lease_duration":0,"data":{"accessor":"XXXXXXX","creation_time":1732294406,"creation_ttl":2764800,"display_name":"approle","entity_id":"XXX","expire_time":"2024-12-24T16:53:26.932122122Z","explicit_max_ttl":0,"id":"hvs.secretToken","issue_time":"2024-11-22T16:53:26.932129132Z","meta":{"role_name":"myvault"},"num_uses":0,"orphan":true,"path":"auth/approle/login","policies":["default","myvault"],"renewable":true,"ttl":2764724,"type":"service"},"wrap_info":null,"warnings":null,"auth":null,"mount_type":"token"}
  
      return 1;
  }
  
  sub check_authentication {
      my ($self, %options) = @_;
  
      # prepare the cache (aka statefile)
      $self->{cache}->check_options(option_results => $options{option_results});
      my ($dir, $file, $suffix) = $options{option_results}->{vault_cache} =~ /^(.*\/)([^\/]+)(_.*)?$/;
  
      # Try reading the cache file
      if ($self->{cache}->read(
          statefile        => $file,
          statefile_suffix => defined($suffix) ? $suffix : '',
          statefile_dir    => $dir,
          statefile_format => 'json'
      )) {
          # if the cache file could be read, get the token and its expiration date
          $self->{auth} = {
              token            => $self->{cache}->get(name => 'token'),
              expiration_epoch => $self->{cache}->get(name => 'expiration_epoch')
          };
      }
  
      # if it is not valid, authenticate to get a new token
      if ( !$self->is_token_still_valid() ) {
          return $self->authenticate();
      }
  
      return 1;
  }
  
  sub authenticate {
      my ($self) = @_;
  
      # initial value: assuming the role and secret id might not be encrypted
      my $role_id   = $self->{vault}->{role_id};
      my $secret_id = $self->{vault}->{secret_id};
      if (centreon::plugins::misc::is_empty($role_id) || centreon::plugins::misc::is_empty($secret_id)) {
          $self->{output}->add_option_msg(short_msg => "Unable to authenticate to the vault: role_id or secret_id is empty.");
          $self->{output}->option_exit();
      }
      my $decryption_key = $self->get_decryption_key();
  
      # Decrypt the role_id and the secret_id if we have a decryption key
      if ( !centreon::plugins::misc::is_empty($decryption_key) ) {
          $role_id = $self->extract_and_decrypt(
              data => $role_id,
              key  => $decryption_key
          );
          $secret_id = $self->extract_and_decrypt(
              data => $secret_id,
              key  => $decryption_key
          );
      }
  
      # Authenticate to get the token
      my ($auth_result_json) = $self->{http}->request(
          hostname        => $self->{vault}->{url},
          port            => $self->{vault}->{port},
          proto           => $self->{vault}->{protocol},
          method          => 'POST',
          url_path        => "/v1/auth/approle/login",
          query_form_post => "role_id=$role_id&secret_id=$secret_id",
          header          => [
              'Content-Type: application/x-www-form-urlencoded',
              'Accept: */*',
              'X-Vault-Request: true',
              'User-Agent: Centreon-Plugins'
          ]
      );
  
      # Convert the response into a JSON object
      my $auth_result_obj = centreon::plugins::misc::json_decode($auth_result_json);
      if (!defined($auth_result_obj)) {
          # exit with UNKNOWN status
          $self->{output}->add_option_msg(short_msg => "Cannot decode JSON response from the vault server: $auth_result_json.");
          $self->{output}->option_exit();
      }
      # Authentication to the vault has passed
      # store the token (.auth.client_token) and its expiration date (current date + .lease_duration)
      my $expiration_epoch = -1;
      my $lease_duration = $auth_result_obj->{auth}->{lease_duration};
      if ( defined($lease_duration)
              && $lease_duration =~ /\d+/
              && $lease_duration > 0 ) {
          $expiration_epoch = time() + $lease_duration;
      }
      $self->{auth} = {
          'token'            => $auth_result_obj->{auth}->{client_token},
          'expiration_epoch' => $expiration_epoch
      };
      $self->{cache}->write(data => $self->{auth}, name => 'auth');
  
      $self->{output}->output_add(long_msg => "Authenticating worked. Token valid until "
              . localtime($self->{auth}->{expiration_epoch}), debug => 1);
  
      return 1;
  }
  
  
  
  sub request_api {
      my ($self, %options) = @_;
  
      $self->vault_settings(%options);
  
      # check the authentication
      if (!$self->check_authentication(%options)) {
          $self->{output}->add_option_msg(short_msg => "Unable to authenticate to the vault.");
          $self->{output}->option_exit();
      }
  
      $self->{lookup_values} = {};
  
      foreach my $item (@{$self->{request_endpoint}}) {
          # Extract vault name configuration from endpoint
          # 'vault::/v1/<root_path>/monitoring/hosts/7ad55afc-fa9e-4851-85b7-e26f47e421d7'
          my ($endpoint, $secret) = $item =~ /^(.*)\:\:(.*)$/;
  
  
          my ($response) = $self->{http}->request(
              hostname => $self->{vault}->{url},
              port => $self->{vault}->{port},
              proto => $self->{vault}->{protocol},
              method => 'GET',
              url_path => $endpoint,
              header => [
                  'Accept: application/json',
                  'User-Agent: Centreon-Plugins',
                  'X-Vault-Request: true',
                  'X-Vault-Token: ' . $self->{auth}->{token}
              ]
          );
  
          my $json = centreon::plugins::misc::json_decode($response);
          if (!defined($json->{data})) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode Vault JSON response: $response");
              $self->{output}->option_exit();
          };
  
          foreach my $secret_name (keys %{$json->{data}->{data}}) {
              # e.g. secret::hashicorp_vault::myspace/data/snmp::PubCommunity
              $self->{lookup_values}->{'secret::hashicorp_vault::' .  substr($endpoint, index($endpoint, '/', 1) + 1) . '::' . $secret_name} = $json->{data}->{data}->{$secret_name};
          }
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
  
      foreach my $mapping (@{$self->{map_option}}) {
          my ($opt_name, $opt_value) = $mapping =~ /^(.+?)=%(.+)$/ or next;
          $opt_name =~ s/-/_/g;
          $options{option_results}->{$opt_name} = defined($self->{lookup_values}->{$opt_value}) ? $self->{lookup_values}->{$opt_value} : $opt_value;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      $self->extract_map_options(%options);
  
      return if (scalar(@{$self->{map_option}}) <= 0);
  
      $self->request_api(%options);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Centreon Vault password manager
  
  =head1 SYNOPSIS
  
  Centreon Vault password manager
  
  To be used with an array containing keys/values saved in a secret path by resource
  
  =head1 VAULT OPTIONS
  
  =over 8
  
  =item B<--vault-config>
  
  Path to the file defining access to the Centreon vault (default: C</etc/centreon-engine/centreonvault.json>).
  
  =item B<--vault-cache>
  
  Path to the file where the token to access the Centreon vault will be stored (default: C</var/lib/centreon/centplugins/centreonvault_session>).
  
  =item B<--vault-env-file>
  
  Path to the file containing the APP_SECRET variable (default: C</usr/share/centreon/.env>).
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreonvault>.
  
  =cut
  
  =head1 NAME
  
  centreon::plugins::passwordmgr::centreonvault - Module for getting secrets from Centreon Vault.
  
  =head1 SYNOPSIS
  
    use centreon::plugins::passwordmgr::centreonvault;
  
    my $vault = centreon::plugins::passwordmgr::centreonvault->new(output => $output, options => $options);
    $vault->manage_options(option_results => \%option_results);
  
  =head1 DESCRIPTION
  
  This module provides methods to retrieve secrets (passwords, SNMP communities, ...) from Centreon Vault (adequately
  configured HashiCorp Vault).
  It extracts and decrypt the information required to login to the vault from the vault configuration file, authenticates
  to the vault, retrieves secrets, and maps them to the corresponding options for the centreon-plugins to work with.
  
  =head1 METHODS
  
  =head2 new
  
    my $vault = centreon::plugins::passwordmgr::centreonvault->new(%options);
  
  Creates a new `centreon::plugins::passwordmgr::centreonvault` object. The `%options` hash can include:
  
  =over 4
  
  =item * output
  
  The output object for displaying debug and error messages.
  
  =item * options
  
  The options object for handling command-line options.
  
  =back
  
  =head2 extract_map_options
  
    $vault->extract_map_options(option_results => \%option_results);
  
  Extracts and maps options that match the Vault path regex pattern (C</^secret::hashicorp_vault::([^:]+)::(.+)$/>). The
  `%option_results` hash should include the command-line options.
  
  =head2 vault_settings
  
    $vault->vault_settings(option_results => \%option_results);
  
  Loads and validates the Vault configuration from the specified file.
  The `%option_results` hash should include the command-line options.
  
  =head2 get_decryption_key
  
    my $key = $vault->get_decryption_key();
  
  Retrieves the decryption key from C<APP_SECRET> environment variable. It will look for it in the the specified
  environment file if it is not available in the environment variables.
  
  =head2 extract_and_decrypt
  
    my $decrypted_data = $vault->extract_and_decrypt(data => $data, key => $key);
  
  Decrypts the given data using the specified key. The options must include:
  
  =over 4
  
  =item * data
  
  The base64-encoded data to decrypt.
  
  =item * key
  
  The base64-encoded decryption key.
  
  =back
  
  =head2 is_token_still_valid
  
    my $is_valid = $vault->is_token_still_valid();
  
  Checks if there is a token in the cache and if it is still valid based on its expiration date. Returns 1 if valid, otherwise undef.
  
  =head2 check_authentication
  
    $vault->check_authentication(option_results => \%option_results);
  
  Checks the authentication status and retrieves a new token if necessary. The `%option_results` hash should include the command-line options.
  
  =head2 authenticate
  
    $vault->authenticate();
  
  Authenticates to the Vault, retrieves a new token and stores it in the dedicated cache file.
  
  =head2 request_api
  
    $vault->request_api(option_results => \%option_results);
  
  Sends requests to the Vault API to retrieve secrets. The `%option_results` hash should include the command-line options.
  
  =head2 do_map
  
    $vault->do_map(option_results => \%option_results);
  
  Maps the retrieved secrets to the corresponding options. The `%option_results` hash should include the command-line options.
  Calling this method will update the `%option_results` hash replacing vault paths with the retrieved secrets.
  
  =head2 manage_options
  
    $vault->manage_options(option_results => \%option_results);
  
  Manages the options by extracting, requesting, and mapping secrets. The `%option_results` hash should include the command-line options.
  
  NB: This is the main method to be called from outside the module. All other methods are intended to be used internally.
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_CENTREONVAULT

$fatpacked{"centreon/plugins/passwordmgr/environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_ENVIRONMENT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::environment;
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'environment-map-option:s@' => { name => 'environment_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'ENVIRONMENT OPTIONS');
  
      $self->{output} = $options{output};    
  
      return $self;
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      return if (!defined($options{option_results}->{environment_map_option}));
  
      foreach (@{$options{option_results}->{environment_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = defined($ENV{$map}) ? $ENV{$map} : '';
      }
  }
  
  1;
  
  
  =head1 NAME
  
  Environment global
  
  =head1 SYNOPSIS
  
  environment class
  
  =head1 ENVIRONMENT OPTIONS
  
  =over 8
  
  =item B<--environment-map-option>
  
  Overload plugin option.
  Example:
  --environment-map-option="snmp-community=SNMPCOMMUNITY"
  
  =back
  
  =head1 DESCRIPTION
  
  B<environment>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_ENVIRONMENT

$fatpacked{"centreon/plugins/passwordmgr/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_FILE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::file;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use JSON::Path;
  use JSON::XS;
  use Data::Dumper;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'secret-file:s'          => { name => 'secret_file' },
          'secret-search-value:s@' => { name => 'secret_search_value' },
          'secret-map-option:s@'   => { name => 'secret_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'SECRET FILE OPTIONS');
  
      $self->{output} = $options{output};    
      $JSON::Path::Safe = 0;
  
      return $self;
  }
  
  sub load {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}->{secret_file}) && $options{option_results}->{secret_file} ne '') {
          if (! -f $options{option_results}->{secret_file} or ! -r $options{option_results}->{secret_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read secret file '$options{option_results}->{secret_file}': $!");
              $self->{output}->option_exit();
          }
  
          my $content = centreon::plugins::misc::slurp_file(output => $self->{output}, file => $options{option_results}->{secret_file});
  
          my $decoded;
          eval {
              $decoded = JSON::XS->new->utf8->decode($content);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode secret file");
              $self->{output}->option_exit();
          }
  
          return $decoded;
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{secret_search_value}));
      
      foreach (@{$options{option_results}->{secret_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
  
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{secret_map_option}));
      foreach (@{$options{option_results}->{secret_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      my $secrets = $self->load(%options);
      return if (!defined($secrets));
  
      $self->do_lookup(%options, json => $secrets);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Secret file global
  
  =head1 SYNOPSIS
  
  secret file class
  
  =head1 SECRET FILE OPTIONS
  
  =over 8
  
  =item B<--secret-file>
  
  Secret file.
  
  =item B<--secret-search-value>
  
  Looking for a value in the JSON. Can use JSON Path and other option values.
  Example: 
  --secret-search-value='password=$..entries.[?($_->{title} =~ /server/i)].password'
  --secret-search-value='username=$..entries.[?($_->{title} =~ /server/i)].username'
  --secret-search-value='password=$..entries.[?($_->{title} =~ /%{hostname}/i)].password'
  
  =item B<--secret-map-option>
  
  Overload plugin option.
  Example:
  --secret-map-option="password=%{password}"
  --secret-map-option="username=%{username}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<secret file>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_FILE

$fatpacked{"centreon/plugins/passwordmgr/hashicorpvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_HASHICORPVAULT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::hashicorpvault;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::http;
  use Digest::MD5 qw(md5_hex);
  use JSON::XS;
  
  use vars qw($vault_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'auth-method:s'    => { name => 'auth_method', default => 'token' },
          'auth-path:s'      => { name => 'auth_path' },
          'auth-settings:s%' => { name => 'auth_settings' },
          'map-option:s@'    => { name => 'map_option' },
          'secret-path:s@'   => { name => 'secret_path' },
          'vault-address:s'  => { name => 'vault_address'},
          'vault-port:s'     => { name => 'vault_port', default => '8200' },
          'vault-protocol:s' => { name => 'vault_protocol', default => 'http'},
          'vault-token:s'    => { name => 'vault_token'}
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'VAULT OPTIONS');
  
      $self->{output} = $options{output};
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl');
      return $self;
  }
  
  sub get_access_token {
      my ($self, %options) = @_;
  
      my $decoded;
      my $login = $self->parse_auth_method(method => $self->{auth_method}, settings => $self->{auth_settings});
      my $post_json = JSON::XS->new->utf8->encode($login);
      if (!defined($self->{auth_path}) || $self->{auth_path} eq '') {
          $self->{auth_path} = $self->{auth_method};
      }
      my $url_path = '/v1/auth/'. $self->{auth_path} . '/login/';
      $url_path .= $self->{auth_settings}->{username} if (defined($self->{auth_settings}->{username}) && $self->{auth_method} =~ 'userpass|login') ;
  
      my $content = $self->{http}->request(
          hostname => $self->{vault_address},
          port => $self->{vault_port},
          proto => $self->{vault_protocol},
          method => 'POST',
          header => ['Content-type: application/json'],
          query_form_post => $post_json,
          url_path => $url_path
      );
  
      if (!defined($content) || $content eq '') {
          $self->{output}->add_option_msg(short_msg => "Authentication endpoint returns empty content [code: '" . $self->{http}->get_code() . "'] [message: '" . $self->{http}->get_message() . "']");
          $self->{output}->option_exit();
      }
  
      eval {
          $decoded = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $self->{output}->output_add(long_msg => $content, debug => 1);
          $self->{output}->add_option_msg(short_msg => "Cannot decode response (add --debug option to display returned content)");
          $self->{output}->option_exit();
      }
      if (defined($decoded->{errors}[0])) {
          $self->{output}->output_add(long_msg => "Error message : " . $decoded->{errors}[0], debug => 1);
          $self->{output}->add_option_msg(short_msg => "Authentication endpoint returns error code '" . $decoded->{errors}[0] . "' (add --debug option for detailed message)");
          $self->{output}->option_exit();
      }
  
      my $access_token = $decoded->{auth}->{client_token};
      return $access_token;
  }
  
  sub parse_auth_method {
      my ($self, %options) = @_;
  
      my $login_settings;
      my $settings_mapping = {
          azure    => [ 'role', 'jwt' ],
          cert     => [ 'name' ],
          github   => [ 'token' ],
          ldap     => [ 'username', 'password' ],
          okta     => [ 'username', 'password', 'totp' ],
          radius   => [ 'username', 'password' ],
          userpass => [ 'username', 'password' ]
      };
  
      foreach (@{$settings_mapping->{$options{method}}}) {
          if (!defined($options{settings}->{$_})) {
              $self->{output}->add_option_msg(short_msg => 'Missing authentication setting: ' . $_);
              $self->{output}->option_exit();
          }
          $login_settings->{$_} = $options{settings}->{$_};
      };
  
      return $login_settings;
  }
  
  sub settings {
      my ($self, %options) = @_;
  
      if (!defined($options{option_results}->{vault_address}) || $options{option_results}->{vault_address} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set the --vault-address option");
          $self->{output}->option_exit();
      }
  
      if ($options{option_results}->{auth_method} eq 'token' && (!defined($options{option_results}->{vault_token}) || $options{option_results}->{vault_token} eq '')) {
          $self->{output}->add_option_msg(short_msg => "Please set the --vault-token option");
          $self->{output}->option_exit();
      }
  
      if (!defined($options{option_results}->{secret_path}) || $options{option_results}->{secret_path} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set the --secret-path option");
          $self->{output}->option_exit();
      }
  
      if (defined($options{option_results}->{auth_path})) {		
          $self->{auth_path} = lc($options{option_results}->{auth_path});
      }
  
      $self->{auth_method} = lc($options{option_results}->{auth_method});
      $self->{auth_settings} = defined($options{option_results}->{auth_settings}) && $options{option_results}->{auth_settings} ne '' ? $options{option_results}->{auth_settings} : {};
      $self->{vault_address} = $options{option_results}->{vault_address};
      $self->{vault_port} = $options{option_results}->{vault_port};
      $self->{vault_protocol} = $options{option_results}->{vault_protocol};
      $self->{vault_token} = $options{option_results}->{vault_token};
  
      if (lc($self->{auth_method}) !~ m/azure|cert|github|ldap|okta|radius|userpass|token/ ) {
          $self->{output}->add_option_msg(short_msg => "Incorrect or unsupported authentication method set in --auth-method");
          $self->{output}->option_exit();
      }
      foreach (@{$options{option_results}->{secret_path}}) {
          $self->{request_endpoint}->{$_} = '/v1/' . $_;
      }
  
      if (defined($options{option_results}->{auth_method}) && $options{option_results}->{auth_method} ne 'token') {
          $self->{vault_token} = $self->get_access_token(%options);
      };
  
      $self->{http}->add_header(key => 'Accept', value => 'application/json');
      if (defined($self->{vault_token})) {
          $self->{http}->add_header(key => 'X-Vault-Token', value => $self->{vault_token});
      }
  }
  
  sub request_api {
      my ($self, %options) = @_;
  
      $self->settings(%options);
      my ($raw_data, $raw_response);
      foreach my $endpoint (keys %{$self->{request_endpoint}}) {
          my $json;
          my $response = $self->{http}->request(
              hostname => $self->{vault_address},
              port => $self->{vault_port},
              proto => $self->{vault_protocol},
              method => 'GET',
              url_path => $self->{request_endpoint}->{$endpoint}
          );
          $self->{output}->output_add(long_msg => $response, debug => 1);
  
          eval {
              $json = JSON::XS->new->utf8->decode($response);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode Vault JSON response: $@");
              $self->{output}->option_exit();
          }
  
          if ((defined($json->{data}->{metadata}->{deletion_time}) && $json->{data}->{metadata}->{deletion_time} ne '') || $json->{data}->{metadata}->{destroyed} eq 'true') {
              $self->{output}->add_option_msg(short_msg => "This secret is not valid anymore");
              $self->{output}->option_exit();
          }
  
          foreach (keys %{$json->{data}->{data}}) {
              $self->{lookup_values}->{'key_' . $endpoint} = $_;
              $self->{lookup_values}->{'value_' . $endpoint} = $json->{data}->{data}->{$_};
          }
          push(@{$raw_data}, $json);
          push(@{$raw_response}, $response);
      }
  
      return ($raw_data, $raw_response);
  }
  
  sub do_map {
      my ($self, %options) = @_;
  
      return if (!defined($options{option_results}->{map_option}));
      foreach (@{$options{option_results}->{map_option}}) {
          next if (! /^(.+?)=(.+)$/);
  
          my ($option, $map) = ($1, $2);
  
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g;
          }
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      my ($content, $debug) = $self->request_api(%options);
      if (!defined($content)) {
          $self->{output}->add_option_msg(short_msg => "Cannot read Vault information");
          $self->{output}->option_exit();
      }
      $self->do_map(%options);
      $self->{output}->output_add(long_msg => Data::Dumper::Dumper($debug), debug => 1) if ($self->{output}->is_debug());
  }
  
  1;
  
  
  =head1 NAME
  
  HashiCorp Vault global
  
  =head1 SYNOPSIS
  
  HashiCorp Vault class
  To be used with K/V engines
  
  =head1 VAULT OPTIONS
  
  =over 8
  
  =item B<--vault-address>
  
  IP address of the HashiCorp Vault server (mandatory).
  
  =item B<--vault-port>
  
  Port of the HashiCorp Vault server (default: '8200').
  
  =item B<--vault-protocol>
  
  HTTP of the HashiCorp Vault server.
  Can be: 'http', 'https' (default: http).
  
  =item B<--auth-method>
  
  Authentication method to log in against the Vault server.
  Can be: 'azure', 'cert', 'github', 'ldap', 'okta', 'radius', 'userpass' (default: 'token');
  
  =item B<--auth-path>
  
  Authentication path for 'userpass'. Is an optional setting.
  
  More information here: https://developer.hashicorp.com/vault/docs/auth/userpass#configuration
  
  =item B<--vault-token>
  
  Directly specify a valid token to log in (only for --auth-method='token').
  
  =item B<--auth-settings>
  
  Required information to log in according to the selected method.
  Examples:
  for 'userpass': --auth-settings='username=user1' --auth-settings='password=my_password'
  for 'azure': --auth-settings='role=my_azure_role' --auth-settings='jwt=my_azure_token'
  
  More information here: https://www.vaultproject.io/api-docs/auth
  
  =item B<--secret-path>
  
  Location of the secret in the Vault K/V engine (mandatory - Can be multiple).
  Examples:
  for v1 engine: --secret-path='mysecrets/servicecredentials'
  for v2 engine: --secret-path='mysecrets/data/servicecredentials?version=12'
  
  More information here: https://www.vaultproject.io/api-docs/secret/kv
  
  =item B<--map-option>
  
  Overload Plugin option with K/V values.
  Use the following syntax:
  the_option_to_overload='%{key_$secret_path$}' or
  the_option_to_overload='%{value_$secret_path$}'
  Example:
  --map-option='username=%{key_mysecrets/servicecredentials}'
  --map-option='password=%{value_mysecrets/servicecredentials}'
  
  =back
  
  =head1 DESCRIPTION
  
  B<hashicorpvault>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_HASHICORPVAULT

$fatpacked{"centreon/plugins/passwordmgr/keepass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_KEEPASS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::keepass;
  
  use strict;
  use warnings;
  use JSON::Path;
  use Data::Dumper;
  use KeePass::Reader;
  
  use vars qw($keepass_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'keepass-endpoint:s'        => { name => 'keepass_endpoint' },
          'keepass-endpoint-file:s'   => { name => 'keepass_endpoint_file' },
          'keepass-file:s'            => { name => 'keepass_file' },
          'keepass-password:s'        => { name => 'keepass_password' },
          'keepass-search-value:s@'   => { name => 'keepass_search_value' },
          'keepass-map-option:s@'     => { name => 'keepass_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'KEEPASS OPTIONS');
  
      $self->{output} = $options{output};    
      $JSON::Path::Safe = 0;
  
      return $self;
  }
  
  sub build_api_args {
      my ($self, %options) = @_;
      
      $self->{connection_info} = { file => undef, password => undef };
      if (defined($options{option_results}->{keepass_endpoint_file}) && $options{option_results}->{keepass_endpoint_file} ne '') {
          if (! -f $options{option_results}->{keepass_endpoint_file} or ! -r $options{option_results}->{keepass_endpoint_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read keepass endpoint file: $!");
              $self->{output}->option_exit();
          }
          
          require $options{option_results}->{keepass_endpoint_file};
          if (defined($keepass_connections) && defined($options{option_results}->{keepass_endpoint}) && $options{option_results}->{keepass_endpoint} ne '') {
              if (!defined($keepass_connections->{$options{option_results}->{keepass_endpoint}})) {
                  $self->{output}->add_option_msg(short_msg => "Endpoint $options{option_results}->{keepass_endpoint} doesn't exist in keepass endpoint file");
                  $self->{output}->option_exit();
              }
              
              $self->{connection_info} = $keepass_connections->{$options{option_results}->{keepass_endpoint}};
          }
      }
      
      foreach (['keepass_file', 'file'], ['keepass_password', 'password']) {
          if (defined($options{option_results}->{$_->[0]}) && $options{option_results}->{$_->[0]} ne '') {
              $self->{connection_info}->{$_->[1]} = $options{option_results}->{$_->[0]};
          }
      }
      
      if (defined($self->{connection_info}->{file}) && $self->{connection_info}->{file} ne '') {
          if (!defined($self->{connection_info}->{password}) || $self->{connection_info}->{password} eq '') {
              $self->{output}->add_option_msg(short_msg => "Please set keepass-password option");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{keepass_search_value}));
      
      foreach (@{$options{option_results}->{keepass_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
                  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
          
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{keepass_map_option}));
      foreach (@{$options{option_results}->{keepass_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      $self->build_api_args(%options);
      return if (!defined($self->{connection_info}->{file}));
      
      my $keepass = KeePass::Reader->new();
      my $content = $keepass->load_db(file => $self->{connection_info}->{file}, password => $self->{connection_info}->{password});
      if (!defined($content)) {
          $self->{output}->add_option_msg(short_msg => "Cannot read keepass file: " . $keepass->error());
          $self->{output}->option_exit();
      }
      $self->{output}->output_add(long_msg => Data::Dumper::Dumper($content), debug => 1) if ($self->{output}->is_debug());
  
      $self->do_lookup(%options, json => $content);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Keepass global
  
  =head1 SYNOPSIS
  
  keepass class
  
  =head1 KEEPASS OPTIONS
  
  =over 8
  
  =item B<--keepass-endpoint>
  
  Connection information to be used in keepass file.
  
  =item B<--keepass-endpoint-file>
  
  File with keepass connection informations.
  
  =item B<--keepass-file>
  
  Keepass file.
  
  =item B<--keepass-password>
  
  Keepass master password.
  
  =item B<--keepass-search-value>
  
  Looking for a value in the JSON keepass. Can use JSON Path and other option values.
  Example: 
  --keepass-search-value='password=$..entries.[?($_->{title} =~ /serveurx/i)].password'
  --keepass-search-value='username=$..entries.[?($_->{title} =~ /serveurx/i)].username'
  --keepass-search-value='password=$..entries.[?($_->{title} =~ /%{hostname}/i)].password'
  
  =item B<--keepass-map-option>
  
  Overload plugin option.
  Example:
  --keepass-map-option="password=%{password}"
  --keepass-map-option="username=%{username}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<keepass>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_KEEPASS

$fatpacked{"centreon/plugins/passwordmgr/teampass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_TEAMPASS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::teampass;
  
  use strict;
  use warnings;
  use JSON::Path;
  use JSON::XS;
  use Data::Dumper;
  use centreon::plugins::http;
  
  use vars qw($teampass_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          "teampass-endpoint:s"       => { name => 'teampass_endpoint' },
          "teampass-endpoint-file:s"  => { name => 'teampass_endpoint_file' },
          "teampass-api-key:s"        => { name => 'teampass_api_key' },
          "teampass-api-address:s"    => { name => 'teampass_api_address' },
          "teampass-api-request:s"    => { name => 'teampass_api_request' },
          "teampass-search-value:s@"  => { name => 'teampass_search_value' },
          "teampass-map-option:s@"    => { name => 'teampass_map_option' },
          "teampass-timeout:s"        => { name => 'teampass_timeout' },
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'TEAMPASS OPTIONS');
  
      $self->{output} = $options{output};    
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl');
      $JSON::Path::Safe = 0;
      
      return $self;
  }
  
  sub build_api_args {
      my ($self, %options) = @_;
      
      $self->{connection_info} = { address => undef, key => undef, request => undef };
      if (defined($options{option_results}->{teampass_endpoint_file}) && $options{option_results}->{teampass_endpoint_file} ne '') {
          if (! -f $options{option_results}->{teampass_endpoint_file} or ! -r $options{option_results}->{teampass_endpoint_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read teampass file: $!");
              $self->{output}->option_exit();
          }
          
          require $options{option_results}->{teampass_endpoint_file};
          if (defined($teampass_connections) && defined($options{option_results}->{teampass_endpoint}) && $options{option_results}->{teampass_endpoint} ne '') {
              if (!defined($teampass_connections->{$options{option_results}->{teampass_endpoint}})) {
                  $self->{output}->add_option_msg(short_msg => "Endpoint $options{option_results}->{teampass_endpoint} doesn't exist in teampass file");
                  $self->{output}->option_exit();
              }
              
              $self->{connection_info} = $teampass_connections->{$options{option_results}->{teampass_endpoint}};
          }
      }
      
      foreach (['teampass_api_address', 'address'], ['teampass_api_key', 'key'], ['teampass_api_request', 'request']) {
          if (defined($options{option_results}->{$_->[0]}) && $options{option_results}->{$_->[0]} ne '') {
              $self->{connection_info}->{$_->[1]} = $options{option_results}->{$_->[0]};
          }
      }
      
      if (defined($self->{connection_info}->{address}) && $self->{connection_info}->{address} ne '') {
          foreach ('key', 'request') {
              if (!defined($self->{connection_info}->{$_}) || $self->{connection_info}->{$_} eq '') {
                  $self->{output}->add_option_msg(short_msg => "Please set teampass-api-$_ option");
                  $self->{output}->option_exit();
              }
          }
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{teampass_search_value}));
      
      foreach (@{$options{option_results}->{teampass_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
                  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
          
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{teampass_map_option}));
      foreach (@{$options{option_results}->{teampass_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      $self->build_api_args(%options);
      return if (!defined($self->{connection_info}->{address}));
      
      $self->{http}->set_options(
          timeout => $options{option_results}->{teampass_timeout},
          unknown_status => '%{http_code} < 200 or %{http_code} >= 300',
      );
      my $response = $self->{http}->request(method => 'GET', 
          full_url => $self->{connection_info}->{address} . $self->{connection_info}->{request}, 
          hostname => '',
          get_param => ['apikey=' . $self->{connection_info}->{key}],
      );
      $self->{output}->output_add(long_msg => $response, debug => 1);
      
      my $json;
      eval {
          $json = JSON::XS->new->utf8->decode($response);
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "Cannot decode teampass json response: $@");
          $self->{output}->option_exit();
      }
      
      $self->do_lookup(%options, json => $json);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Teampass global
  
  =head1 SYNOPSIS
  
  teampass class
  
  =head1 TEAMPASS OPTIONS
  
  =over 8
  
  =item B<--teampass-endpoint>
  
  Connection information to be used in teampass file.
  
  =item B<--teampass-endpoint-file>
  
  File with teampass connection informations.
  
  =item B<--teampass-timeout>
  
  Set HTTP Rest API timeout (default: 5).
  
  =item B<--teampass-api-key>
  
  Teampass API Key.
  
  =item B<--teampass-api-address>
  
  Teampass URL (example: http://10.0.0.1/teampass).
  
  =item B<--teampass-api-request>
  
  Teampass request (example: /api/index.php/folder/3).
  
  =item B<--teampass-search-value>
  
  Looking for a value in the JSON teampass response. Can use JSON Path and other option values.
  Example: 
  --teampass-search-value='password=$.[?($_->{label} =~ /serveur1/i)].pw'
  --teampass-search-value='login=$.[?($_->{label} =~ /serveur1/i)].login'
  --teampass-search-value='password=$.[?($_->{label} =~ /%{hostname}/i)].pw'
  
  =item B<--teampass-map-option>
  
  Overload plugin option.
  Example:
  --teampass-map-option="password=%{password}"
  --teampass-map-option="username=%{login}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<teampass>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_TEAMPASS

$fatpacked{"centreon/plugins/perfdata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PERFDATA';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::perfdata;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{output} = $options{output};
      # Typical Nagios Perfdata 'with ~ @ ..'
      $self->{threshold_label} = {};
      $self->{float_precision} = defined($self->{output}->{option_results}->{float_precision}) && $self->{output}->{option_results}->{float_precision} =~ /\d+/ ?  
          int($self->{output}->{option_results}->{float_precision}) : 8;
  
      return $self;
  }
  
  sub get_perfdata_for_output {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{total} : percent threshold to transform in global
      # $options{cast_int} : cast absolute to int
      # $options{op} : operator to apply to start/end value (uses with 'value'})
      # $options{value} : value to apply with 'op' option
      
      if (!defined($self->{threshold_label}->{$options{label}}->{value}) || $self->{threshold_label}->{$options{label}}->{value} eq '') {
          return '';
      }
      
      my %perf_value = %{$self->{threshold_label}->{$options{label}}};
      
      if (defined($options{op}) && defined($options{value})) {
          eval "\$perf_value{start} = \$perf_value{start} $options{op} \$options{value}" if ($perf_value{infinite_neg} == 0);
          eval "\$perf_value{end} = \$perf_value{end} $options{op} \$options{value}" if ($perf_value{infinite_pos} == 0);
      }
      if (defined($options{total})) {
          $perf_value{start} = $perf_value{start} * $options{total} / 100 if ($perf_value{infinite_neg} == 0);
          $perf_value{end} = $perf_value{end} * $options{total} / 100 if ($perf_value{infinite_pos} == 0);
          $perf_value{start} = sprintf("%.2f", $perf_value{start}) if ($perf_value{infinite_neg} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
          $perf_value{end} = sprintf("%.2f", $perf_value{end}) if ($perf_value{infinite_pos} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
      }
      
      $perf_value{start} = int($perf_value{start}) if ($perf_value{infinite_neg} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      $perf_value{end} = int($perf_value{end}) if ($perf_value{infinite_pos} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      
      my $perf_output = ($perf_value{arobase} == 1 ? '@' : '') . 
                        (($perf_value{infinite_neg} == 0) ? $perf_value{start} : '~') . 
                        ':' . 
                        (($perf_value{infinite_pos} == 0) ? $perf_value{end} : '');
  
      return $perf_output;
  }
  
  sub threshold_validate {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{value} : threshold value
  
      my $status = 1;
      $self->{threshold_label}->{$options{label}} = { value => $options{value}, start => undef, end => undef, arobase => undef, infinite_neg => undef, infinite_pos => undef };
      if (!defined($options{value}) || $options{value} eq '') {
          return $status;
      }
  
      ($status, my $result_perf) = 
          centreon::plugins::misc::parse_threshold(threshold => $options{value});
      $self->{threshold_label}->{$options{label}} = { %{$self->{threshold_label}->{$options{label}}}, %$result_perf };
      
      $self->{threshold_label}->{$options{label}}->{start_precision} = $self->{threshold_label}->{$options{label}}->{start};
      if ($self->{threshold_label}->{$options{label}}->{start} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{start_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{start});
      }
      
      $self->{threshold_label}->{$options{label}}->{end_precision} = $self->{threshold_label}->{$options{label}}->{end};
      if ($self->{threshold_label}->{$options{label}}->{end} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{end_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{end});
      }
      
      return $status;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      # Can check multiple threshold. First match: out. Order is important
      # options{value}: value to compare
      # options{threshold}: ref to an array (example: [ {label => 'warning', exit_litteral => 'warning' }, {label => 'critical', exit_litteral => 'critical'} ]
      if ($options{value} =~ /[.,]/) {
          $options{value} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $options{value});
      }
  
      foreach (@{$options{threshold}}) {
          next if (!defined($self->{threshold_label}->{$_->{label}}));
          next if (!defined($self->{threshold_label}->{$_->{label}}->{value}) || $self->{threshold_label}->{$_->{label}}->{value} eq '');
          if ($self->{threshold_label}->{$_->{label}}->{arobase} == 0 && ($options{value} < $self->{threshold_label}->{$_->{label}}->{start_precision} || $options{value} > $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          } elsif ($self->{threshold_label}->{$_->{label}}->{arobase}  == 1 && ($options{value} >= $self->{threshold_label}->{$_->{label}}->{start_precision} && $options{value} <= $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          }
      }
  
      return 'ok';
  }
  
  sub trim {
      my ($self, $value) = @_;
      
      $value =~ s/^[ \t]+//;
      $value =~ s/[ \t]+$//;
      return $value;
  }
  
  sub change_bytes {
      my ($self, %options) = @_;
  
      my $value = $options{value};
      my $divide = defined($options{network}) ? 1000 : 1024;
      my @units = ('K', 'M', 'G', 'T');
      my $unit = '';
      my $sign = '';
  
      $sign = '-' if ($value != abs($value));
      $value = abs($value);
      
      for (my $i = 0; $i < scalar(@units); $i++) {
          last if (($value / $divide) < 1);
          $unit = $units[$i];
          $value = $value / $divide;
      }
  
      return (sprintf('%.2f', $sign . $value), $unit . (defined($options{network}) ? 'b' : 'B'));
  }
  
  1;
  
  
  =head1 NAME
  
  Perfdata class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 DESCRIPTION
  
  B<perfdata>.
  
  =cut
CENTREON_PLUGINS_PERFDATA

$fatpacked{"centreon/plugins/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script;
  
  use strict;
  use warnings;
  use centreon::plugins::output;
  use centreon::plugins::misc;
  use Pod::Usage;
  
  my %handlers = (DIE => {}, ALRM => {});
  
  my $global_version = '20251000 (1b86ebfb1)';
  my $alternative_fatpacker = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{options} = undef;
      $self->{plugin} = undef;
      $self->{help} = undef;
  
      # Avoid to destroy because it keeps a ref on the object. 
      # A problem if we execute it multiple times in the same perl execution
      # Use prepare_destroy
      $self->set_signal_handlers();
      return $self;
  }
  
  sub prepare_destroy {
      my ($self) = @_;
  
      %handlers = ();
  }
  
  sub set_signal_handlers {
      my ($self) = @_;
  
      $SIG{__DIE__} = \&class_handle_DIE;
      $handlers{DIE}->{$self} = sub { $self->handle_DIE($_[0]) };
  }
  
  sub class_handle_DIE {
      my ($msg) = @_;
  
      foreach (keys %{$handlers{DIE}}) {
          &{$handlers{DIE}->{$_}}($msg);
      }
  }
  
  sub class_handle_ALRM {
      foreach (keys %{$handlers{ALRM}}) {
          &{$handlers{ALRM}->{$_}}();
      }
  }
  
  sub handle_DIE {
      my ($self, $msg) = @_;
  
      return unless defined $^S and $^S == 0; # Ignore errors in eval
      $self->{output}->add_option_msg(short_msg => $msg);
      $self->{output}->die_exit();
  }
  
  sub handle_ALRM {
      my ($self) = @_;
  
      $self->{output}->add_option_msg(short_msg => 'script global timeout');
      $self->{output}->option_exit();
  }
  
  sub get_global_version {
      return $global_version;
  }
  
  sub get_plugin {
      my ($self) = @_;
  
      # Need to load global 'Output' and 'Options'
      if ($alternative_fatpacker == 0) {
          require centreon::plugins::options;
          $self->{options} = centreon::plugins::options->new();
      } else {
          require centreon::plugins::alternative::FatPackerOptions;
          $self->{options} = centreon::plugins::alternative::FatPackerOptions->new();
      }
      $self->{output} = centreon::plugins::output->new(options => $self->{options});
      $self->{options}->set_output(output => $self->{output});
  
      $self->{options}->add_options(arguments => {
          'plugin:s'          => { name => 'plugin' },
          'list-plugin'       => { name => 'list_plugin' }, 
          'help'              => { name => 'help' },
          'ignore-warn-msg'   => { name => 'ignore_warn_msg' },
          'version'           => { name => 'version' },
          'runas:s'           => { name => 'runas' },
          'global-timeout:s'  => { name => 'global_timeout' },
          'environment:s%'    => { name => 'environment' },
          'convert-args:s'    => { name => 'convert_args' },
      });
  
      $self->{options}->parse_options();
  
      $self->{plugin} = $self->{options}->get_option(argument => 'plugin');
      $self->{list_plugin} = $self->{options}->get_option(argument => 'list_plugin');
      $self->{help} = $self->{options}->get_option(argument => 'help');
      $self->{version} = $self->{options}->get_option(argument => 'version');
      $self->{runas} = $self->{options}->get_option(argument => 'runas');
      $self->{environment} = $self->{options}->get_option(argument => 'environment');
      $self->{ignore_warn_msg} = $self->{options}->get_option(argument => 'ignore_warn_msg');
      $self->{convert_args} = $self->{options}->get_option(argument => 'convert_args');
  
      my $global_timeout = $self->{options}->get_option(argument => 'global_timeout');
      if (defined($global_timeout) && $global_timeout =~ /(\d+)/) {
          $SIG{ALRM} = \&class_handle_ALRM;
          $handlers{ALRM}->{$self} = sub { $self->handle_ALRM() };
          alarm($1);
      }
  
      $self->{output}->plugin(name => $self->{plugin});
      $self->{output}->check_options(option_results => $self->{options}->get_options());
  
      $self->{options}->clean();
  }
  
  sub convert_args {
      my ($self) = @_;
  
      if ($self->{convert_args} =~ /^(.+?),(.*)/) {
          my ($search, $replace) = ($1, $2);
          for (my $i = 0; $i <= $#ARGV; $i++) {
              eval "\$ARGV[\$i] =~ s/$search/$replace/g";
          }
      }
  }
  
  sub display_local_help {
      my ($self) = @_;
  
      my $stdout;
      if ($self->{help}) {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
  
          if ($alternative_fatpacker == 0) {
              pod2usage(-exitval => 'NOEXIT', -input => $self->{options}->pod_where(package => __PACKAGE__));
          } else {
              my $pp = __PACKAGE__ . '.pm';
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh);
              close $str_fh;
          }
      }
  
      $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
  }
  
  sub check_directory {
      my ($self, $directory) = @_;
  
      opendir(my $dh, $directory) || return ;
      while (my $filename = readdir $dh) {
          $self->check_directory($directory . '/' . $filename) if ($filename !~ /^\./ && -d $directory . '/' . $filename);
          if ($filename eq 'plugin.pm') {
              my $stdout = '';
  
              {
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  pod2usage(
                      -exitval => 'NOEXIT',
                      -input => $directory . "/" . $filename,
                      -verbose => 99, 
                      -sections => 'PLUGIN DESCRIPTION'
                  );
              }
              $self->{plugins_result}->{$directory . '/' . $filename} = $stdout;
          }
      }
      closedir $dh;
  }
  
  sub fatpacker_find_plugin {
      my ($self) = @_;
      
      my $plugins = [];
      foreach (@INC) {
          next if (ref($_) !~ /FatPacked/);
          foreach my $name (keys %$_) {
              if ($name =~ /plugin.pm$/) {
                  push @$plugins, $name;
              }
          }
      }
  
      return $plugins;
  }
  
  sub check_plugin_option {
      my ($self) = @_;
  
      if (defined($self->{version})) {
          $self->{output}->add_option_msg(short_msg => 'Global Version: ' . $global_version);
          $self->{output}->option_exit(nolabel => 1);
      }
  
      my $no_plugin = 1;
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          if (scalar(@$integrated_plugins) == 1) {
              $self->{plugin} = $integrated_plugins->[0];
              $no_plugin = 0;
          }
      }
  
      if ($no_plugin == 1) {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--plugin' option.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_list_plugin {
      my ($self) = @_;
      $self->{plugins_result} = {};
  
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
  
          foreach my $key (sort @$integrated_plugins) {
              # Need to load it to get the description
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output}, module => $key, 
                  error_msg => 'Cannot load module --plugin.'
              );
  
              my $name = $key;
              $name =~ s/\.pm//g;
              $name =~ s/\//::/g;
              $self->{output}->add_option_msg(long_msg => '-----------------');
              $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
              {
                  my $stdout = '';
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  my $content_class = $INC{$key}->{$key};
                  open my $str_fh, '<', \$content_class;
                  pod2usage(-exitval => 'NOEXIT', -input => $str_fh, -verbose => 99, -sections => 'PLUGIN DESCRIPTION');
                  close $str_fh;
                  $self->{output}->add_option_msg(long_msg => $stdout);
              }
          }
          return ;
      }
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'FindBin', 
          error_msg => "Cannot load module 'FindBin'."
      );
      my $directory = $FindBin::Bin;
      if (defined($ENV{PAR_TEMP})) {
          $directory = $ENV{PAR_TEMP} . '/inc/lib';
      }
      # Search file 'plugin.pm'
      $self->check_directory($directory);
      foreach my $key (sort keys %{$self->{plugins_result}}) {
          my $name = $key;
          $name =~ s/^\Q$directory\E\/(.*)\.pm/$1/;
          $name =~ s/\//::/g;
          $self->{plugins_result}->{$key} =~ s/^Plugin Description/DESCRIPTION/i;
  
          $self->{output}->add_option_msg(long_msg => '-----------------');
          $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
          $self->{output}->add_option_msg(long_msg => $self->{plugins_result}->{$key});
      }
  }
  
  sub check_relaunch_get_args {
      my ($self) = @_;
  
      my $args = ['--plugin=' . $self->{plugin}, @ARGV];
      push @$args, '--ignore-warn-msg' if (defined($self->{ignore_warn_msg}));
      push @$args, '--help' if (defined($self->{help}));
      push @$args, '--global-timeout', $self->{global_timeout} if (defined($self->{global_timeout}));
      foreach ((
          ['output_xml', 0], ['output_json', 0], ['output_openmetrics', 0], 
          ['disco_format', 0], ['disco_show', 0], ['use_new_perfdata', 0], ['debug', 0], ['verbose', 0],
          ['range_perfdata', 1], ['filter_uom', 1], ['opt_exit', 1], ['filter_perfdata', 1],
          ['output_file', 1], ['float_precision', 1]
      )) {
          my $option = $self->{output}->get_option(option => $_->[0]);
          if (defined($option)) {
              my $option_label = $_->[0];
              $option_label =~ s/_/-/g;
              push @$args, "--$option_label" if ($_->[1] == 0);
              push @$args, "--$option_label", $option if ($_->[1] == 1);
          }
      }
  
      return $args;
  }
  
  sub check_relaunch {
      my $self = shift;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'FindBin', 
          error_msg => "Cannot load module 'FindBin'."
      );
  
      my $need_restart = 0;
      my $cmd = $FindBin::Bin . '/' . $FindBin::Script;
      my $args = [];
  
      if (defined($self->{environment})) {
          foreach (keys %{$self->{environment}}) {
              if ($_ ne '' && (!defined($ENV{$_}) || $ENV{$_} ne $self->{environment}->{$_})) {
                  $ENV{$_} = $self->{environment}->{$_};
                  $need_restart = 1;
              }
          }
      }
  
      my $rebuild_args = $self->check_relaunch_get_args();
  
      if (defined($self->{runas}) && $self->{runas} ne '') {
          # Check if it's already me and user exist ;)
          my ($name, $passwd, $uid) = getpwnam($self->{runas});
          if (!defined($uid)) {
              $self->{output}->add_option_msg(short_msg => "Runas user '" . $self->{runas} . "' not exist.");
              $self->{output}->option_exit();
          }
          if ($uid != $>) {
              if ($> == 0) {
                  unshift @$args, '-s', '/bin/bash', '-l', $self->{runas}, '-c', join(' ', $cmd, @$rebuild_args);
                  $cmd = 'su';
              } else {
                  unshift @$args, '-S', '-u', $self->{runas}, $cmd, @$rebuild_args;
                  $cmd = 'sudo';
              }
              $need_restart = 1;
          }
      }
  
      if ($need_restart == 1) {
          if (scalar(@$args) <= 0) {
              unshift @$args, @$rebuild_args;
          }
  
          my ($lerror, $stdout, $exit_code) = centreon::plugins::misc::backtick(
              command => $cmd,
              arguments => $args,
              timeout => 30,
              wait_exit => 1
          );
  
          if ($exit_code <= -1000) {
              if ($exit_code == -1000) {
                  $self->{output}->output_add(
                      severity => 'UNKNOWN', 
                      short_msg => $stdout
                  );
              }
              $self->{output}->display();
              $self->{output}->exit();
          }
          chomp $stdout;
          print $stdout . "\n";
          # We put unknown
          if (!($exit_code >= 0 && $exit_code <= 4)) {
              exit 3;
          }
          exit $exit_code;
      }
  }
  
  sub run {
      my ($self) = @_;
  
      $self->get_plugin();
  
      if (defined($self->{help}) && !defined($self->{plugin})) {
          $self->display_local_help();
          $self->{output}->option_exit();
      }
      if (defined($self->{list_plugin})) {
          $self->display_list_plugin();
          $self->{output}->option_exit();
      }
      $self->check_plugin_option() if (!defined($self->{plugin}) || $self->{plugin} eq '');
      if (defined($self->{ignore_warn_msg})) {
          $SIG{__WARN__} = sub {};
      }
      $self->convert_args() if (defined($self->{convert_args}));
  
      $self->check_relaunch();
  
      (undef, $self->{plugin}) = 
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => $self->{plugin}, 
              error_msg => 'Cannot load module --plugin.'
          );
      my $plugin = $self->{plugin}->new(options => $self->{options}, output => $self->{output});
      $plugin->init(
          help => $self->{help},
          version => $self->{version}
      );
      $plugin->run();
  }
  
  1;
  
  
  =head1 NAME
  
  centreon_plugins.pl - main program to call Centreon plugins.
  
  =head1 SYNOPSIS
  
  centreon_plugins.pl [options]
  
  =head1 OPTIONS
  
  =over 8
  
  =item B<--plugin>
  
  Specify the path to the plugin.
  
  =item B<--list-plugin>
  
  List all available plugins.
  
  =item B<--version>
  
  Return the version of the plugin.
  
  =item B<--help>
  
  Return the help message for the plugin and exit.
  
  =item B<--ignore-warn-msg>
  
  Ignore Perl warning messages (they will not be displayed).
  
  =item B<--runas>
  
  Run the script as a different user.
  
  =item B<--global-timeout>
  
  Define the script's timeout.
  
  =item B<--environment>
  
  Define environment variables for the script (set them in the execution environment
  before running it for better performance).
  
  =item B<--convert-args>
  
  Replace a pattern in the provided arguments. Useful to bypass forbidden characters.
  E.g.: when a password transmitted via the NRPE protocol contains '!' (which is
  interpreted as a separator), you can send '##' instead of the '!' and the plugin will replace '##' with '!', using the --convert-args='##,\x21' option.
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreon_plugins.pl> .
  
  =cut
CENTREON_PLUGINS_SCRIPT

$fatpacked{"centreon/plugins/script_snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT_SNMP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script_snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::snmp;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      $self->{options} = $options{options};
      $self->{output} = $options{output};
      
      $self->{options}->add_options(
          arguments => {
              'mode:s'            => { name => 'mode_name' },
              'dyn-mode:s'        => { name => 'dynmode_name' },
              'list-mode'         => { name => 'list_mode' },
              'mode-version:s'    => { name => 'mode_version' },
              'no-sanity-options' => { name => 'no_sanity_options' },
              'pass-manager:s'    => { name => 'pass_manager' },
          }
      );
      $self->{version} = '1.0';
      $self->{modes} = {};
      $self->{default} = undef;
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      foreach (keys %{$self->{option_results}}) {
          $self->{$_} = $self->{option_results}->{$_};
      }
      $self->{options}->clean();
  
      $self->{options}->add_help(package => $options{package}, sections => 'PLUGIN DESCRIPTION');
      $self->{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL OPTIONS');
      $self->{output}->mode(name => $self->{mode_name});
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
  
      # add meta mode
      $self->{modes}->{multi} = 'centreon::plugins::multi';
      if (defined($options{help}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->version();
      }
      if (defined($self->{list_mode})) {
          $self->list_mode();
      }
      $self->{options}->set_sanity() if (!defined($self->{no_sanity_options}));
  
      # Output HELP
      $self->{options}->add_help(package => 'centreon::plugins::output', sections => 'OUTPUT OPTIONS');
  
      $self->load_password_mgr();
  
      # SNMP
      $self->{snmp} = centreon::plugins::snmp->new(options => $self->{options}, output => $self->{output});
  
      # Load mode
      if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
          $self->is_mode(mode => $self->{mode_name});
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{modes}{$self->{mode_name}}, 
                                                 error_msg => "Cannot load module --mode.");
          $self->{mode} = $self->{modes}{$self->{mode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{mode_name});
      } elsif (defined($self->{dynmode_name}) && $self->{dynmode_name} ne '') {
          (undef, $self->{dynmode_name}) = centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{dynmode_name}, 
                                                                                  error_msg => "Cannot load module --dyn-mode.");
          $self->{mode} = $self->{dynmode_name}->new(options => $self->{options}, output => $self->{output}, mode => $self->{dynmode_name});
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--mode' or '--dyn-mode' option.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{help})) {
          if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
              $self->{options}->add_help(package => $self->{modes}{$self->{mode_name}}, sections => 'MODE');
          } else {
              $self->{options}->add_help(package => $self->{dynmode_name}, sections => 'MODE');
          }
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version})) {
          $self->{mode}->version();
          $self->{output}->option_exit(nolabel => 1);
      }
      if (centreon::plugins::misc::minimal_version($self->{mode}->{version}, $self->{mode_version}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Not good version for plugin mode. Excepted at least: " . $self->{mode_version} . ". Get: ".  $self->{mode}->{version});
          $self->{output}->option_exit();
      }
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      
      $self->{pass_mgr}->manage_options(option_results => $self->{option_results}) if (defined($self->{pass_mgr}));
      $self->{snmp}->check_options(option_results => $self->{option_results});
      $self->{mode}->check_options(
          option_results => $self->{option_results},
          default => $self->{default},
          snmp => $self->{snmp},
          modes => $self->{modes} # for meta mode multi
      );
  }
  
  sub load_password_mgr {
      my ($self, %options) = @_;
      
      return if (!defined($self->{option_results}->{pass_manager}) || $self->{option_results}->{pass_manager} eq '');
  
      (undef, my $pass_mgr_name) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => "centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager}, 
          error_msg => "Cannot load module 'centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager} . "'"
      );
      $self->{pass_mgr} = $pass_mgr_name->new(options => $self->{options}, output => $self->{output});
  }
  
  sub run {
      my ($self) = @_;
  
      if ($self->{output}->is_disco_format()) {
          $self->{mode}->disco_format();
          $self->{output}->display_disco_format();
          $self->{output}->exit(exit_litteral => 'ok');
      }
  
      $self->{snmp}->connect();
      if ($self->{output}->is_disco_show()) {
          $self->{mode}->disco_show(snmp => $self->{snmp});
          $self->{output}->display_disco_show();
          $self->{output}->exit(exit_litteral => 'ok');
      } else {
          $self->{mode}->run(snmp => $self->{snmp});
      }
  }
  
  sub is_mode {
      my ($self, %options) = @_;
  
      if (!defined($self->{modes}{$options{mode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{mode} . "' doesn't exist (use --list-mode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub version {
      my ($self) = @_;    
      $self->{output}->add_option_msg(short_msg => 'Plugin Version: ' . $self->{version});
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_mode {
      my ($self) = @_;
      $self->{options}->display_help();
  
      $self->{output}->add_option_msg(long_msg => 'Modes Meta:');
      $self->{output}->add_option_msg(long_msg => '   multi');
      $self->{output}->add_option_msg(long_msg => '');
      $self->{output}->add_option_msg(long_msg => 'Modes Available:');
      foreach (sort keys %{$self->{modes}}) {
          next if ($_ eq 'multi');
          $self->{output}->add_option_msg(long_msg => '   ' . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  1;
  
  
  =head1 NAME
  
  -
  
  =head1 SYNOPSIS
  
  -
  
  =head1 GLOBAL OPTIONS
  
  =over 8
  
  =item B<--mode>
  
  Define the mode in which you want the plugin to be executed (see --list-mode).
  
  =item B<--dyn-mode>
  
  Specify a mode with the module's path (advanced).
  
  =item B<--list-mode>
  
  List all available modes.
  
  =item B<--mode-version>
  
  Check minimal version of mode. If not, unknown error.
  
  =item B<--version>
  
  Return the version of the plugin.
  
  =item B<--pass-manager>
  
  Define the password manager you want to use.
  Supported managers are: environment, file, keepass, hashicorpvault and teampass.
  
  =back
  
  =head1 DESCRIPTION
  
  B<>.
  
  =cut
CENTREON_PLUGINS_SCRIPT_SNMP

$fatpacked{"centreon/plugins/snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SNMP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use SNMP;
  use Socket;
  use POSIX;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{options} = options object
      # $options{output} = output object
      # $options{exit_value} = integer
  
      if (!defined($options{output})) {
          print "Class SNMP: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class SNMP: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      if (!defined($options{noptions})) {
          $options{options}->add_options(arguments => {
              'hostname|host:s'    => { name => 'host' },
              'snmp-community:s'   => { name => 'snmp_community', default => 'public' },
              'snmp-version:s'     => { name => 'snmp_version', default => 1 },
              'snmp-port:s'        => { name => 'snmp_port', default => 161 },
              'snmp-timeout:s'     => { name => 'snmp_timeout', default => 1 },
              'snmp-retries:s'     => { name => 'snmp_retries', default => 5 },
              'maxrepetitions:s'   => { name => 'maxrepetitions', default => 50 },
              'subsetleef:s'       => { name => 'subsetleef', default => 50 },
              'subsettable:s'      => { name => 'subsettable', default => 100 },
              'snmp-cache-file:s'  => { name => 'snmp_cache_file' },
              'snmp-autoreduce:s'  => { name => 'snmp_autoreduce' },
              'snmp-force-getnext' => { name => 'snmp_force_getnext' },
              'snmp-username:s'    => { name => 'snmp_security_name' },
              'authpassphrase:s'   => { name => 'snmp_auth_passphrase' },
              'authprotocol:s'     => { name => 'snmp_auth_protocol' },
              'privpassphrase:s'   => { name => 'snmp_priv_passphrase' },
              'privprotocol:s'     => { name => 'snmp_priv_protocol' },
              'contextname:s'      => { name => 'snmp_context_name' },
              'contextengineid:s'  => { name => 'snmp_context_engine_id' },
              'securityengineid:s' => { name => 'snmp_security_engine_id' },
              'snmp-tls-transport:s'      => { name => 'snmp_tls_transport' },
              'snmp-tls-our-identity:s'   => { name => 'snmp_tls_our_identity' },
              'snmp-tls-their-identity:s' => { name => 'snmp_tls_their_identity' },
              'snmp-tls-their-hostname:s' => { name => 'snmp_tls_their_hostname' },
              'snmp-tls-trust-cert:s    ' => { name => 'snmp_tls_trust_cert' },
              'snmp-errors-exit:s'        => { name => 'snmp_errors_exit', default => 'unknown' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'SNMP OPTIONS');
      }
  
      #####
      $self->{session} = undef;
      $self->{output} = $options{output};
      $self->{snmp_params} = {};
  
      $self->{use_snmp_cache} = 0;
  
      # Dont load MIB
      $SNMP::auto_init_mib = 0;
      $ENV{MIBS} = '';
      # For snmpv v1 - get request retries when you have "NoSuchName"
      $self->{RetryNoSuch} = 1;
      # Dont try to translate OID (we keep value)
      $self->{UseNumeric} = 1;
  
      $self->{error_msg} = undef;
      $self->{error_status} = 0;
  
      return $self;
  }
  
  sub connect {
      my ($self, %options) = @_;
  
      $self->{snmp_params}->{RetryNoSuch} = $self->{RetryNoSuch};
      $self->{snmp_params}->{UseNumeric} = $self->{UseNumeric};
  
      if (!$self->{output}->is_litteral_status(status => $self->{snmp_errors_exit})) {
          $self->{output}->add_option_msg(short_msg => "Unknown value '" . $self->{snmp_errors_exit}  . "' for --snmp-errors-exit.");
          $self->{output}->option_exit(exit_litteral => 'unknown');
      }
  
      $self->{session} = new SNMP::Session(%{$self->{snmp_params}});
      if (!defined($self->{session})) {
          if (defined($options{dont_quit}) && $options{dont_quit} == 1) {
              $self->set_error(error_status => -1, error_msg => 'SNMP Session: unable to create');
              return 1;
          }
          $self->{output}->add_option_msg(short_msg => 'SNMP Session: unable to create');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      if ($self->{session}->{ErrorNum}) {
          if (defined($options{dont_quit}) && $options{dont_quit} == 1) {
              $self->set_error(error_status => -1, error_msg => 'SNMP Session: ' . $self->{session}->{ErrorStr});
              return 1;
          }
          $self->{output}->add_option_msg(short_msg => 'SNMP Session: ' . $self->{session}->{ErrorStr});
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return 0;
  }
  
  sub load {
      my ($self, %options) = @_;
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      # $options{instances} = ref to array of oids instances
      # $options{begin}, $args->{end} = integer instance end
      # $options{instance_regexp} = str
      # 3 way to use: with instances, with end, none
      
      if (defined($options{end})) {
          for (my $i = $options{begin}; $i <= $options{end}; $i++) {
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $i;
              }
          }
          return ;
      }
      
      if (defined($options{instances})) {
          $options{instance_regexp} = defined($options{instance_regexp}) ? $options{instance_regexp} : '(\d+)$';
          foreach my $instance (@{$options{instances}}) {
              $instance =~ /$options{instance_regexp}/;
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $1;
              }
          }
          return ;
      }
      
      push @{$self->{oids_loaded}}, @{$options{oids}};
  }
  
  sub autoreduce_table {
      my ($self, %options) = @_;
      
      return 1 if (defined($self->{snmp_force_getnext}) || $self->is_snmpv1());
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if (${$options{repeat_count}} == 1);
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_multiple_table {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      return 1 if (${$options{repeat_count}} == 1);
      
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      $self->{subsettable} = int($self->{subsettable} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_leef {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if ($self->{subsetleef} == 1);
      $self->{subsetleef} = int($self->{subsetleef} / $self->{snmp_autoreduce_divisor});
      $self->{subsetleef} = 1 if ($self->{subsetleef} < 1);
      
      my $array_ref = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach ([@{$options{current}}], @{$self->{array_ref_ar}}) {
          foreach my $entry (@$_) {;
              push @$subset_construct, [$entry->[0], $entry->[1]];
              $subset_current++;
              if ($subset_current == $self->{subsetleef}) {
                  push @$array_ref, \@$subset_construct;
                  $subset_construct = [];
                  $subset_current = 0;
              }
          }
      }
      
      if ($subset_current) {
          push @$array_ref, \@$subset_construct;
      }
  
      $self->{array_ref_ar} = \@$array_ref;
      return 0;
  }
  
  sub get_leef_cache {
      my ($self, %options) = @_;
  
      my $results = {};
      foreach my $oid (@{$options{oids}}) {
          if (defined($self->{snmp_cache}->{$oid})) {
              $results->{$oid} = $self->{snmp_cache}->{$oid};
          }
      }
  
      if ($options{nothing_quit} == 1 && scalar(keys %$results) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP GET Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return $results;
  }
  
  sub get_leef {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{nothing_quit} = integer
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
  
      # Returns array
      #    'undef' value for an OID means NoSuchValue
  
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if (!defined($options{oids})) {
          if ($#{$self->{oids_loaded}} < 0) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Need to specify OIDs");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => 'Need to specify OIDs');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          push @{$options{oids}}, @{$self->{oids_loaded}};
          @{$self->{oids_loaded}} = ();
      }
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_leef_cache(oids => $options{oids}, nothing_quit => $nothing_quit);
      }
  
      my $results = {};
      $self->{array_ref_ar} = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach my $oid (@{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my ($oid, $instance) = ($1, $2);
          $results->{$oid . "." . $instance} = undef;
          push @$subset_construct, [$oid, $instance];
          $subset_current++;
          if ($subset_current == $self->{subsetleef}) {
              push @{$self->{array_ref_ar}}, \@$subset_construct;
              $subset_construct = [];
              $subset_current = 0;
          }
      }
      if ($subset_current) {
          push @{$self->{array_ref_ar}}, \@$subset_construct;
      }
  
      ############################
      # If wrong oid with SNMP v1, packet resent (2 packets more). Not the case with SNMP > 1.
      # Can have "NoSuchName", if nothing works...
      # = v1: wrong oid
      #   bless( [
      #       '.1.3.6.1.2.1.1.3',
      #       '0',
      #       '199720062',
      #       'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1.999',
      #       '0'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1',
      #       '1000'
      #       ], 'SNMP::Varbind' )
      # > v1: wrong oid
      #   bless( [
      #        '.1.3.6.1.2.1.1.3',
      #        '0',
      #        '199728713',
      #        'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #         '.1.3.6.1.2.1.1',
      #         '3',
      #         'NOSUCHINSTANCE',
      #        'TICKS'
      #    ], 'SNMP::Varbind' )
      #   bless( [
      #        '.1.3.6.1.2.1.1.999',
      #        '0',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #        '.1.3.6.1.2.1.1',
      #        '1000',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' )
      ############################
  
      my $total = 0;
      while (my $entry = shift(@{$self->{array_ref_ar}})) {
          my $vb = new SNMP::VarList(@{$entry});
          $self->{session}->get($vb);
  
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We next.
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_leef(current => $entry) == 0);
              }
              my $msg = 'SNMP GET Request: ' . $self->{session}->{ErrorStr};    
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Some equipments gives a partial response and no error.
          # We look the last value if it's empty or not
          # In snmpv1 we have the retryNoSuch
          if (((scalar(@$vb) != scalar(@{$entry})) || (scalar(@{@$vb[-1]}) < 3)) && !$self->is_snmpv1()) {
              next if ($self->{snmp_autoreduce} == 1 && $self->autoreduce_leef(current => $entry) == 0);
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => 'SNMP partial response. Please try --snmp-autoreduce option');
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => 'SNMP partial response');
              return undef;
          }
  
          foreach my $entry (@$vb) {
              if ($#$entry < 3) {
                  # Can be snmpv1 not find
                  next;
              }
              if (${$entry}[2] eq 'NOSUCHOBJECT' || ${$entry}[2] eq 'NOSUCHINSTANCE') {
                  # Error in snmp > 1
                  next;
              }
  
              $total++;
              $results->{${$entry}[0] . "." . ${$entry}[1]} = ${$entry}[2];
          }
      }
  
      if ($nothing_quit == 1 && $total == 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP GET Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub multiple_find_bigger {
      my ($self, %options) = @_;
      
      my $getting = {};
      my @values = ();
      foreach my $key (keys %{$options{working_oids}}) {
          push @values, $options{working_oids}->{$key}->{start};
          $getting->{ $options{working_oids}->{$key}->{start} } = $key;
      }
      @values = $self->oid_lex_sort(@values);
      
      return $getting->{pop(@values)};
  }
  
  sub get_multiple_table_cache {
      my ($self, %options) = @_;
  
      my $results = {};
      foreach my $entry (@{$options{oids}}) {
          my $result = $self->get_table_cache(
              oid => $entry->{oid},
              start => $entry->{start},
              end => $entry->{end},
              nothing_quit => 0
          );
          if ($options{return_type} == 0) {
              $results->{ $entry->{oid} } = $result;
          } else {
              $results = { %$results, %$result };
          }
      }
  
      my $total = 0;
      if ($options{nothing_quit} == 1) {
          if ($options{return_type} == 1) {
              $total = scalar(keys %$results);
          } else {
              foreach (keys %$results) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
  
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      return $results;
  }
  
  sub get_multiple_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = refs array
      #     [ { oid => 'x.x.x.x', start => '', end => ''}, { oid => 'y.y.y.y', start => '', end => ''} ]
      # $options{return_type} = integer
  
      my ($return_type) = (defined($options{return_type}) && $options{return_type} == 1) ? 1 : 0;
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_multiple_table_cache(
              oids => $options{oids},
              return_type => $return_type,
              nothing_quit => $nothing_quit
          );
      }
  
      my $working_oids = {};
      my $results = {};
      # Check overlap
      foreach my $entry (@{$options{oids}}) {
          # Transform asking
          if ($entry->{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
  
          if (defined($entry->{start})) {
              $working_oids->{$entry->{oid}} = { start => $entry->{start}, end => $entry->{end} }; # last in it
          } else {
              $working_oids->{$entry->{oid}} = { start => $entry->{oid}, end => $entry->{end} };
          }
  
          if ($return_type == 0) {
              $results->{ $entry->{oid} } = {};
          }
      }
  
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
  
      # Quit if base not the same or 'ENDOFMIBVIEW' value. Need all oid finish otherwise we continue :)
      while (1) {
          my $current_oids = 0;
          my @bindings = ();
          my @bases = ();
          foreach my $key (keys %{$working_oids}) {
              $working_oids->{$key}->{start} =~ /(.*)\.(\d+)([\.\s]*)$/;
              push @bindings, [$1, $2];
              push @bases, $key;
  
              $current_oids++;
              last if ($current_oids > $self->{subsettable});
          }
  
          # Nothing more to check. We quit
          last if ($current_oids == 0);
  
          my $vb = new SNMP::VarList(@bindings);
  
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              my $current_repeat_count = floor($repeat_count / $current_oids);
              $current_repeat_count = 1 if ($current_repeat_count == 0);
              $self->{session}->getbulk(0, $current_repeat_count, $vb);
          }
  
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. Need to find the most up oid ;)
                  my $oid_base = $self->multiple_find_bigger(working_oids => $working_oids);
                  delete $working_oids->{$oid_base};
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_multiple_table(repeat_count => \$repeat_count) == 0);
              }
  
              my $msg = 'SNMP Table Request: ' . $self->{session}->{ErrorStr};
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Manage
          # step by step: [ 1 => 1, 2 => 1, 3 => 1 ], [ 1 => 2, 2 => 2, 3 => 2 ],...
  
          my $pos = -1;
          foreach my $entry (@$vb) {
              $pos++;
  
              # Already destruct. we continue
              next if (!defined($working_oids->{ $bases[$pos % $current_oids] }));
  
              # ENDOFMIBVIEW is on each iteration. So we need to delete and skip after that
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  # END mib
                  next;
              }
  
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              my $base = $bases[$pos % $current_oids];
              if ($complete_oid !~ /^$base\./ ||
                  (defined($working_oids->{ $bases[$pos % $current_oids] }->{end}) && 
                   $self->check_oid_up(current => $complete_oid, end => $working_oids->{ $bases[$pos % $current_oids] }->{end}))) {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  next;
              }
  
              if ($return_type == 0) {
                  $results->{$bases[$pos % $current_oids]}->{$complete_oid} = ${$entry}[2];
              } else {
                  $results->{$complete_oid} = ${$entry}[2];
              }
  
              $working_oids->{ $bases[$pos % $current_oids] }->{start} = $complete_oid;
          }
  
          # infinite loop. Some equipments it returns nothing!!??
          if ($pos == -1) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: problem to get values (try --snmp-force-getnext option)');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      my $total = 0;
      if ($nothing_quit == 1) {
          if ($return_type == 1) {
              $total = scalar(keys %{$results});
          } else {
              foreach (keys %{$results}) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
  
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub get_table_cache {
      my ($self, %options) = @_;
  
      my $branch = defined($options{start}) ? $options{start} : $options{oid};
  
      my $results = {};
      foreach my $oid ($self->oid_lex_sort(keys %{$self->{snmp_cache}})) {
          if ($oid =~ /^$branch\./) {
              $results->{$oid} = $self->{snmp_cache}->{$oid};
              if (defined($options{end}) && $self->check_oid_up(current => $oid, end => $options{end})) {
                  last;
              } 
          }
      }
  
      if ($options{nothing_quit} == 1 && scalar(keys %$results) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return $results;
  }
  
  sub get_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oid} = string (example: '.1.2')
      # $options{start} = string (example: '.1.2')
      # $options{end} = string (example: '.1.2')
  
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if (defined($options{start})) {
          $options{start} = $self->clean_oid($options{start});
      }
      if (defined($options{end})) {
          $options{end} = $self->clean_oid($options{end});
      }
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_table_cache(
              oid => $options{oid},
              start => $options{start},
              end => $options{end},
              nothing_quit => $nothing_quit
          );
      }
  
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
  
      # Transform asking
      if ($options{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
          if ($dont_quit == 1) {
              $self->set_error(error_status => -1, error_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
              return undef;
          }
          $self->{output}->add_option_msg(short_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      my $main_indice = $1 . '.' . $2;
      my $results = {};
  
      # Quit if base not the same or 'ENDOFMIBVIEW' value
      my $leave = 1;
      my $last_oid;
  
      if (defined($options{start})) {
          $last_oid = $options{start};
      } else {
          $last_oid = $options{oid};
      }
      while ($leave) {
          $last_oid =~ /(.*)\.(\d+)([\.\s]*)$/;
          my $vb = new SNMP::VarList([$1, $2]);
  
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              $self->{session}->getbulk(0, $repeat_count, $vb);
          }
  
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We quit.
                  last;
              }
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_table(repeat_count => \$repeat_count) == 0);
              }
  
              my $msg = 'SNMP Table Request: ' . $self->{session}->{ErrorStr};
  
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Manage
          foreach my $entry (@$vb) {
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  # END mib
                  $leave = 0;
                  last;
              }
  
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              if ($complete_oid !~ /^$main_indice\./ ||
                  (defined($options{end}) && $self->check_oid_up(current => $complete_oid, end => $options{end}))) {
                  $leave = 0;
                  last;
              }
  
              $results->{$complete_oid} = ${$entry}[2];
              $last_oid = $complete_oid;
          }
      }
  
      if ($nothing_quit == 1 && scalar(keys %$results) == 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub set {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = ref to hash table
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      my $vars = [];
      foreach my $oid (keys %{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
  
          my $value = $options{oids}->{$oid}->{value};
          my $type = $options{oids}->{$oid}->{type};
          my ($oid, $instance) = ($1, $2);
  
          push @$vars, [$oid, $instance, $value, $type];
      }
  
      $self->{session}->set($vars);
      if ($self->{session}->{ErrorNum}) {
          # 0    noError       Pas d'erreurs.
          # 1    tooBig        Reponse de taille trop grande.
          # 2    noSuchName    Variable inexistante.
  
          my $msg = 'SNMP SET Request: ' . $self->{session}->{ErrorStr};
          if ($dont_quit == 0) {
              $self->{output}->add_option_msg(short_msg => $msg);
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
  
          $self->set_error(error_status => -1, error_msg => $msg);
          return undef;
      }
  
      return 0;
  }
  
  sub is_snmpv1 {
      my ($self) = @_;
  
      if ($self->{snmp_params}->{Version} eq '1') {
          return 1;
      }
      return 0;
  }
  
  sub clean_oid {
      my ($self, $oid) = @_;
  
      $oid =~ s/\.$//;
      $oid =~ s/^(\d)/\.$1/;
      return $oid;
  }
  
  sub check_oid_up {
      my ($self, %options) = @_;
  
      my $current_oid = $options{current};
      my $end_oid = $options{end};
  
      my @current_oid_splitted = split /\./, $current_oid;
      my @end_oid_splitted = split /\./, $end_oid;
      # Skip first value (before first '.' empty)
      for (my $i = 1; $i <= $#current_oid_splitted && $i <= $#end_oid_splitted; $i++) {
          if (int($current_oid_splitted[$i]) > int($end_oid_splitted[$i])) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      $self->{snmp_errors_exit} = $options{option_results}->{snmp_errors_exit};
  
      if (defined($options{option_results}->{snmp_cache_file}) && $options{option_results}->{snmp_cache_file} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'JSON::XS',
              error_msg => "Cannot load module 'JSON::XS'."
          );
          my $content = centreon::plugins::misc::slurp_file(output => $self->{output}, file => $options{option_results}->{snmp_cache_file});
          eval {
              $self->{snmp_cache} = JSON::XS->new->decode($content);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode json cache file: $@");
              $self->{output}->option_exit();
          }
  
          $self->{use_snmp_cache} = 1;
          return ;
      }
  
      if (!defined($options{option_results}->{host})) {
          $self->{output}->add_option_msg(short_msg => 'Missing parameter --hostname.');
          $self->{output}->option_exit();
      }
  
      $options{option_results}->{snmp_version} =~ s/^v//;
      if ($options{option_results}->{snmp_version} !~ /1|2c|2|3/) {
          $self->{output}->add_option_msg(short_msg => 'Unknown snmp version.');
          $self->{output}->option_exit();
      }
  
      $self->{snmp_force_getnext} = $options{option_results}->{snmp_force_getnext};
      $self->{maxrepetitions} = $options{option_results}->{maxrepetitions};
      $self->{subsetleef} = (defined($options{option_results}->{subsetleef}) && $options{option_results}->{subsetleef} =~ /^[0-9]+$/) ? $options{option_results}->{subsetleef} : 50;
      $self->{subsettable} = (defined($options{option_results}->{subsettable}) && $options{option_results}->{subsettable} =~ /^[0-9]+$/) ? $options{option_results}->{subsettable} : 100;
      $self->{snmp_autoreduce} = 0;
      $self->{snmp_autoreduce_divisor} = 2;
      if (defined($options{option_results}->{snmp_autoreduce})) {
          $self->{snmp_autoreduce} = 1;
          $self->{snmp_autoreduce_divisor} = $1 if ($options{option_results}->{snmp_autoreduce} =~ /(\d+(\.\d+)?)/ && $1 > 1);
      }
  
      %{$self->{snmp_params}} = (
          DestHost => $options{option_results}->{host},
          Community => $options{option_results}->{snmp_community},
          Version => $options{option_results}->{snmp_version},
          RemotePort => $options{option_results}->{snmp_port},
          Retries => 5
      );
  
      if (defined($options{option_results}->{snmp_timeout}) && $options{option_results}->{snmp_timeout} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Timeout} = $options{option_results}->{snmp_timeout} * (10**6);
      }
  
      if (defined($options{option_results}->{snmp_retries}) && $options{option_results}->{snmp_retries} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Retries} = $options{option_results}->{snmp_retries};
      }
  
      if ($options{option_results}->{snmp_version} eq '3') {
          delete $self->{snmp_params}->{Community};
  
          $self->{snmp_params}->{Context} = $options{option_results}->{snmp_context_name} if (defined($options{option_results}->{snmp_context_name}));
          $self->{snmp_params}->{ContextEngineId} = $options{option_results}->{snmp_context_engine_id} if (defined($options{option_results}->{snmp_context_engine_id}));
          $self->{snmp_params}->{SecEngineId} = $options{option_results}->{snmp_security_engine_id} if (defined($options{option_results}->{snmp_security_engine_id}));
          $self->{snmp_params}->{SecName} = $options{option_results}->{snmp_security_name} if (defined($options{option_results}->{snmp_security_name}));
  
          # Certificate SNMPv3. Need net-snmp > 5.6
          if (defined($options{option_results}->{snmp_tls_transport}) && $options{option_results}->{snmp_tls_transport} =~ /^dtlsudp|tlstcp$/) {
              $self->{snmp_params}->{DestHost} = $options{option_results}->{snmp_tls_transport} . ':' . $options{option_results}->{host};
              $self->{snmp_params}->{OurIdentity} = $options{option_results}->{snmp_tls_our_identity} if (defined($options{option_results}->{snmp_tls_our_identity}));
              $self->{snmp_params}->{TheirIdentity} = $options{option_results}->{snmp_tls_their_identity} if (defined($options{option_results}->{snmp_tls_their_identity}));
              $self->{snmp_params}->{TheirHostname} = $options{option_results}->{snmp_tls_their_hostname} if (defined($options{option_results}->{snmp_tls_their_hostname}));
              $self->{snmp_params}->{TrustCert} = $options{option_results}->{snmp_tls_trust_cert} if (defined($options{option_results}->{snmp_tls_trust_cert}));
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              return ;
          }
  
          if (!defined($options{option_results}->{snmp_security_name}) || $options{option_results}->{snmp_security_name} eq '') {
              $self->{output}->add_option_msg(short_msg => 'Missing parameter Security Name.');
              $self->{output}->option_exit();
          }
  
          # unauthenticated and unencrypted
          $self->{snmp_params}->{SecLevel} = 'noAuthNoPriv';
  
          my $user_activate = 0;
          if (defined($options{option_results}->{snmp_auth_passphrase}) && $options{option_results}->{snmp_auth_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_auth_protocol})) {
                  $self->{output}->add_option_msg(short_msg => 'Missing parameter authenticate protocol.');
                  $self->{output}->option_exit();
              }
              $options{option_results}->{snmp_auth_protocol} = uc($options{option_results}->{snmp_auth_protocol});
              if ($options{option_results}->{snmp_auth_protocol} !~ /^(?:MD5|SHA|SHA224|SHA256|SHA384|SHA512)$/) {
                  $self->{output}->add_option_msg(short_msg => 'Wrong authentication protocol.');
                  $self->{output}->option_exit();
              }
  
              $self->{snmp_params}->{SecLevel} = 'authNoPriv';
              $self->{snmp_params}->{AuthProto} = $options{option_results}->{snmp_auth_protocol};
              $self->{snmp_params}->{AuthPass} = $options{option_results}->{snmp_auth_passphrase};
              $user_activate = 1;
          }
  
          if (defined($options{option_results}->{snmp_priv_passphrase}) && $options{option_results}->{snmp_priv_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_priv_protocol})) {
                  $self->{output}->add_option_msg(short_msg => 'Missing parameter privacy protocol.');
                  $self->{output}->option_exit();
              }
  
              $options{option_results}->{snmp_priv_protocol} = uc($options{option_results}->{snmp_priv_protocol});
              if ($options{option_results}->{snmp_priv_protocol} !~ /^(?:DES|AES|AES192|AES192C|AES256|AES256C)$/) {
                  $self->{output}->add_option_msg(short_msg => 'Wrong privacy protocol.');
                  $self->{output}->option_exit();
              }
              if ($user_activate == 0) {
                  $self->{output}->add_option_msg(short_msg => 'Cannot use snmp v3 privacy option without snmp v3 authentification options.');
                  $self->{output}->option_exit();
              }
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              $self->{snmp_params}->{PrivPass} = $options{option_results}->{snmp_priv_passphrase};
              $self->{snmp_params}->{PrivProto} = $options{option_results}->{snmp_priv_protocol};
          }
      }
  }
  
  sub set_snmp_connect_params {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{snmp_params}->{$_} = $options{$_};
      }
  }
  
  sub set_snmp_params {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub set_error {
      my ($self, %options) = @_;
      # $options{error_msg} = string error
      # $options{error_status} = integer status
  
      $self->{error_status} = defined($options{error_status}) ? $options{error_status} : 0;
      $self->{error_msg} = defined($options{error_msg}) ? $options{error_msg} : undef;
  }
  
  sub error_status {
      my ($self) = @_;
  
      return $self->{error_status};
  }
  
  sub error {
      my ($self) = @_;
  
      return $self->{error_msg};
  }
  
  sub get_hostname {
      my ($self) = @_;
  
      my $host = $self->{snmp_params}->{DestHost};
      $host =~ s/.*://;
      return $host;
  }
  
  sub get_port {
      my ($self) = @_;
  
      return $self->{snmp_params}->{RemotePort};
  }
  
  sub map_instance {
      my ($self, %options) = @_;
  
      my $results = {};
      my $instance = '';
      $instance = '.' . $options{instance} if (defined($options{instance}));
      foreach my $name (keys %{$options{mapping}}) {
          my $entry = $options{mapping}->{$name}->{oid} . $instance;
          if (defined($options{results}->{$entry})) {
              $results->{$name} = $options{results}->{$entry};
          } elsif (defined($options{results}->{$options{mapping}->{$name}->{oid}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{oid}}->{$entry};
          } else {
              $results->{$name} = defined($options{default}) ? $options{default} : undef;
          }
  
          if (defined($options{mapping}->{$name}->{map})) {
              if (defined($results->{$name})) {
                  $results->{$name} = defined($options{mapping}->{$name}->{map}->{$results->{$name}}) ? $options{mapping}->{$name}->{map}->{$results->{$name}} : (defined($options{default}) ? $options{default} : 'unknown');
              }
          }
      }
  
      return $results;
  }
  
  sub debug {
      my ($self, %options) = @_;
  
      foreach my $oid1 ($self->oid_lex_sort(keys %{$options{results}})) {
          if (ref($options{results}->{$oid1}) eq 'HASH') {
              foreach my $oid2 ($self->oid_lex_sort(keys %{$options{results}->{$oid1}})) {
                  $self->{output}->output_add(long_msg => $oid2 . ' = ' . (defined($options{results}->{$oid1}->{$oid2}) ? $options{results}->{$oid1}->{$oid2} : 'undef'), debug => 1);
              }
          } else {
              $self->{output}->output_add(long_msg => $oid1 . ' = ' . (defined($options{results}->{$oid1}) ? $options{results}->{$oid1} : 'undef'), debug => 1);
          }
      }
  }
  
  sub oid_lex_sort {
      my $self = shift;
  
      if (@_ <= 1) {
          return @_;
      }
  
      return map { $_->[0] }
          sort { $a->[1] cmp $b->[1] }
          map {
             my $oid = $_;
             $oid =~ s/^\.//;
             $oid =~ s/ /\.0/g;
             [$_, pack 'N*', split m/\./, $oid]
          } @_;
  }
  
  1;
  
  
  =head1 NAME
  
  SNMP global
  
  =head1 SYNOPSIS
  
  snmp class
  
  =head1 SNMP OPTIONS
  
  =over 8
  
  =item B<--hostname>
  
  Name or address of the host to monitor (mandatory).
  
  =item B<--snmp-community>
  
  SNMP community (default value: public). It is recommended to use a read-only
  community.
  
  =item B<--snmp-version>
  
  Version of the SNMP protocol. 1 for SNMP v1 (default), 2 for SNMP v2c, 3 for SNMP v3.
  
  =item B<--snmp-port>
  
  UDP port to send the SNMP request to (default: 161).
  
  =item B<--snmp-timeout>
  
  Time to wait before sending the request again if no reply has been received,
  in seconds (default: 1). See also --snmp-retries.
  
  =item B<--snmp-retries>
  
  Maximum number of retries (default: 5).
  
  =item B<--maxrepetitions>
  
  Max repetitions value (default: 50) (only for SNMP v2 and v3).
  
  =item B<--subsetleef>
  
  How many OID values per SNMP request (default: 50) (for get_leef method. Be cautious when you set it. Prefer to let the default value).
  
  =item B<--snmp-autoreduce>
   
  Progressively reduce the number of requested OIDs in bulk mode. Use it in case of
  SNMP errors (by default, the number is divided by 2).
  
  =item B<--snmp-force-getnext>
  
  Use SNMP getnext function in SNMP v2c and v3. This will request one OID at a
  time.
  
  =item B<--snmp-cache-file>
  
  Use SNMP cache file.
  
  =item B<--snmp-username>
  
  SNMP v3 only:
  User name (securityName). 
  
  =item B<--authpassphrase>
  
  SNMP v3 only:
  Pass phrase hashed using the authentication protocol defined in the 
  --authprotocol option.
  
  =item B<--authprotocol>
  
  SNMP v3 only:
  Authentication protocol: MD5|SHA. Since net-snmp 5.9.1: SHA224|SHA256|SHA384|SHA512.
  
  =item B<--privpassphrase>
  
  SNMP v3 only:
  Privacy pass phrase (privPassword) to encrypt messages using the protocol
  defined in the --privprotocol option.
  
  =item B<--privprotocol>
  
  SNMP v3 only:
  Privacy protocol (privProtocol) used to encrypt messages.
  Supported protocols are: DES|AES and since net-snmp 5.9.1: AES192|AES192C|AES256|AES256C.
  
  =item B<--contextname>
  
  SNMP v3 only:
  Context name (contextName), if relevant for the monitored host.
  
  =item B<--contextengineid>
  
  SNMP v3 only:
  Context engine ID (contextEngineID), if relevant for the monitored host, given 
  as a hexadecimal string.
  
  =item B<--securityengineid>
  
  SNMP v3 only:
  Security engine ID, given as a hexadecimal string.
  
  =item B<--snmp-errors-exit>
  
  Expected status in case of SNMP error or timeout.
  Possible values are warning, critical and unknown (default).
  
  =item B<--snmp-tls-transport>
  
  Transport protocol for TLS communication (can be: 'dtlsudp', 'tlstcp').
  
  =item B<--snmp-tls-our-identity>
  
  X.509 certificate to identify ourselves. Can be the path to the certificate file
  or its contents.
  
  =item B<--snmp-tls-their-identity>
  
  X.509 certificate to identify the remote host. Can be the path to the 
  certificate file or its contents. This option is unnecessary if the certificate
  is already trusted by your system.
  
  =item B<--snmp-tls-their-hostname>
  
  Common Name (CN) expected in the certificate sent by the host if it differs from
  the value of the --hostname parameter.
  
  =item B<--snmp-tls-trust-cert>
  
  A trusted CA certificate used to verify a remote host's certificate. 
  If you use this option, you must also  define --snmp-tls-their-hostname.
  
  =back
  
  =head1 DESCRIPTION
  
  B<snmp>.
  
  =cut
CENTREON_PLUGINS_SNMP

$fatpacked{"centreon/plugins/statefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_STATEFILE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::statefile;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::misc;
  
  my $default_dir = '/var/lib/centreon/centplugins';
  if ($^O eq 'MSWin32') {
      $default_dir = 'C:/Windows/Temp';
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (defined($options{options})) {
          $options{options}->add_options(arguments => {
              'memcached:s'          => { name => 'memcached' },
              'redis-server:s'       => { name => 'redis_server' },
              'redis-attribute:s%'   => { name => 'redis_attribute' },
              'redis-db:s'           => { name => 'redis_db' },
              'memexpiration:s'      => { name => 'memexpiration', default => 86400 },
              'statefile-dir:s'      => { name => 'statefile_dir', default => $default_dir },
              'statefile-suffix:s'   => { name => 'statefile_suffix', default => '' },
              'statefile-concat-cwd' => { name => 'statefile_concat_cwd' },
              'statefile-storable'   => { name => 'statefile_storable' }, # legacy
              'failback-file'        => { name => 'failback_file' },
              'statefile-format:s'   => { name => 'statefile_format' },
              'statefile-key:s'      => { name => 'statefile_key' },
              'statefile-cipher:s'   => { name => 'statefile_cipher' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'RETENTION OPTIONS', once => 1);
      }
  
      $self->{error} = 0;
      $self->{output} = $options{output};
      $self->{datas} = {};
      $self->{storable} = 0;
      $self->{memcached_ok} = 0;
      $self->{memcached} = undef;
  
      $self->{statefile_dir} = undef;
      $self->{statefile_suffix} = undef;
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}) && defined($options{option_results}->{memcached})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Memcached::libmemcached',
              error_msg => "Cannot load module 'Memcached::libmemcached'."
          );
          $self->{memcached} = Memcached::libmemcached->new();
          Memcached::libmemcached::memcached_server_add($self->{memcached}, $options{option_results}->{memcached});
      }
  
      # Check redis
      if (defined($options{option_results}->{redis_server})) {
          $self->{redis_attributes} = '';
          if (defined($options{option_results}->{redis_attribute})) {
              foreach (keys %{$options{option_results}->{redis_attribute}}) {
                  $self->{redis_attributes} .= "$_ => " . $options{option_results}->{redis_attribute}->{$_} . ', ';
              }
          }
  
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Redis',
              error_msg => "Cannot load module 'Redis'."
          );
          eval {
              $options{option_results}->{redis_server} .= ':6379' if ($options{option_results}->{redis_server} !~ /:\d+$/);
              $self->{redis_cnx} = Redis->new(
                  server => $options{option_results}->{redis_server}, 
                  eval $self->{redis_attributes}
              );
              if (defined($self->{redis_cnx}) && 
                  defined($options{option_results}->{redis_db}) &&
                  $options{option_results}->{redis_db} ne ''
                  ) {
                  $self->{redis_cnx}->select($options{option_results}->{redis_db});
              }
          };
          if (!defined($self->{redis_cnx}) && !defined($options{option_results}->{failback_file})) {
              $self->{output}->add_option_msg(short_msg => "redis connection issue: $@");
              $self->{output}->option_exit();
          }
      }
  
      $self->{statefile_format} = 'json';
      if (defined($options{option_results}->{statefile_format}) && $options{option_results}->{statefile_format} ne '' && 
          $options{option_results}->{statefile_format} =~ /^(?:dumper|json|storable)$/) {
          $self->{statefile_format} = $options{option_results}->{statefile_format};
      } elsif (defined($options{default_format}) && $options{default_format} =~ /^(?:dumper|json|storable)$/) {
          $self->{statefile_format} = $options{default_format};
      }
  
      if (defined($options{option_results}->{statefile_storable})) {
          $self->{statefile_format} = 'storable';
      }
  
      if ($self->{statefile_format} eq 'dumper') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'Safe', 
              no_quit => 1
          );
          $self->{safe} = Safe->new();
          $self->{safe}->share('$datas');
      } elsif ($self->{statefile_format} eq 'storable') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Storable',
              error_msg => "Cannot load module 'Storable'."
          );
      } elsif ($self->{statefile_format} eq 'json') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'JSON::XS',
              error_msg => "Cannot load module 'JSON::XS'."
          );
      }
  
      $self->{statefile_cipher} = defined($options{option_results}->{statefile_cipher}) && $options{option_results}->{statefile_cipher} ne '' ?    
          $options{option_results}->{statefile_cipher} : 'AES';
      $self->{statefile_key} = defined($options{option_results}->{statefile_key}) && $options{option_results}->{statefile_key} ne '' ?    
          $options{option_results}->{statefile_key} : '';
  
      if ($self->{statefile_key} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Crypt::Mode::CBC',
              error_msg => "Cannot load module 'Crypt::Mode::CBC'."
          );
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Crypt::PRNG',
              error_msg => "Cannot load module 'Crypt::PRNG'."
          );
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'MIME::Base64',
              error_msg => "Cannot load module 'MIME::Base64'."
          );
      }
  
      $self->{statefile_dir} = $options{option_results}->{statefile_dir};
      if (defined($self->{statefile_dir})
              && $self->{statefile_dir} ne $default_dir
              && defined($options{option_results}->{statefile_concat_cwd})
      ) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Cwd',
              error_msg => "Cannot load module 'Cwd'."
          );
          $self->{statefile_dir} = Cwd::cwd() . '/' . $self->{statefile_dir};
      }
  
      $self->{$_} = $options{option_results}->{$_} foreach qw/statefile_suffix memexpiration/;
  }
  
  sub error {
      my ($self) = shift;
  
      if (@_) {
          $self->{error} = $_[0];
      }
      return $self->{error};
  }
  
  sub get_key {
      my ($self, %options) = @_;
  
      my $key = $options{key};
  
      {
          use bytes;
  
          my $size = length($key);
          my $minsize = Crypt::Cipher->min_keysize($options{cipher});
          if ($minsize > $size) {
              $key .= "0" x ($minsize - $size);
          }
      }
  
      return $key;
  }
  
  sub decrypt {
      my ($self, %options) = @_;
  
      return (1, $options{data}) if (!defined($options{data}->{encrypted}));
  
      my $plaintext;
      eval {
          my $cipher = Crypt::Mode::CBC->new($options{data}->{cipher}, 1);
          $plaintext = $cipher->decrypt(
              MIME::Base64::decode_base64($options{data}->{ciphertext}),
              $self->get_key(key => $self->{statefile_key}, cipher => $options{data}->{cipher}),
              pack('H*', $options{data}->{iv})
          );
      };
  
      if ($@) {
          return 0;
      }
  
      return $self->deserialize(data => $plaintext, nocipher => 1);
  }
  
  sub deserialize {
      my ($self, %options) = @_;
  
      my $deserialized = '';
      if ($self->{statefile_format} eq 'dumper') {
          our $datas;
          $self->{safe}->reval($options{data}, 1);
          return 0 if ($@);
  
          $deserialized = $datas;
      } elsif ($self->{statefile_format} eq 'storable') {
          eval {
              $deserialized = Storable::thaw($options{data});
          };
          return 0 if ($@);
      } elsif ($self->{statefile_format} eq 'json') {
          eval {
              $deserialized = JSON::XS->new->decode($options{data});
          };
          return 0 if ($@);
      }
  
      return 0 if (!defined($deserialized) || ref($deserialized) ne 'HASH');
  
      my $rv = 1;
      if ($self->{statefile_key} ne '' && !defined($options{nocipher})) {
          ($rv, $deserialized) = $self->decrypt(data => $deserialized);
      }
  
      return ($rv, $deserialized);
  }
  
  sub slurp {
      my ($self, %options) = @_;
  
      my $content = do {
          local $/ = undef;
          if (!open my $fh, '<', $options{file}) {
              $self->{output}->add_option_msg(short_msg => "Could not open file $options{file}: $!");
              $self->{output}->option_exit();
          }
          <$fh>;
      };
  
      return $content;
  }
  
  sub read {
      my ($self, %options) = @_;
      $self->{statefile_suffix} = defined($options{statefile_suffix}) ? $options{statefile_suffix} : $self->{statefile_suffix};
      $self->{statefile_dir} = defined($options{statefile_dir}) ? $options{statefile_dir} : $self->{statefile_dir};
      $self->{statefile} = defined($options{statefile}) ? $options{statefile} . $self->{statefile_suffix} : $self->{statefile};
      $self->{no_quit} = defined($options{no_quit}) && $options{no_quit} == 1 ? 1 : 0;
  
      my ($data, $rv);
  
      if (defined($self->{memcached})) {
          # if "SUCCESS" or "NOT FOUND" is ok. Other with use the file
          my $val = Memcached::libmemcached::memcached_get($self->{memcached}, $self->{statefile_dir} . '/' . $self->{statefile});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS|NOT FOUND$/i) {
              $self->{memcached_ok} = 1;
              if (defined($val)) {
                  ($rv, $data) = $self->deserialize(data => $val);
                  $self->{datas} = defined($data) ? $data : {};
                  return $rv;
              }
  
              return 0;
          }
      }
  
      if (defined($self->{redis_cnx})) {
          my $val = $self->{redis_cnx}->get($self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($val)) {
              ($rv, $data) = $self->deserialize(data => $val);
              $self->{datas} = defined($data) ? $data : {};
              return $rv;
          }
  
          return 0;
      }
  
      if (! -e $self->{statefile_dir} . '/' . $self->{statefile}) {
          if (! -w $self->{statefile_dir} || ! -x $self->{statefile_dir}) {
              $self->error(1);
              $self->{output}->add_option_msg(short_msg =>  "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write/exec permissions on directory.");
              if ($self->{no_quit} == 0) {
                  $self->{output}->option_exit();
              }
          }
          return 0;
      } elsif (! -w $self->{statefile_dir} . '/' . $self->{statefile}) {
          $self->error(1);
          $self->{output}->add_option_msg(short_msg => "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write permissions on file.");
          if ($self->{no_quit} == 0) {
              $self->{output}->option_exit();
          }
          return 1;
      } elsif (! -s $self->{statefile_dir} . '/' . $self->{statefile}) {
          # Empty file. Not a problem. Maybe plugin not manage not values
          return 0;
      }
  
      $data = $self->slurp(file => $self->{statefile_dir} . '/' . $self->{statefile});
      ($rv, $data) = $self->deserialize(data => $data);
      $self->{datas} = defined($data) ? $data : {};
  
      return $rv;
  }
  
  sub get_string_content {
      my ($self, %options) = @_;
  
      return Data::Dumper::Dumper($self->{datas});
  }
  
  sub get {
      my ($self, %options) = @_;
  
      if (defined($self->{datas}->{ $options{name} })) {
          return $self->{datas}->{ $options{name} };
      }
      return undef;
  }
  
  sub encrypt {
      my ($self, %options) = @_;
  
      my $data = {
          encrypted => 1,
          cipher => $self->{statefile_cipher},
          iv => Crypt::PRNG::random_bytes_hex(16)
      };
  
      eval {
          my $cipher = Crypt::Mode::CBC->new($self->{statefile_cipher}, 1);
          $data->{ciphertext} = MIME::Base64::encode_base64(
              $cipher->encrypt(
                  $options{data},
                  $self->get_key(key => $self->{statefile_key}, cipher => $self->{statefile_cipher}),
                  pack('H*', $data->{iv})
              ),
              ''
          );
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "cipher encrypt error: $@");
          $self->{output}->option_exit();
      }
  
      return $self->serialize(data => $data, nocipher => 1);
  }
  
  sub serialize {
      my ($self, %options) = @_;
  
      my $serialized = '';
      if ($self->{statefile_format} eq 'dumper') {
          $serialized = Data::Dumper->Dump([$options{data}], ['datas']);
      } elsif ($self->{statefile_format} eq 'storable') {
          $serialized = Storable::freeze($options{data});
      } elsif ($self->{statefile_format} eq 'json') {
          eval {
              $serialized = JSON::XS->new->encode($options{data});
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg =>  "Cannot serialize statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'");
              $self->{output}->option_exit();
          }
      }
  
      if ($self->{statefile_key} ne '' && !defined($options{nocipher})) {
          $serialized = $self->encrypt(data => $serialized);
      }
  
      return $serialized;
  }
  
  sub write {
      my ($self, %options) = @_;
  
      my $serialized = $self->serialize(data => $options{data});
      if ($self->{memcached_ok} == 1) {
          Memcached::libmemcached::memcached_set(
              $self->{memcached},
              $self->{statefile_dir} . '/' . $self->{statefile}, 
              $serialized,
              $self->{memexpiration}
          );
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS$/i) {
              return ;
          }
      }
      if (defined($self->{redis_cnx})) {
          return if (defined($self->{redis_cnx}->set(
              $self->{statefile_dir} . '/' . $self->{statefile},
              $serialized,
              'EX', $self->{memexpiration}))
          );
      }
      open FILE, '>', $self->{statefile_dir} . '/' . $self->{statefile};
      print FILE $serialized;
      close FILE;
  }
  
  1;
  
  
  =head1 NAME
  
  centreon::plugins::statefile - A module for managing state files with various storage backends.
  
  =head1 SYNOPSIS
  
      use centreon::plugins::statefile;
  
      my $statefile = centreon::plugins::statefile->new(
          output => $output,
          options => $options
      );
  
      $statefile->check_options(option_results => $option_results);
      $statefile->read(statefile => 'my_statefile');
      my $data = $statefile->get(name => 'some_key');
      $statefile->write(data => { some_key => 'some_value' });
  
  =head1 DESCRIPTION
  
  The `centreon::plugins::statefile` module provides methods to manage state files (files storing the data to keep from an
  execution to the next one), supporting various storage backends such as local files, Memcached, and Redis. It also supports encryption and different serialization formats.
  
  =head1 METHODS
  
  =head2 new
  
      my $statefile = centreon::plugins::statefile->new(%options);
  
  Creates a new `centreon::plugins::statefile` object.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<output> - An C<centreon::plugins::output> object to log error messages.
  
  =item * C<options> - A C<centreon::plugins::options> object to add command-line options.
  
  =back
  
  =back
  
  =head2 check_options
  
      $statefile->check_options(%options);
  
  Checks and processes the provided options.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<option_results> - A hash of option results.
  
  =back
  
  =back
  
  =head2 read
  
      $statefile->read(%options);
  
  Reads the state file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<statefile> - The name of the state file to read.
  
  =item * C<statefile_suffix> - An optional suffix for the state file name.
  
  =item * C<statefile_dir> - An optional directory for the state file.
  
  =item * C<no_quit> - An optional flag to prevent the program from exiting on error.
  
  =back
  
  =back
  
  =head2 write
  
      $statefile->write(%options);
  
  Writes data to the state file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<data> - A hash reference containing the data to write.
  
  =back
  
  =back
  
  =head2 get
  
      my $value = $statefile->get(%options);
  
  Retrieves a value from the state file data.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<name> - The key name of the value to retrieve.
  
  =back
  
  =back
  
  =head2 get_string_content
  
      my $string = $statefile->get_string_content();
  
  Returns the state file data as a string.
  
  =head2 error
  
      my $error = $statefile->error();
  
  Gets or sets the error state.
  
  =over 4
  
  =item * C<$error> - An optional error value to set.
  
  =back
  
  =head1 EXAMPLES
  
  =head2 Creating a Statefile Object
  
      use centreon::plugins::statefile;
  
      my $statefile = centreon::plugins::statefile->new(
          output => $output,
          options => $options
      );
  
  =head2 Checking Options
  
      $statefile->check_options(option_results => $option_results);
  
  =head2 Reading a Statefile
  
      $statefile->read(statefile => 'my_statefile');
  
  =head2 Writing to a Statefile
  
      $statefile->write(data => { some_key => 'some_value' });
  
  =head2 Retrieving a Value
  
      my $value = $statefile->get(name => 'some_key');
  
  =head2 Getting Statefile Data as a String
  
      my $string = $statefile->get_string_content();
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
  
  =head1 RETENTION OPTIONS
  
  =over 8
  
  =item B<--memcached>
  
  Memcached server to use (only one server).
  
  =item B<--redis-server>
  
  Redis server to use (only one server). Syntax: address[:port]
  
  =item B<--redis-attribute>
  
  Set Redis Options (--redis-attribute="cnx_timeout=5").
  
  =item B<--redis-db>
  
  Set Redis database index.
  
  =item B<--failback-file>
  
  Fall back on a local file if Redis connection fails.
  
  =item B<--memexpiration>
  
  Time to keep data in seconds (default: 86400).
  
  =item B<--statefile-dir>
  
  Define the cache directory (default: '/var/lib/centreon/centplugins').
  
  =item B<--statefile-suffix>
  
  Define a suffix to customize the statefile name (default: '').
  
  =item B<--statefile-concat-cwd>
  
  If used with the '--statefile-dir' option, the latter's value will be used as
  a sub-directory of the current working directory.
  Useful on Windows when the plugin is compiled, as the file system and permissions are different from Linux.
  
  =item B<--statefile-format>
  
  Define the format used to store the cache. Available formats: 'dumper', 'storable', 'json' (default).
  
  =item B<--statefile-key>
  
  Define the key to encrypt/decrypt the cache.
  
  =item B<--statefile-cipher>
  
  Define the cipher algorithm to encrypt the cache (default: 'AES').
  
  =back
  
  =head1 DESCRIPTION
  
  B<statefile>.
  
  =cut
CENTREON_PLUGINS_STATEFILE

$fatpacked{"centreon/plugins/templates/catalog_functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS';
  #
  # Copyright 2018 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::catalog_functions;
  
  use strict;
  use warnings;
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(catalog_status_threshold catalog_status_threshold_ng catalog_status_calc);
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
  
      my $label = $self->{label};
      $label =~ s/-/_/g;
      if (defined($self->{instance_mode}->{option_results}->{'ok_' . $label}) && $self->{instance_mode}->{option_results}->{'ok_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'ok_' . $label})) {
          $status = 'ok';
      } elsif (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'critical_' . $label})) {
          $status = 'critical';
      } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'warning_' . $label})) {
          $status = 'warning';
      } elsif (defined($self->{instance_mode}->{option_results}->{'unknown_' . $label}) && $self->{instance_mode}->{option_results}->{'unknown_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'unknown_' . $label})) {
          $status = 'unknown';
      }
  
      return $status;
  }
  
  sub catalog_status_threshold_ng {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      if (defined($self->{instance_mode}->{option_results}->{'critical-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'critical-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'critical-' . $self->{label}})) {
          $status = 'critical';
      } elsif (defined($self->{instance_mode}->{option_results}->{'warning-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'warning-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'warning-' . $self->{label}})) {
          $status = 'warning';
      } elsif (defined($self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}})) {
          $status = 'unknown';
      }
  
      return $status;
  }
  
  sub catalog_status_calc {
      my ($self, %options) = @_;
  
      foreach (keys %{$options{new_datas}}) {
          if (/^\Q$self->{instance}\E_(.*)/) {
              $self->{result_values}->{$1} = $options{new_datas}->{$_};
          }
      }
  }
  
  1;
  
  
CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS

$fatpacked{"centreon/plugins/templates/counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_COUNTER';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  
  package centreon::plugins::templates::counter;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use centreon::plugins::values;
  use centreon::plugins::misc;
  use JSON::XS;
  
  my $sort_subs = {
      num => sub { $a <=> $b },
      cmp => sub { $a cmp $b },
  };
  
  sub set_counters {
      my ($self, %options) = @_;
      
      if (!defined($self->{maps_counters})) {
          $self->{maps_counters} = {};
      }
      
      $self->{maps_counters_type} = [];
      
      # 0 = mode total
      # 1 = mode instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'global', type => 0, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #};
  
      #$self->{maps_counters}->{global} = [
      #    { label => 'client', set => {
      #           key_values => [ { name => 'client' } ],
      #           output_template => 'Current client connections : %s',
      #           perfdatas => [
      #               { label => 'Client', value => 'client', template => '%s', 
      #                 min => 0, unit => 'con' },
      #           ],
      #       }
      #    },
      #];
      
      # Example for instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'cpu', type => 1, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #    message_multiple => 'All CPU usages are ok',
      #};    
  }
  
  sub get_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          return $self->can($options{method_name});
      }
      
      return undef;
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub get_threshold_prefix {
      my ($self, %options) = @_;
      
      my $prefix = '';
      END_LOOP: foreach (@{$self->{maps_counters_type}}) {
          if ($_->{name} eq $options{name}) {
              $prefix = 'instance-' if ($_->{type} == 1);
              last;
          }
          
          if ($_->{type} == 3) {
              foreach (@{$_->{group}}) {
                  if ($_->{name} eq $options{name}) {
                      $prefix = 'instance-' if ($_->{type} == 0);
                      $prefix = 'subinstance-' if ($_->{type} == 1);
                      last END_LOOP;
                  }
              }
          }
      }
  
      return $prefix;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'filter-counters-block:s' => { name => 'filter_counters_block' },
          'filter-counters:s'       => { name => 'filter_counters' },
          'display-ok-counters:s'   => { name => 'display_ok_counters' },
          'list-counters'           => { name => 'list_counters' }
      });
      $self->{statefile_value} = undef;
      if (defined($options{statefile}) && $options{statefile}) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'centreon::plugins::statefile',
              error_msg => "Cannot load module 'centreon::plugins::statefile'."
          );
          $self->{statefile_value} = centreon::plugins::statefile->new(%options);
      }
  
      $self->{maps_counters} = {} if (!defined($self->{maps_counters}));
      $self->set_counters(%options);
      
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              my $label = $_->{label};
              my $thlabel = $label;
              if ($self->{output}->use_new_perfdata() && defined($_->{nlabel})) {
                  $label = $_->{nlabel};
                  $thlabel = $self->get_threshold_prefix(name => $key) . $label;
              }
              $thlabel =~ s/\./-/g;
  
              if (!defined($_->{threshold}) || $_->{threshold} != 0) {
                  $options{options}->add_options(arguments => {
                      'unknown-' . $thlabel . ':s'  => { name => 'unknown-' . $thlabel, default => $_->{unknown_default} },
                      'warning-' . $thlabel . ':s'  => { name => 'warning-' . $thlabel, default => $_->{warning_default} },
                      'critical-' . $thlabel . ':s' => { name => 'critical-' . $thlabel, default => $_->{critical_default} }
                  });
  
                  if (defined($_->{nlabel})) {
                      $options{options}->add_options(arguments => {
                          'unknown-' . $_->{label} . ':s'  => { name => 'unknown-' . $_->{label}, redirect => 'unknown-' . $thlabel },
                          'warning-' . $_->{label} . ':s'  => { name => 'warning-' . $_->{label}, redirect => 'warning-' . $thlabel },
                          'critical-' . $_->{label} . ':s' => { name => 'critical-' . $_->{label}, redirect => 'critical-' . $thlabel }
                      });
                  }
              }
  
              $_->{obj} = centreon::plugins::values->new(
                  statefile => $self->{statefile_value},
                  output => $self->{output}, perfdata => $self->{perfdata},
                  label => $_->{label}, nlabel => $_->{nlabel}, thlabel => $thlabel
              );
              $_->{obj}->set(%{$_->{set}});
          }
      }
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL COUNTERS OPTIONS', once => 1) if $options{display_template_help};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{list_counters})) {
          my $list_counter = '';
          my $th_counter = '';
          my $counters;
          foreach my $key (keys %{$self->{maps_counters}}) {
              foreach (@{$self->{maps_counters}->{$key}}) {
                  $counters->{metrics}->{$_->{label}}->{nlabel} ="";
                  $counters->{metrics}->{$_->{label}}->{min}="";
                  $counters->{metrics}->{$_->{label}}->{max}="";
                  $counters->{metrics}->{$_->{label}}->{unit}="";
                  $counters->{metrics}->{$_->{label}}->{output_template}="";
                  if(defined($_->{nlabel})) {
                      $counters->{metrics}->{$_->{label}}->{nlabel} = $_->{nlabel};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{min})) {
                      $counters->{metrics}->{$_->{label}}->{min} = $_->{set}->{perfdatas}->[0]->{min};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{max})) {
                      $counters->{metrics}->{$_->{label}}->{max} = $_->{set}->{perfdatas}->[0]->{max};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{unit})) {
                      $counters->{metrics}->{$_->{label}}->{unit} = $_->{set}->{perfdatas}->[0]->{unit};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{template})) {
                      $counters->{metrics}->{$_->{label}}->{output_template} = $_->{set}->{perfdatas}->[0]->{template};
                  }
                  my $label = $_->{label};
                  $label =~ s/-//g;
                  $list_counter .= $_->{label}." ";
                  $th_counter .= " --warning-$_->{label}='\$_SERVICEWARNING" . uc($label) . "\$' --critical-$_->{label}='\$_SERVICECRITICAL" . uc($label) . "\$'";
  
              }
          }
          $counters->{"counter list"}=$list_counter;
          $counters->{"pack configuration"}=$th_counter." \$_SERVICEEXTRAOPTIONS\$";
  
          my $result_data ="";
          eval {
              $result_data = JSON::XS->new->indent->space_after->canonical->utf8->encode($counters);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot use \$counters as it is a malformed JSON: " . $@);
              $self->{output}->option_exit();
          }
  
          $self->{output}->output_add(short_msg => "counter list: ".$list_counter);
          $self->{output}->output_add(long_msg => $result_data);
          $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
          $self->{output}->exit();
      }
  
      my $change_macros_opt = [];
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              push @$change_macros_opt, 'unknown-' . $_->{label}, 'warning-' . $_->{label}, 'critical-' . $_->{label}
                  if (defined($_->{type}) && $_->{type} == 2);
              $_->{obj}->{instance_mode} = $self;
              $_->{obj}->init(option_results => $self->{option_results}) if (!defined($_->{type}) || $_->{type} != 2);
          }
      }
  
      $self->change_macros(macros => $change_macros_opt) if (scalar(@$change_macros_opt) > 0);
  
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->check_options(%options);
      }
  }
  
  sub run_global {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
      # Can be set when it comes from type 3 counters
      my $called_multiple = defined($options{called_multiple}) && $options{called_multiple} == 1 ? 1 : 0;
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? 1 : 0;
      my $force_instance = defined($options{force_instance}) ? $options{force_instance} : undef;
  
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
      my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
      my @exits;
      foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
          my $obj = $_->{obj};
  
          next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
              $_->{label} !~ /$self->{option_results}->{filter_counters}/);
  
          $obj->set(instance => defined($force_instance) ? $force_instance : $options{config}->{name});
  
          my ($value_check) = $obj->execute(new_datas => $self->{new_datas}, values => $self->{$options{config}->{name}});
  
          next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
          if ($value_check != 0) {
              $long_msg .= $long_msg_append . $obj->output_error();
              $long_msg_append = $message_separator;
              next;
          }
          my $exit2 = $obj->threshold_check();
          push @exits, $exit2;
  
          my $output = $obj->output();
          if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
              (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
               $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
          }
  
          if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
              $short_msg .= $short_msg_append . $output;
              $short_msg_append = $message_separator;
          }
  
          $obj->perfdata(extra_instance => $multiple_parent);
      }
  
      my ($prefix_output, $suffix_output);
      $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}) 
          if (defined($options{config}->{cb_prefix_output}));
      $prefix_output = '' if (!defined($prefix_output));
  
      $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}, instance_value => $self->{$options{config}->{name}}) 
          if (defined($options{config}->{cb_suffix_output}));
      $suffix_output = '' if (!defined($suffix_output));
  
      if ($called_multiple == 1 && $long_msg ne '') {
          $self->{output}->output_add(long_msg => $options{indent_long_output} . $prefix_output. $long_msg . $suffix_output);
      }
  
      my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
      if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
          if ($called_multiple == 0) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          } else {
              $self->run_multiple_prefix_output(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
      } else {
          if ($long_msg ne '' && $multiple_parent == 0) {
              if ($called_multiple == 0) {
                  $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output)
                      if ($display_short == 1);
              } else {
                  $self->run_multiple_prefix_output(
                      severity => 'ok',
                      short_msg => $prefix_output . $long_msg . $suffix_output
                  ) if ($display_short == 1);
              }
          }
      }
  }
  
  sub run_instances {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $cb_init_counters = $self->get_callback(method_name => $options{config}->{cb_init_counters});
      my $display_status_lo = defined($options{display_status_long_output}) && $options{display_status_long_output} == 1 ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
      my $display_long = (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0) ? 1 : 0;
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $no_message_multiple = 1;
      
      $self->{lproblems} = 0;
      $self->{multiple} = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $self->{multiple} = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
  
      # The default sort method is cmp (string comparison)
      my $sort_method = 'cmp';
      # If configured otherwise, we take it from the counter (only other method is 'num' for '<=>')
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
  
      # In the absence of sort_attribute the sort method is set now
      my $sort_sub = $sort_subs->{$sort_method};
  
      # If sort_attribute is set, then we'll redefine how things are sorted depending on the specified sort_method
      if (defined($options{config}->{sort_attribute})) {
          my $sort_attribute = $options{config}->{sort_attribute};
          if ($sort_method eq 'cmp') {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} cmp $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          } else {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} <=> $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          }
      }
  
      # Now the loop begins with the desired sorting method
      foreach my $id (sort { $sort_sub->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
  
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              next if ($cb_init_counters && $self->$cb_init_counters(%$_) == 1);
  
              $no_message_multiple = 0;
              $obj->set(instance => $id);
          
              my ($value_check) = $obj->execute(
                  new_datas => $self->{new_datas},
                  values => $self->{$options{config}->{name}}->{$id}
              );
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $self->{lproblems}++;
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              $obj->perfdata(extra_instance => $self->{multiple});
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          # in mode grouped, we don't display 'ok'
          my $debug = 0;
          $debug = 1 if ($display_status_lo == 1 && $self->{output}->is_status(value => $exit, compare => 'OK', litteral => 1));
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => ($display_status_lo == 1 ? lc($exit) . ': ' : '') . $prefix_output . $long_msg . $suffix_output, debug => $debug)
                  if ($display_long == 1);
          }
          if ($resume == 1) {
              $self->{most_critical_instance} = $self->{output}->get_most_critical(status => [ $self->{most_critical_instance},  $exit ]);  
              next;
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
          
          if ($self->{multiple} == 0)  {
              $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output)
                  if ($display_short == 1);
          }
      }
      
      if ($no_message_multiple == 0 && $self->{multiple} == 1 && $resume == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple})
              if ($display_short == 1);
      }
  }
  
  sub run_group {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      return if (scalar(keys %{$self->{$options{config}->{name}}}) <= 0);
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => $options{config}->{message_multiple}
          );
      }
  
      my $format_output = defined($options{config}->{format_output}) ? $options{config}->{format_output} : '%s problem(s) detected';
  
      my ($global_exit, $total_problems) = ([], 0);
      foreach my $id (sort keys %{$self->{$options{config}->{name}}}) {
          $self->{most_critical_instance} = 'ok';
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(
                  long_msg => $self->call_object_callback(
                      method_name => $options{config}->{cb_long_output},
                      instance => $id,
                      instance_value => $self->{$options{config}->{name}}->{$id}
                  )
              );
          }
  
          foreach my $group (@{$options{config}->{group}}) {
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$id}->{$group->{name}};
              
              # we resume datas
              $self->run_instances(config => $group, display_status_long_output => 1, resume => 1);
              
              push @{$global_exit}, $self->{most_critical_instance};
              $total_problems += $self->{lproblems};
              
              my $prefix_output;
              $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
                  if (defined($options{config}->{cb_prefix_output}));
              $prefix_output = '' if (!defined($prefix_output));
              
              if ($multiple == 0 && (!defined($group->{display}) || $group->{display} != 0)) {
                  $self->{output}->output_add(
                      severity => $self->{most_critical_instance},
                      short_msg => sprintf("${prefix_output}" . $format_output, $self->{lproblems})
                  );
              }
          }
      }
      
      if ($multiple == 1) {
          my $exit = $self->{output}->get_most_critical(status => [ @{$global_exit} ]);
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => sprintf($format_output, $total_problems)
              );
          }
      }
      
      if (defined($options{config}->{display_counter_problem})) {
          $self->{output}->perfdata_add(
              label => $options{config}->{display_counter_problem}->{label},
              nlabel => $options{config}->{display_counter_problem}->{nlabel},
              unit => $options{config}->{display_counter_problem}->{unit},
              value => $total_problems,
              min => $options{config}->{display_counter_problem}->{min}, max => $options{config}->{display_counter_problem}->{max}
          );
      }
  }
  
  sub run_multiple_instances {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $use_new_perfdata = $self->{output}->use_new_perfdata();
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? $options{multiple_parent} : 0;
      my $indent_long_output = defined($options{indent_long_output}) ? $options{indent_long_output} : '';
      my $no_message_multiple = 1;
      my $display_long = (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0) ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
  
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator} : ', ';
  
      # The default sort method is cmp (string comparison)
      my $sort_method = 'cmp';
      # If configured otherwise, we take it from the counter (only other method is 'num' for '<=>')
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
  
      # In the absence of sort_attribute the sort method is set now
      my $sort_sub = $sort_subs->{$sort_method};
  
      # If sort_attribute is set, then we'll redefine how things are sorted depending on the specified sort_method
      if (defined($options{config}->{sort_attribute})) {
          my $sort_attribute = $options{config}->{sort_attribute};
          if ($sort_method eq 'cmp') {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} cmp $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          } else {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} <=> $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          }
      }
  
      # Now the loop begins with the desired sorting method
      foreach my $id (sort { $sort_sub->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
              
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              
              my $instance = $id;
              if ($use_new_perfdata || ($multiple_parent == 1 && $multiple == 1)) {
                  $instance = $options{instance_parent} . ($self->{output}->get_instance_perfdata_separator()) . $id;
              } elsif ($multiple_parent == 1 && $multiple == 0) {
                  $instance = $options{instance_parent};
              }
              
              $no_message_multiple = 0;
              $obj->set(instance => $instance);
          
              my ($value_check) = $obj->execute(
                  new_datas => $self->{new_datas},
                  values => $self->{$options{config}->{name}}->{$id}
              );
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
  
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              if ($multiple_parent == 1 && $multiple == 0) {
                  $obj->perfdata(extra_instance => 1);
              } else {
                  $obj->perfdata(extra_instance => $multiple);
              }
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
  
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => $indent_long_output . $prefix_output . $long_msg . $suffix_output)
                  if ($display_long == 1);
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->run_multiple_prefix_output(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
  
          if ($multiple == 0 && $multiple_parent == 0) {
              $self->run_multiple_prefix_output(severity => 'ok', short_msg => $prefix_output . $long_msg . $suffix_output)
                  if ($display_short == 1);
          }
      }
  
      if ($no_message_multiple == 0 && $multiple == 1 && $multiple_parent == 0) {
          $self->run_multiple_prefix_output(severity => 'ok', short_msg => $options{config}->{message_multiple})
              if ($display_short == 1);
      }
  }
  
  sub run_multiple_prefix_output {
      my ($self, %options) = @_;
      
      my %separator;
      if ($self->{prefix_multiple_output_done}->{lc($options{severity})} == 0) {
          $self->{output}->output_add(severity => $options{severity}, short_msg => $self->{prefix_multiple_output});
          $self->{prefix_multiple_output_done}->{lc($options{severity})} = 1;
          $separator{separator} = '';
      }
  
      $self->{output}->output_add(severity => $options{severity}, short_msg => $options{short_msg}, %separator);
  }
  
  sub run_multiple {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
  
      if ($multiple == 1) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => $options{config}->{message_multiple}
          );
      }
  
      foreach my $instance (sort keys %{$self->{$options{config}->{name}}}) {
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(
                  long_msg => $self->call_object_callback(
                      method_name => $options{config}->{cb_long_output},
                      instance => $instance,
                      instance_value => $self->{$options{config}->{name}}->{$instance}
                  )
              );
          }
  
          $self->{prefix_multiple_output} = '';
          $self->{prefix_multiple_output_done} = { ok => 0, warning => 0, critical => 0, unknown => 0 };
          $self->{prefix_multiple_output} = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $instance, instance_value => $self->{$options{config}->{name}}->{$instance})
               if (defined($options{config}->{cb_prefix_output}));
          my $indent_long_output = '';
          $indent_long_output = $options{config}->{indent_long_output}
              if (defined($options{config}->{indent_long_output}));
  
          foreach my $group (@{$options{config}->{group}}) {
              next if (!defined($self->{$options{config}->{name}}->{$instance}->{$group->{name}}));
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$instance}->{$group->{name}};
  
              if ($group->{type} == 1) {
                  $self->run_multiple_instances(config => $group, multiple_parent => $multiple, instance_parent => $instance, indent_long_output => $indent_long_output);
              } elsif ($group->{type} == 0) {
                  $self->run_global(
                      config => $group,
                      multiple_parent => $multiple,
                      called_multiple => 1,
                      force_instance => $instance,
                      indent_long_output => $indent_long_output
                  );
              }
          }
      }
  }
  
  sub read_statefile_key {
      my ($self, %options) = @_;
  
      $self->{statefile_value}->read(statefile => $self->{cache_name});
      return $self->{statefile_value}->get(name => $options{key});
  }
  
  sub set_timestamp {
      my ($self, %options) = @_;
  
      $self->{override_timestamp} = $options{timestamp};
  }
  
  sub run {
      my ($self, %options) = @_;
      
      $self->manage_selection(%options);
      
      $self->{new_datas} = undef;
      if (defined($self->{statefile_value})) {
          $self->{new_datas} = {};
          $self->{statefile_value}->read(statefile => $self->{cache_name}) if (defined($self->{cache_name}));
          $self->{new_datas}->{last_timestamp} = defined($self->{override_timestamp}) ? $self->{override_timestamp} : time();
      }
  
      foreach my $entry (@{$self->{maps_counters_type}}) {
          if ($entry->{type} == 0) {
              $self->run_global(config => $entry);
          } elsif ($entry->{type} == 1) {
              $self->run_instances(config => $entry);
          } elsif ($entry->{type} == 2) {
              $self->run_group(config => $entry);
          } elsif ($entry->{type} == 3) {
              $self->run_multiple(config => $entry);
          }
      }
  
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->write(data => $self->{new_datas});
      }
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      # example for snmp
      #use Digest::MD5 qw(md5_hex);
      #$self->{cache_name} = "choose_name_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
      #    (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  sub compat_threshold_counter {
      my ($self, %options) = @_;
  
      foreach ('warning', 'critical') {
          foreach my $th (@{$options{compat}->{th}}) {
              next if (!defined($options{option_results}->{$_ . '-' . $th->[0]}) || $options{option_results}->{$_ . '-' . $th->[0]} eq '');
  
              my $src_threshold = $options{option_results}->{$_ . '-' . $th->[0]};
              if (defined($options{compat}->{units}) && $options{compat}->{units} eq '%') {
                  $options{option_results}->{$_ . '-' . $th->[0]} = undef;
                  if (defined($options{compat}->{free})) {
                      $options{option_results}->{$_ . '-' . $th->[0]} = undef;
                      my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => $src_threshold);
                      next if ($status == 0);
  
                      my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
                      $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
                      $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
                      if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
                          $tmp->{end} = 100 - $result->{start};
                      }
                      if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
                          $tmp->{start} = 100 - $result->{end};
                      }
  
                      $options{option_results}->{$_ . '-' . $th->[1]->{prct}} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
                  } else {
                      $options{option_results}->{$_ . '-' . $th->[1]->{prct}} = $src_threshold;
                  }
              } elsif (defined($options{compat}->{free})) {
                  $options{option_results}->{$_ . '-' . $th->[1]->{free}} = $options{option_results}->{$_ . '-' . $th->[0]};
                  $options{option_results}->{$_ . '-' . $th->[0]} = undef;
              }
          }
      }
  }
  
  sub change_macros {
      my ($self, %options) = @_;
  
      foreach (@{$options{macros}}) {
          if (defined($self->{option_results}->{$_}) && $self->{option_results}->{$_} ne '') {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$values->{$1}/g;
          }
      }
  }
  
  sub custom_perfdata_instances {
      my ($self, %options) = @_;
  
      my $instances = [];
      foreach (split(/\s+/, $options{instances})) {
          while (/%\((.+?)\)/g) {
              my $name = $1;
              if (!defined($options{labels}->{$name})) {
                  $self->{output}->add_option_msg(short_msg => "option $options{option_name} unsupported label: %($name)");
                  $self->{output}->option_exit();
              }
  
              push @$instances, $name;
          }
      }
  
      if (scalar(@$instances) <= 0) {
          $self->{output}->add_option_msg(short_msg => "option $options{option_name} need at least one label");
          $self->{output}->option_exit();
      }
  
      return $instances;
  }
  
  1;
  
  
  =head1 GLOBAL COUNTERS OPTIONS
  
  Global options for counters.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example to check SSL connections only : --filter-counters='^xxxx|yyyy$'
  
  =item B<--warning-*>
  
  Warning threshold.
  Can be: 'xxx', 'xxx'.
  
  =item B<--critical-*>
  
  Critical threshold.
  Can be: 'xxx', 'xxx'.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_COUNTER

$fatpacked{"centreon/plugins/templates/hardware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_HARDWARE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::hardware;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
  
      #$self->{regexp_threshold_numeric_check_section_option} = '';
      #$self->{cb_threshold_numeric_check_section_option} = 'callbackname';
  
      # Some callbacks 
      #$self->{cb_hook1} = 'callbackname'; # before the loads
      #$self->{cb_hook2} = 'callbackname'; # between loads and requests
      #$self->{cb_hook3} = 'callbackname'; # after requests
      #$self->{cb_hook4} = 'callbackname'; # after output
  
      # Example for threshold:
      #$self->{thresholds} = {
      #    fan => [
      #        ['bad', 'CRITICAL'],
      #        ['good', 'OK'],
      #        ['notPresent', 'OK'],
      #    ],
      #};
      
      # Unset the call to load components
      #$self->{components_exec_load} = 0;
  
      # Set the path_info
      #$self->{components_path} = 'network::xxxx::mode::components';
  
      # Set the components
      #$self->{components_module} = ['cpu', 'memory', ...];
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
  
      return undef;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'component:s'            => { name => 'component', default => '.*' },
          'no-component:s'         => { name => 'no_component', default => 'critical' },
          'threshold-overload:s@'  => { name => 'threshold_overload' },
          'add-name-instance'      => { name => 'add_name_instance' },
          'no-component-count'     => { name => 'no_component_count' }
      });
  
      $self->{performance} = (defined($options{no_performance}) && $options{no_performance} == 1) ?
          0 : 1;
      if ($self->{performance} == 1) {
          $options{options}->add_options(arguments => {
              'warning:s@'  => { name => 'warning' },
              'critical:s@' => { name => 'critical' }
          });
      }
  
      $self->{filter_exclude} = (defined($options{no_filter_exclude}) && $options{no_filter_exclude} == 1) ?
          0 : 1;
      if ($self->{filter_exclude} == 1) {
          $options{options}->add_options(arguments => {
              'exclude:s'     => { name => 'exclude' },
              'filter:s@'     => { name => 'filter' }
          });
      }
      $self->{absent} = (defined($options{no_absent}) && $options{no_absent} == 1) ?
          0 : 1;
      if ($self->{absent} == 1) {
          $options{options}->add_options(arguments => {
              'absent-problem:s@' => { name => 'absent_problem' }
          });
      }
  
      $self->{load_components} = (defined($options{no_load_components}) && $options{no_load_components} == 1) ?
          0 : 1;
      $self->{components} = {};
      $self->{no_components} = undef;
  
      $self->{components_module} = [];
      $self->{components_exec_load} = 1;
      $self->set_system();
  
      $self->{count} = (defined($options{no_count}) && $options{no_count} == 1) ? 0 : 1;
      if ($self->{count} == 1) {
          foreach my $component (@{$self->{components_module}}) {
              $options{options}->add_options(arguments => {
                  'unknown-count-' . $component . ':s'  => { name => 'unknown_count_' . $component },
                  'warning-count-' . $component . ':s'  => { name => 'warning_count_' . $component },
                  'critical-count-' . $component . ':s' => { name => 'critical_count_' . $component }
              });
          }
      }
  
      $self->{request} = [];
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL HARDWARE OPTIONS', once => 1) if $options{display_template_help};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      # For compatibility both $self->{option_results}->{no_component} and $self->{no_components} are initialized.
      # If unset or empty the default value 'critical' is used.
      $self->{option_results}->{no_component} = $self->{no_components} = $self->{option_results}->{no_component} || 'critical';
  
      if ($self->{filter_exclude} == 1) {
          $self->{filter} = [];
          foreach my $val (@{$self->{option_results}->{filter}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{filter}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
  
      if ($self->{absent} == 1) {
          $self->{absent_problem} = [];
          foreach my $val (@{$self->{option_results}->{absent_problem}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{absent_problem}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
  
      $self->{overload_th} = [];
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          next if (!defined($val) || $val eq '');
          my @values = split (/,/, $val);
          if (scalar(@values) < 3) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $instance, $status, $filter);
          if (scalar(@values) == 3) {
              ($section, $status, $filter) = @values;
              $instance = '.*';
          } else {
               ($section, $instance, $status, $filter) = @values;
          }
  
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          push @{$self->{overload_th}}, { section => $section, filter => $filter, status => $status, instance => $instance };
      }
  
      if ($self->{performance} == 1) {
          $self->{numeric_threshold} = {};
          foreach my $option (('warning', 'critical')) {
              foreach my $val (@{$self->{option_results}->{$option}}) {
                  next if (!defined($val) || $val eq '');
                  if ($val !~ /^(.*?),(.*?),(.*)$/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }
                  my ($section, $instance, $value) = ($1, $2, $3);                
                  if (defined($self->{regexp_threshold_numeric_check_section_option}) && 
                      $section !~ /$self->{regexp_threshold_numeric_check_section_option}/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }   
                  $self->call_object_callback(
                      method_name => $self->{cb_threshold_numeric_check_section_option}, 
                      section => $section,
                      option_name => $option,
                      option_value => $val
                  );
  
                  my $position = 0;
                  if (defined($self->{numeric_threshold}->{$section})) {
                      $position = scalar(@{$self->{numeric_threshold}->{$section}});
                  }
                  if (($self->{perfdata}->threshold_validate(label => $option . '-' . $section . '-' . $position, value => $value)) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option threshold '" . $value . "'.");
                      $self->{output}->option_exit();
                  }
                  $self->{numeric_threshold}->{$section} = [] if (!defined($self->{numeric_threshold}->{$section}));
                  push @{$self->{numeric_threshold}->{$section}}, { label => $option . '-' . $section . '-' . $position, threshold => $option, instance => $instance };
              }
          }
      }
  
      if ($self->{count} == 1) {
          foreach my $comp (@{$self->{components_module}}) {
              foreach my $threshold (('warning', 'critical', 'unknown')) {
                  if (($self->{perfdata}->threshold_validate(label => $threshold . '-count-' . $comp, value => $self->{option_results}->{$threshold . '_count_' . $comp})) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong " . $threshold . " threshold '" . $self->{option_results}->{$threshold . '_count_' . $comp} . "'.");
                      $self->{output}->option_exit();
                  }
              }
          }
      }
  }
  
  sub load_components {
      my ($self, %options) = @_;
  
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output}, module => $mod_name,
                  error_msg => "Cannot load module '$mod_name'.") if ($self->{load_components} == 1);
              $self->{loaded} = 1;
              if ($self->{components_exec_load} == 1) {
                  my $func = $mod_name->can('load');
                  $func->($self);
              }
          }
      }
  }
  
  sub exec_components {
      my ($self, %options) = @_;
  
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              my $func = $mod_name->can('check');
              $func->($self); 
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
  
      my $total_components = 0;
      my $display_by_component = '';
      my $display_by_component_append = '';
      my $exit = 'OK';
      my $exits = [];
      my ($warn, $crit);
  
      foreach my $comp (sort(keys %{$self->{components}})) {
          # Skipping short msg when no components
          next if (!defined($self->{option_results}->{no_component_count}) && $self->{components}->{$comp}->{total} == 0 && $self->{components}->{$comp}->{skip} == 0);
          next if (defined($self->{option_results}->{component}) && $comp !~ /$self->{option_results}->{component}/ );
  
          if ($self->{count} == 1) {
              ($exit, $warn, $crit) = $self->get_severity_count(label => $comp, value => $self->{components}->{$comp}->{total});
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(
                      severity => $exit,
                      short_msg => sprintf(
                          "'%s' components '%s' checked",
                          $self->{components}->{$comp}->{total},
                          $comp
                      )
                  );
              }
              $self->{output}->perfdata_add(
                  label => 'count_' . $comp,
                  nlabel => 'hardware.' . $comp . '.count',
                  value => $self->{components}->{$comp}->{total},
                  warning => $warn,
                  critical => $crit
              );
              push @{$exits}, $exit;
          }
  
          $total_components += $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip};
          my $count_by_components = $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip}; 
          $display_by_component .= $display_by_component_append . $self->{components}->{$comp}->{total} . '/' . $count_by_components . ' ' . $self->{components}->{$comp}->{name};
          $display_by_component_append = ', ';
      }
  
      $exit = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
  
      if ($self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(
              short_msg => sprintf(
                  'All %s components are ok [%s].', 
                  $total_components,
                  $display_by_component
              )
          );
      }
  
      if (defined($self->{option_results}->{no_component}) && $total_components == 0) {
          $self->{output}->output_add(
              severity => $self->{no_components},
              short_msg => 'No components are checked.'
          );
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
  
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      $self->exec_components(%options);
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
  
      $self->display();
  
      $self->call_object_callback(method_name => $self->{cb_hook4}, %options);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      $self->{output}->add_disco_format(elements => ['component', 'instance', 'description']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
      
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              if (my $func = $mod_name->can('disco_show')) {
                  $func->($self);
              }
          }
      }
  
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
  }
  
  sub check_filter {
      my ($self, %options) = @_;
  
      # Old compatibility variable. We'll be deleted
      if (defined($self->{option_results}->{exclude})) {
          if (defined($options{instance})) {
              if ($self->{option_results}->{exclude} =~ /(^|\s|,)${options{section}}[^,]*#\Q$options{instance}\E#/) {
                  $self->{components}->{$options{section}}->{skip}++;
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          } elsif (defined($self->{option_results}->{exclude}) && $self->{option_results}->{exclude} =~ /(^|\s|,)$options{section}(\s|,|$)/) {
              $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
              return 1;
          }
      }
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));   
      foreach (@{$self->{filter}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($options{instance}) && !defined($_->{instance})) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
                  return 1;
              } elsif (defined($options{instance}) && $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  sub absent_problem {
      my ($self, %options) = @_;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      foreach (@{$self->{absent_problem}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($_->{instance}) || $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(
                      severity => 'CRITICAL',
                      short_msg => sprintf(
                          "Component '%s' instance '%s' is not present", 
                          $options{section},
                          $options{instance}
                      )
                  );
                  $self->{output}->output_add(long_msg => sprintf("Skipping $options{section} section $options{instance} instance (not present)"));
                  $self->{components}->{$options{section}}->{skip}++;
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  sub get_severity_count {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
  
      $status = $self->{perfdata}->threshold_check(
          value => $options{value},
          threshold => [
              { label => 'critical-count-' . $options{label}, exit_litteral => 'critical' }, 
              { label => 'warning-count-' . $options{label}, exit_litteral => 'warning' },
              { label => 'unknown-count-' . $options{label}, exit_litteral => 'unknown' },
          ]
      );
      $thresholds->{critical} = $self->{perfdata}->get_perfdata_for_output(label => 'critical-count-' . $options{label});
      $thresholds->{warning} = $self->{perfdata}->get_perfdata_for_output(label => 'warning-count-' . $options{label});
  
      return ($status, $thresholds->{warning}, $thresholds->{critical});
  }
  
  sub get_severity_numeric {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      my $checked = 0;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      if (defined($self->{numeric_threshold}->{$options{section}})) {
          my $exits = [];
          foreach (@{$self->{numeric_threshold}->{$options{section}}}) {
              if ($options{instance} =~ /$_->{instance}/) {
                  push @{$exits}, $self->{perfdata}->threshold_check(value => $options{value}, threshold => [ { label => $_->{label}, exit_litteral => $_->{threshold} } ]);
                  $thresholds->{$_->{threshold}} = $self->{perfdata}->get_perfdata_for_output(label => $_->{label});
                  $checked = 1;
              }
          }
          $status = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      }
  
      return ($status, $thresholds->{warning}, $thresholds->{critical}, $checked);
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
  
      foreach (@{$self->{overload_th}}) {
          if ($options{section} =~ /$_->{section}/i) {
              if ($options{value} =~ /$_->{filter}/i &&
                  (!defined($options{instance}) || $options{instance} =~ /$_->{instance}/)) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
  
      my $label = defined($options{label}) ? $options{label} : $options{section};
      foreach (@{$self->{thresholds}->{$label}}) {
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
  
      return $status;
  }
      
  1;
  
  
  =head1 GLOBAL HARDWARE OPTIONS
  
  Global options for hardware.
  
  =over 8
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_HARDWARE

$fatpacked{"centreon/plugins/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_VALUES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::values;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::constants qw(:values);
  
  # Warning message with sprintf and too much arguments.
  # Really annoying. Need to disable that warning
  no if ($^V gt v5.22.0), 'warnings' => 'redundant';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{statefile} = $options{statefile};
      $self->{output} = $options{output};
      $self->{perfdata} = $options{perfdata};
      $self->{label} = $options{label};
      $self->{nlabel} = $options{nlabel};
      $self->{thlabel} = defined($options{thlabel}) ? $options{thlabel} : $self->{label};
  
      $self->{perfdatas} = [];
      
      $self->{output_template} = $self->{label} . ' : %s';
      $self->{output_use} = undef;
      $self->{output_change_bytes} = 0;
      
      $self->{output_error_template} = $self->{label} . ' : %s';
      
      $self->{threshold_use} = undef;
      $self->{threshold_warn} = undef;
      $self->{threshold_crit} = undef;
  
      $self->{per_second} = 0;
      $self->{manual_keys} = 0;
      $self->{last_timestamp} = undef;
  
      $self->{result_values} = {};
      $self->{safe_test} = 0;
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      my $unkn = defined($self->{threshold_unkn}) ? $self->{threshold_unkn} : 'unknown-' . $self->{thlabel};
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
  
      if (($self->{perfdata}->threshold_validate(label => $unkn, value => $options{option_results}->{$unkn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $unkn threshold '" . $options{option_results}->{$unkn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $warn, value => $options{option_results}->{$warn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $warn threshold '" . $options{option_results}->{$warn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $crit, value => $options{option_results}->{$crit})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $crit threshold '" . $options{option_results}->{$crit} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub calc {
      my ($self, %options) = @_;
  
      # manage only one value ;)
      foreach my $value (@{$self->{key_values}}) {
          if (defined($value->{diff}) && $value->{diff} == 1)  {
              $self->{result_values}->{$value->{name}} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}};
          } elsif (defined($value->{per_second}) && $value->{per_second} == 1) {
              $self->{result_values}->{$value->{name}} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / $options{delta_time};
          } elsif (defined($value->{per_minute}) && $value->{per_minute} == 1) {
              $self->{result_values}->{$value->{name}} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / ($options{delta_time} / 60);
          } else {
              $self->{result_values}->{$value->{name}} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}};
          }
      }
  
      return 0;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      if (defined($self->{closure_custom_threshold_check})) {
          return &{$self->{closure_custom_threshold_check}}($self, %options);
      }
  
      my $unkn = defined($self->{threshold_unkn}) ? $self->{threshold_unkn} : 'unknown-' . $self->{thlabel};
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel};
      
      my $value = '';
      if (defined($self->{threshold_use})) {
          $value = $self->{result_values}->{ $self->{threshold_use} };
      } else {
          $value = defined($self->{key_values}->[0]) ? $self->{result_values}->{ $self->{key_values}->[0]->{name} } : '';
      }
  
      return $self->{perfdata}->threshold_check(
          value => $value, threshold => [
              { label => $crit, exit_litteral => 'critical' },
              { label => $warn, exit_litteral => 'warning' },
              { label => $unkn, exit_litteral => 'unknown' }
          ]
      );
  }
  
  sub output_error {
      my ($self, %options) = @_;
  
      return sprintf($self->{output_error_template}, $self->{error_msg});
  }
  
  sub output {
      my ($self, %options) = @_;
       
      if (defined($self->{closure_custom_output})) {
          return $self->{closure_custom_output}->($self);
      }
  
      my ($value, $unit, $name) = ('', '');
      if (defined($self->{output_use})) {
          $name = $self->{output_use};
      } else {
          $name = defined($self->{key_values}->[0]) ? $self->{key_values}->[0]->{name} : undef;
      }
  
      if (defined($name)) {
          $value = $self->{result_values}->{$name};
          if ($self->{output_change_bytes} == 1) {
              ($value, $unit) = $self->{perfdata}->change_bytes(value => $value);
          } elsif ($self->{output_change_bytes} == 2) {
              ($value, $unit) = $self->{perfdata}->change_bytes(value => $value, network => 1);
          }
      }
  
      return sprintf($self->{output_template}, $value, $unit);
  }
  
  sub use_instances {
      my ($self, %options) = @_;
  
      if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
          return 1;
      }
      
      return 0;
  }
  
  sub perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_perfdata})) {
          return &{$self->{closure_custom_perfdata}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      foreach my $perf (@{$self->{perfdatas}}) {
          my ($label, $extra_label, $min, $max, $th_total) = ($self->{label}, '');
          my $cast_int = (defined($perf->{cast_int}) && $perf->{cast_int} == 1) ? 1 : 0;
          my $template = '%s';
          
          $template = $perf->{template} if (defined($perf->{template}));
          $label = $perf->{label} if (defined($perf->{label}));
          if (defined($perf->{min})) {
              $min = ($perf->{min} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{min}} : $perf->{min};
          }
          if (defined($perf->{max})) {
              $max = ($perf->{max} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{max}} : $perf->{max};
          }
          if (defined($perf->{threshold_total})) {
              $th_total = ($perf->{threshold_total} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{threshold_total}} : $perf->{threshold_total};
          }
          
          my $instances;
          if (defined($perf->{label_extra_instance}) && $perf->{label_extra_instance} == 1) {
              my $instance = '';
              if (defined($perf->{instance_use})) {
                  $instance = $self->{result_values}->{$perf->{instance_use}};
              } else {
                  $instance = $self->{instance};
              }
              
              if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
                  $instances = $instance;
              }
          }
  
          my $value = defined($perf->{value}) ? $perf->{value} : $self->{key_values}->[0]->{name};
          $self->{output}->perfdata_add(
              label => $label,
              instances => $instances,
              nlabel => $self->{nlabel},
              unit => $perf->{unit},
              value => $cast_int == 1 ? int($self->{result_values}->{$value}) : sprintf($template, $self->{result_values}->{$value}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => $warn, total => $th_total, cast_int => $cast_int),
              critical => $self->{perfdata}->get_perfdata_for_output(label => $crit, total => $th_total, cast_int => $cast_int),
              min => $min,
              max => $max
          );
      }
  }
  
  sub eval {
      my ($self, %options) = @_;
  
      if ($self->{safe_test} == 0) {
          my ($code) = centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'Safe', 
              no_quit => 1
          );
          if ($code == 0) {
              $self->{safe} = Safe->new();
              $self->{safe}->share('$values');
          }
          $self->{safe_test} = 1;
      }
  
      my $result;
      if (defined($self->{safe})) {
          our $values = $self->{result_values};
          $result = $self->{safe}->reval($options{value}, 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } else {
          my $values = $self->{result_values};
          {
              local $SIG{__WARN__} = sub {}; # ignore
              
              $result = eval "$options{value}";
              if ($@) {
                  die 'Code evaluation error: ' . $@;
              }
          }
      }
  
      return $result;
  }
  
  sub execute {
      my ($self, %options) = @_;
      my $old_datas = {};
  
      $self->{result_values} = {},
      $self->{error_msg} = undef;
      my $quit = 0;
      
      $options{new_datas} = {} if (!defined($options{new_datas}));
      foreach my $value (@{$self->{key_values}}) {
          if (!defined($options{values}->{$value->{name}}) || 
              defined($value->{no_value}) && $options{values}->{$value->{name}} eq $value->{no_value}) {
              $quit = 2;
              last;
          }
      
          if ((defined($value->{diff}) && $value->{diff} == 1) ||
              (defined($value->{per_minute}) && $value->{per_minute} == 1) ||
              (defined($value->{per_second}) && $value->{per_second} == 1)) {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              if (!defined($old_datas->{$self->{instance} . '_' . $value->{name}})) {
                  $quit = 1;
                  next;
              }
              if ($old_datas->{$self->{instance} . '_' . $value->{name}} > $options{new_datas}->{$self->{instance} . '_' . $value->{name}}) {
                  $old_datas->{$self->{instance} . '_' . $value->{name} . '_real'} = $old_datas->{$self->{instance} . '_' . $value->{name}};
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = 0;
              }
          } else {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              }
          }
      }
      
      # Very manual
      if ($self->{manual_keys} == 1) {
          foreach my $name (keys %{$options{values}}) {
              $options{new_datas}->{$self->{instance} . '_' . $name} = $options{values}->{$name};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $name} = $self->{statefile}->get(name => $self->{instance} . '_' . $name);
              }
          }
      }
  
      if ($quit == 2) {
          $self->{error_msg} = 'skipped (no value(s))';
          return NO_VALUE;
      }
  
      if (defined($self->{statefile})) {
          $self->{last_timestamp} = $self->{statefile}->get(name => 'last_timestamp');
      }
  
      if ($quit == 1) {
          $self->{error_msg} = 'Buffer creation';
          return BUFFER_CREATION;
      }
  
      my $delta_time;
      if (defined($self->{statefile}) && defined($self->{last_timestamp})) {
          $delta_time = $options{new_datas}->{last_timestamp} - $self->{last_timestamp};
          if ($delta_time <= 0) {
              $delta_time = 1;
          }
      }
  
      if (defined($self->{closure_custom_calc})) {
          return $self->{closure_custom_calc}->(
              $self,
              old_datas => $old_datas,
              new_datas => $options{new_datas},
              delta_time => $delta_time,
              extra_options => $self->{closure_custom_calc_extra_options}
          );
      }
      return $self->calc(old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time);
  }
  
  1;
  
  
CENTREON_PLUGINS_VALUES

$fatpacked{"network/forcepoint/sdwan/snmp/mode/clusterload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CLUSTERLOAD';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::clusterload;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{global} = [
          {
              label  => 'cpu-load',
              nlabel => 'cluster.cpu.load.percentage',
              set    => {
                  key_values      => [ { name => 'cluster_cpu_load' } ],
                  output_template => 'cluster cpu load: %.2f%%',
                  perfdatas       => [
                      { template => '%.2f', min => 0, max => 100, unit => '%' }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_load = '.1.3.6.1.4.1.47565.1.1.1.19.4.0';# systemLoad
      my $snmp_result = $options{snmp}->get_leef(
          oids         => [ $oid_load ],
          nothing_quit => 1
      );
  
      $self->{global} = {
          cluster_cpu_load => $snmp_result->{$oid_load}
      };
  }
  
  1;
  
  
  =head1 MODE
  
  Check cluster CPU load.
  
  =over 8
  
  
  =item B<--warning-cpu-load>
  
  Threshold in percentage.
  
  =item B<--critical-cpu-load>
  
  Threshold in percentage.
  
  =back
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CLUSTERLOAD

$fatpacked{"network/forcepoint/sdwan/snmp/mode/clusterstate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CLUSTERSTATE';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::clusterstate;
  
  use base qw(centreon::plugins::templates::counter);
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold_ng);
  
  use strict;
  use warnings;
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "Node status is '%s' [Member id: %s]",
          $self->{result_values}->{node_status},
          $self->{result_values}->{node_member_id}
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 }
      ];
  
      $self->{maps_counters}->{global} = [
          {
              label            => 'status',
              type             => 2,
              unknown_default  => '%{node_status} =~ /unknown/i',
              warning_default  => '%{node_status} =~ /lockedOnline/i',
              critical_default =>
                  '%{node_status} =~ /^(?:offline|goingOffline|lockedOffline|goingLockedOffline)$/i',
              set              =>
                  {
                      key_values                     => [ { name => 'node_status' }, { name => 'node_member_id' } ],
                      closure_custom_output          => $self->can('custom_status_output'),
                      closure_custom_threshold_check => \&catalog_status_threshold_ng
                  }
          }
      ]
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $map_oper_state = {
      0  => 'unknown',
      1  => 'online',
      2  => 'goingOnline',
      3  => 'lockedOnline',
      4  => 'goingLockedOnline',
      5  => 'offline',
      6  => 'goingOffline',
      7  => 'lockedOffline',
      8  => 'goingLockedOffline',
      9  => 'standby',
      10 => 'goingStandby'
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_nodeMemberId = '.1.3.6.1.4.1.47565.1.1.1.19.2.0';
      my $oid_nodeOperState = '.1.3.6.1.4.1.47565.1.1.1.19.3.0';
      my $snmp_result = $options{snmp}->get_leef(oids => [ $oid_nodeMemberId, $oid_nodeOperState ], nothing_quit => 1);
      $self->{global} = {
          node_status    => $map_oper_state->{ $snmp_result->{$oid_nodeOperState} },
          node_member_id => $snmp_result->{$oid_nodeMemberId}
      };
  }
  
  1;
  
  
  =head1 MODE
  
  Check status of clustered node.
  
  =over 8
  
  =item B<--warning-status>
  
  Threshold.
  Define the conditions to match for the status to be WARNING (default: '%{node_status} =~ /lockedOnline/i').
  You can use the following variables: %{node_status}, %{node_member_id}.
  
  =item B<--critical-status>
  
  Threshold.
  Define the conditions to match for the status to be CRITICAL (default: '%{node_status} =~ /^(?:offline|goingOffline|lockedOffline|goingLockedOffline)$/i').
  You can use the following variables: %{node_status}, %{node_member_id}.
  
  =item B<--unknown-status>
  
  Threshold.
  Define the conditions to match for the status to be UNKNOWN (default: '%{node_status} =~ /unknown/i').
  You can use the following variables: %{node_status}, %{node_member_id}.
  
  =back
  
  =cut
      
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CLUSTERSTATE

$fatpacked{"network/forcepoint/sdwan/snmp/mode/connections.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CONNECTIONS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::connections;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
      ];
  
      $self->{maps_counters}->{global} = [
          {
              label  => 'total-connections',
              nlabel => 'connections.total.count',
              set    => {
                  key_values      => [ { name => 'fwConnNumber' } ],
                  output_template => 'Total connections : %s',
                  perfdatas       => [
                      { label => 'total_connections', template => '%s', unit => 'con', min => 0 },
                  ],
              }
          },
          {
              label  => 'new-connections-sec',
              nlabel => 'connections.new.persecond',
              set    => {
                  key_values      => [ { name => 'fwNewConnectionsS' } ],
                  output_template => 'New Connections : %.2f /s',
                  perfdatas       => [
                      { label => 'new_connections', template => '%.2f', unit => 'con/s', min => 0 }
                  ],
              }
          },
          {
              label  => 'discarded-connections-sec',
              nlabel => 'connections.discarded.persecond',
              set    => {
                  key_values      => [ { name => 'fwDiscardedConnectionsS' } ],
                  output_template => 'Discarded Connections : %.2f /s',
                  perfdatas       => [
                      { label => 'discarded_connections', template => '%.2f', unit => 'con/s', min => 0 }
                  ],
              }
          },
          {
              label  => 'refused-connections-sec',
              nlabel => 'connections.refused.persecond',
              set    => {
                  key_values      => [ { name => 'fwRefusedConnectionsS' } ],
                  output_template => 'Refused Connections : %.2f /s',
                  perfdatas       => [
                      { label => 'refused_connections', template => '%.2f', unit => 'con/s', min => 0 }
                  ],
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      if ($options{snmp}->is_snmpv1()) {
          $self->{output}->add_option_msg(short_msg => "Need to use SNMP v2c or v3.");
          $self->{output}->option_exit();
      }
  
      my $oid_fwConnNumber = '.1.3.6.1.4.1.47565.1.1.1.4.0';
      my $oid_fwNewConnectionsS = '.1.3.6.1.4.1.47565.1.1.1.11.4.0';
      my $oid_fwDiscardedConnectionsS = '.1.3.6.1.4.1.47565.1.1.1.11.5.0';
      my $oid_fwRefusedConnectionsS = '.1.3.6.1.4.1.47565.1.1.1.11.6.0';
      my $snmp_result = $options{snmp}->get_leef(
          oids =>
              [
                  $oid_fwConnNumber,
                  $oid_fwNewConnectionsS,
                  $oid_fwDiscardedConnectionsS,
                  $oid_fwRefusedConnectionsS
              ],
          nothing_quit => 1
      );
  
      $self->{global} = {
          fwConnNumber            => $snmp_result->{$oid_fwConnNumber},
          fwNewConnectionsS       => $snmp_result->{$oid_fwNewConnectionsS},
          fwDiscardedConnectionsS => $snmp_result->{$oid_fwDiscardedConnectionsS},
          fwRefusedConnectionsS   => $snmp_result->{$oid_fwRefusedConnectionsS},
      };
  }
  
  1;
  
  
  =head1 MODE
  
  Check firewall connections.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Can be : total-connections, new-connections-sec, discarded-connections-sec, refused-connections-sec
  Example : --filter-counters='^total-connections$'
  
  =item B<--warning-total-connections>
  
  Threshold in con.
  
  =item B<--critical-total-connections>
  
  Threshold in con.
  
  =item B<--warning-discarded-connections-sec>
  
  Threshold in con/s.
  
  =item B<--critical-discarded-connections-sec>
  
  Threshold in con/s.
  
  =item B<--warning-new-connections-sec>
  
  Threshold in con/s.
  
  =item B<--critical-new-connections-sec>
  
  Threshold in con/s.
  
  =item B<--warning-refused-connections-sec>
  
  Threshold in con/s.
  
  =item B<--critical-refused-connections-sec>
  
  Threshold in con/s
  
  =back
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_CONNECTIONS

$fatpacked{"network/forcepoint/sdwan/snmp/mode/diskusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_DISKUSAGE';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::diskusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_space_usage_output {
      my ($self, %options) = @_;
  
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(
          value => $self->{result_values}->{total_space}
      );
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(
          value => $self->{result_values}->{used_space}
      );
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(
          value => $self->{result_values}->{free_space}
      );
      return sprintf(
          'space usage total: %s used: %s (%.2f%%) free: %s (%.2f%%)',
          $total_size_value . " " . $total_size_unit,
          $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used_space},
          $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free_space}
      );
  }
  
  sub prefix_disk_output {
      my ($self, %options) = @_;
  
      return "Disk '" . $options{instance} . "' ";
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'disks', type => 1, cb_prefix_output => 'prefix_disk_output', message_multiple => 'All disks are ok' }
      ];
  
      $self->{maps_counters}->{disks} = [
          {
              label  => 'space-usage',
              nlabel => 'disk.space.usage.bytes',
              set    => {
                  key_values            =>
                      [
                          { name => 'used_space' },
                          { name => 'free_space' },
                          { name => 'prct_used_space' },
                          { name => 'prct_free_space' },
                          { name => 'total_space' }
                      ],
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  perfdatas             =>
                      [
                          {
                              template             => '%d',
                              min                  => 0,
                              max                  => 'total_space',
                              unit                 => 'B',
                              cast_int             => 1,
                              label_extra_instance => 1
                          }
                      ]
              }
          },
          {
              label      => 'space-usage-free',
              nlabel     => 'disk.space.free.bytes',
              display_ok => 0,
              set        => {
                  key_values            =>
                      [
                          { name => 'free_space' },
                          { name => 'used_space' },
                          { name => 'prct_used_space' },
                          { name => 'prct_free_space' },
                          { name => 'total_space' }
                      ],
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  perfdatas             =>
                      [
                          {
                              template             => '%d',
                              min                  => 0,
                              max                  => 'total_space',
                              unit                 => 'B',
                              cast_int             => 1,
                              label_extra_instance => 1
                          }
                      ]
              }
          },
          {
              label      => 'space-usage-prct',
              nlabel     => 'disk.space.usage.percentage',
              display_ok => 0,
              set        => {
                  key_values            =>
                      [
                          { name => 'prct_used_space' },
                          { name => 'used_space' },
                          { name => 'free_space' },
                          { name => 'prct_free_space' },
                          { name => 'total_space' }
                      ],
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  perfdatas             =>
                      [
                          { template => '%.2f', min => 0, max => 100, unit => '%', label_extra_instance => 1 }
                      ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 'filter-name:s' => { name => 'filter_name' } });
  
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $mapping = {
          name  => { oid => '.1.3.6.1.4.1.47565.1.1.1.11.3.1.2' },# fwPartitionDevName
          total => { oid => '.1.3.6.1.4.1.47565.1.1.1.11.3.1.4' },# fwPartitionSize
          free  => { oid => '.1.3.6.1.4.1.47565.1.1.1.11.3.1.6' },# fwPartitionAvail
          used  => { oid => '.1.3.6.1.4.1.47565.1.1.1.11.3.1.5' }# fwPartitionUsed
      };
      my $oid_fwDiskStatsEntry = '.1.3.6.1.4.1.47565.1.1.1.11.3.1';
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids         => [
              { oid => $oid_fwDiskStatsEntry, start => $mapping->{name}->{oid}, end => $mapping->{free}->{oid} },
              { oid => $mapping->{name}->{oid} }
          ],
          return_type  => 1,
          nothing_quit => 1
      );
  
      $self->{disks} = {};
      foreach my $oid (sort keys %$snmp_result) {
          next if ($oid !~ /^$mapping->{name}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
  
          # Filter disks by partition dev name
          next if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $result->{name} !~ /$self->{option_results}->{filter_name}/);
  
          $self->{disks}->{ $result->{name} } = {
              free_space      => $result->{free},
              total_space     => $result->{total},
              used_space      => $result->{used},
              prct_used_space => $result->{used} * 100 / $result->{total},
              prct_free_space => $result->{free} * 100 / $result->{total},
          };
      }
  
      if (scalar(keys %{$self->{disks}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No disk found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check disks.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter disks by partition dev name (can be a regexp).
  
  =item B<--warning-space-usage>
  
  Threshold in bytes.
  
  =item B<--critical-space-usage>
  
  Threshold in bytes.
  
  =item B<--warning-space-usage-free>
  
  Threshold in bytes.
  
  =item B<--critical-space-usage-free>
  
  Threshold in bytes.
  
  =item B<--warning-space-usage-prct>
  
  Threshold in percentage.
  
  =item B<--critical-space-usage-prct>
  
  Threshold in percentage.
  
  =back
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_DISKUSAGE

$fatpacked{"network/forcepoint/sdwan/snmp/mode/droppedpackets.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_DROPPEDPACKETS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::droppedpackets;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub custom_drop_calc {
      my ($self, %options) = @_;
  
      # First call or reboot or counter goes back
      if (!defined($options{old_datas}->{global_dropped})
          || $options{new_datas}->{global_dropped} < $options{old_datas}->{global_dropped}
      ) {
          $self->{error_msg} = 'buffer creation';
          return -1;
      }
  
      my $dropped = $options{new_datas}->{global_dropped} - $options{old_datas}->{global_dropped};
      $self->{result_values}->{dropped_packets_per_sec} = $dropped / $options{delta_time};
  
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
      ];
  
      $self->{maps_counters}->{global} = [
          {
              label  => 'dropped-packets-sec',
              nlabel => 'dropped.packets.persecond',
              set    => {
                  key_values          => [],
                  manual_keys         => 1,
                  closure_custom_calc => $self->can('custom_drop_calc'),
                  output_template     => 'Packets Dropped : %.2f /s',
                  output_use          => 'dropped_packets_per_sec', threshold_use => 'dropped_packets_per_sec',
                  perfdatas           => [
                      { value => 'dropped_packets_per_sec', template => '%.2f', unit => 'packets/s', min => 0 }
                  ],
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      $self->{cache_policy} = centreon::plugins::statefile->new(%options);
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      if ($options{snmp}->is_snmpv1()) {
          $self->{output}->add_option_msg(short_msg => "Can't check SNMP 64 bits counters with SNMPv1.");
          $self->{output}->option_exit();
      }
  
      my $oid_fwDropped = '.1.3.6.1.4.1.47565.1.1.1.6.0';
      my $result = $options{snmp}->get_leef(oids => [ $oid_fwDropped ], nothing_quit => 1);
  
      $self->{global} = {
          dropped => $result->{$oid_fwDropped}
      };
  
      $self->{cache_name} = "forcepoint_sdwan_" . $options{snmp}->get_hostname() . '_' . $options{snmp}->get_port() . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ?
              md5_hex($self->{option_results}->{filter_counters}) :
              md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check dropped packets per second by firewall.
  
  =over 8
  
  =item B<--warning-dropped-packets-sec>
  
  Threshold in packets/s.
  
  =item B<--critical-dropped-packets-sec>
  
  Threshold in packets/s.
  
  =back
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_DROPPEDPACKETS

$fatpacked{"network/forcepoint/sdwan/snmp/mode/listdisks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_LISTDISKS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::listdisks;
  
  use strict;
  use warnings;
  
  use base qw(centreon::plugins::mode);
  
  use centreon::plugins::misc;
  
  my %map_state = (
      1 => 'online',
      2 => 'offline',
  );
  
  my $mapping = {
      hrstorageMount => { oid => '.1.3.6.1.2.1.25.3.8.1.2' },
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-name:s' => { name => 'filter_name' },
      });
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $self->{snmp}->get_table(
          oid => $mapping->{hrstorageMount}->{oid},
          dont_quit => 1
      );
      $self->{disks} = {};
  
      while (my ($oid, $value) = each %{$snmp_result}) {
          $self->{disks}->{ $oid } = { name => $value };
      }
  }
  
  # Sorts the disks hash by name
  sub _sort_output {
      my ($self, %disks) = @_;
  
      sort {
          $self->{disks}->{$a}->{name} cmp $self->{disks}->{$b}->{name}
      } keys %disks;
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
  
      foreach my $oid ($self->_sort_output(%{$self->{disks}})) {
          $self->{output}->output_add(long_msg => "[name = " . $self->{disks}->{$oid}->{name} . "]");
      }
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'List disks:'
      );
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      $self->{output}->add_disco_format(elements => ['name']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
      foreach my $oid ($self->_sort_output(%{$self->{disks}})) {
          $self->{output}->add_disco_entry(
              name => $self->{disks}->{$oid}->{name},
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List disks.
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_LISTDISKS

$fatpacked{"network/forcepoint/sdwan/snmp/mode/rejectedpackets.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_REJECTEDPACKETS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::mode::rejectedpackets;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub custom_reject_calc {
      my ($self, %options) = @_;
  
      # First call or reboot or counter goes back
      if (!defined($options{old_datas}->{global_rejected})
          || $options{new_datas}->{global_rejected} < $options{old_datas}->{global_rejected}
      ) {
          $self->{error_msg} = 'buffer creation';
          return -1;
      }
  
      my $rejected = $options{new_datas}->{global_rejected} - $options{old_datas}->{global_rejected};
      $self->{result_values}->{rejected_packets_per_sec} = $rejected / $options{delta_time};
  
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
      ];
  
      $self->{maps_counters}->{global} = [
          {
              label  => 'rejected-packets-sec',
              nlabel => 'rejected.packets.persecond',
              set    => {
                  key_values          => [],
                  manual_keys         => 1,
                  closure_custom_calc => $self->can('custom_reject_calc'),
                  output_template     => 'Packets Rejected : %.2f /s',
                  output_use          => 'rejected_packets_per_sec', threshold_use => 'rejected_packets_per_sec',
                  perfdatas           => [
                      { value => 'rejected_packets_per_sec', template => '%.2f', unit => 'packets/s', min => 0 }
                  ],
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      $self->{cache_policy} = centreon::plugins::statefile->new(%options);
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      if ($options{snmp}->is_snmpv1()) {
          $self->{output}->add_option_msg(short_msg => "Can't check SNMP 64 bits counters with SNMPv1.");
          $self->{output}->option_exit();
      }
  
      my $oid_fwRejected = '.1.3.6.1.4.1.47565.1.1.1.9.0';
      my $result = $options{snmp}->get_leef(oids => [ $oid_fwRejected ], nothing_quit => 1);
  
      $self->{global} = {
          rejected => $result->{$oid_fwRejected}
      };
  
      $self->{cache_name} = "forcepoint_sdwan_" . $options{snmp}->get_hostname() . '_' . $options{snmp}->get_port() . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ?
              md5_hex($self->{option_results}->{filter_counters}) :
              md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check rejected packets per second by firewall.
  
  =over 8
  
  =item B<--warning-rejected-packets-sec>
  
  Threshold in packets/s.
  
  =item B<--critical-rejected-packets-sec>
  
  Threshold in packets/s.
  
  =back
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_MODE_REJECTEDPACKETS

$fatpacked{"network/forcepoint/sdwan/snmp/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NETWORK_FORCEPOINT_SDWAN_SNMP_PLUGIN';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package network::forcepoint::sdwan::snmp::plugin;
  
  use strict;
  use warnings;
  use base qw(centreon::plugins::script_snmp);
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      $self->{modes} = {
          'cluster-load'     => 'network::forcepoint::sdwan::snmp::mode::clusterload',
          'cluster-state'    => 'network::forcepoint::sdwan::snmp::mode::clusterstate',
          'connections'      => 'network::forcepoint::sdwan::snmp::mode::connections',
          'cpu'              => 'snmp_standard::mode::cpu',
          'cpu-detailed'     => 'snmp_standard::mode::cpudetailed',
          'disk-usage'       => 'network::forcepoint::sdwan::snmp::mode::diskusage',
          'dropped-packets'  => 'network::forcepoint::sdwan::snmp::mode::droppedpackets',
          'interfaces'       => 'snmp_standard::mode::interfaces',
          'list-disks'       => 'network::forcepoint::sdwan::snmp::mode::listdisks',
          'list-interfaces'  => 'snmp_standard::mode::listinterfaces',
          'load'             => 'snmp_standard::mode::loadaverage',
          'memory'           => 'snmp_standard::mode::memory',
          'rejected-packets' => 'network::forcepoint::sdwan::snmp::mode::rejectedpackets',
          'storage'          => 'snmp_standard::mode::storage',
          'swap'             => 'snmp_standard::mode::swap',
          'uptime'           => 'snmp_standard::mode::uptime',
      };
  
      return $self;
  }
  
  1;
  
  
  =head1 PLUGIN DESCRIPTION
  
  Check Forcepoint SD-WAN firewall in SNMP.
  
  =cut
NETWORK_FORCEPOINT_SDWAN_SNMP_PLUGIN

$fatpacked{"snmp_standard/mode/cpu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_CPU';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::cpu;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub prefix_cpu_avg_output {
      my ($self, %options) = @_;
  
      if ($self->{cpu_avg}->{count} > 0) {
          return $self->{cpu_avg}->{count} . ' CPU(s) average usage is ';
      }
      return 'CPU(s) average usage is ';
  }
  
  sub prefix_cpu_core_output {
      my ($self, %options) = @_;
  
      return "CPU '" . $options{instance_value}->{display} . "' ";
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'cpu_avg', type => 0, cb_prefix_output => 'prefix_cpu_avg_output' },
          { name => 'cpu_core', type => 1, cb_prefix_output => 'prefix_cpu_core_output' }
      ];
  
      $self->{maps_counters}->{cpu_avg} = [
          { label => 'average', nlabel => 'cpu.utilization.percentage', set => {
                  key_values => [ { name => 'average' }, { name => 'count' } ],
                  output_template => '%.2f %%',
                  perfdatas => [
                      { label => 'total_cpu_avg', template => '%.2f', min => 0, max => 100, unit => '%' }
                  ]
              }
          }
      ];
  
      $self->{maps_counters}->{cpu_core} = [
          { label => 'core', nlabel => 'core.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpu' }, { name => 'display' } ],
                  output_template => 'usage : %.2f %%',
                  perfdatas => [
                      { label => 'cpu', template => '%.2f', min => 0, max => 100, unit => '%', label_extra_instance => 1, instance_use => 'display' }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
           'use-ucd' => { name => 'use_ucd' }
      });
  
      return $self;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{cpu_avg} = {};
      $self->{cpu_core} = {};
  
      if (defined($self->{option_results}->{use_ucd})) {
          my $oid_ssCpuIdle = '.1.3.6.1.4.1.2021.11.11.0';
          my $snmp_result = $options{snmp}->get_leef(oids => [$oid_ssCpuIdle], nothing_quit => 1);
          $self->{cpu_avg} = {
              average => 100 - $snmp_result->{$oid_ssCpuIdle},
              count => -1
          };
          return ;
      }
  
      my $oid_cputable = '.1.3.6.1.2.1.25.3.3.1.2';
      my $result = $options{snmp}->get_table(oid => $oid_cputable, nothing_quit => 1);
  
      my $cpu = 0;
      my $i = 0;
      foreach my $key ($options{snmp}->oid_lex_sort(keys %$result)) {
          $key =~ /\.([0-9]+)$/;
          my $cpu_num = $1;
  
          $cpu += $result->{$key};
          $self->{cpu_core}->{$i} = {
              display => $i,
              cpu => $result->{$key}
          };
  
          $i++;
      }
  
      my $avg_cpu = $cpu / $i;
      $self->{cpu_avg} = {
          average => $avg_cpu,
          count => $i
      };
  }
  
  1;
  
  
  =head1 MODE
  
  Check system CPUs.
  (The average, over the last minute, of the percentage
  of time that this processor was not idle)
  
  =over 8
  
  =item B<--use-ucd>
  
  Use UCD MIB for CPU average.
  
  =item B<--warning-average>
  
  Warning threshold average CPU utilization. 
  
  =item B<--critical-average>
  
  Critical  threshold average CPU utilization.
  
  =item B<--warning-core>
  
  Warning thresholds for each CPU core
  
  =item B<--critical-core>
  
  Critical thresholds for each CPU core
  
  =back
  
  =cut
SNMP_STANDARD_MODE_CPU

$fatpacked{"snmp_standard/mode/cpudetailed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_CPUDETAILED';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::cpudetailed;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub custom_cpu_calc {
      my ($self, %options) = @_;
  
      return -10 if (!defined($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}}));
      if (!defined($options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}})) {
          $self->{error_msg} = "Buffer creation";
          return -1;
      }
  
      if (!defined($self->{instance_mode}->{total_cpu})) {
          $self->{instance_mode}->{total_cpu} = 0;        
          foreach (keys %{$options{new_datas}}) {
              if (/$self->{instance}_/) {
                  my $new_total = $options{new_datas}->{$_};
                  next if (!defined($options{old_datas}->{$_}));
                  my $old_total = $options{old_datas}->{$_};
  
                  my $diff_total = $new_total - $old_total;
                  if ($diff_total < 0) {
                      $self->{instance_mode}->{total_cpu} += $old_total;
                  } else {
                      $self->{instance_mode}->{total_cpu} += $diff_total;
                  }
              }
          }
      }
  
      if ($self->{instance_mode}->{total_cpu} <= 0) {
          $self->{error_msg} = "counter not moved";
          return -12;
      }
      
      if ($options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}} > $options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}}) {
          $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}} = 0;
      }
      $self->{result_values}->{prct_used} = 
          ($options{new_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}} - 
           $options{old_datas}->{$self->{instance} . '_' . $options{extra_options}->{label_ref}}) * 100 /
          $self->{instance_mode}->{total_cpu};
      
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, cb_prefix_output => 'prefix_cpu_output', skipped_code => { -10 => 1 } },
      ];
      $self->{maps_counters}->{global} = [
          { label => 'user', nlabel => 'cpu.user.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawUser' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'User %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'nice', nlabel => 'cpu.nice.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawNice' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Nice %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'system', nlabel => 'cpu.system.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawSystem' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'System %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'idle', nlabel => 'cpu.idle.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawIdle' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Idle %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'wait', nlabel => 'cpu.wait.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawWait' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Wait %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'kernel', nlabel => 'cpu.kernel.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawKernel' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Kernel %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'interrupt', nlabel => 'cpu.interrupt.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawInterrupt' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Interrupt %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'softirq', nlabel => 'cpu.softirq.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawSoftIRQ' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Soft Irq %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'steal', nlabel => 'cpu.steal.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawSteal' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Steal %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'guest', nlabel => 'cpu.guest.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawGuest' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Guest %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
          { label => 'guestnice', nlabel => 'cpu.guestnice.utilization.percentage', set => {
                  key_values => [],
                  closure_custom_calc => $self->can('custom_cpu_calc'), closure_custom_calc_extra_options => { label_ref => 'ssCpuRawGuestNice' },
                  manual_keys => 1, 
                  threshold_use => 'prct_used', output_use => 'prct_used',
                  output_template => 'Guest Nice %.2f %%',
                  perfdatas => [
                      { value => 'prct_used', template => '%.2f', min => 0 , max => 100, unit => '%' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_cpu_output {
      my ($self, %options) = @_;
  
      return 'CPU Usage: ';
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $mapping = {
      ssCpuRawUser    => { oid => '.1.3.6.1.4.1.2021.11.50' },
      ssCpuRawNice    => { oid => '.1.3.6.1.4.1.2021.11.51' },
      ssCpuRawSystem  => { oid => '.1.3.6.1.4.1.2021.11.52' },
      ssCpuRawIdle    => { oid => '.1.3.6.1.4.1.2021.11.53' },
      ssCpuRawWait    => { oid => '.1.3.6.1.4.1.2021.11.54' },
      ssCpuRawKernel  => { oid => '.1.3.6.1.4.1.2021.11.55' },
      ssCpuRawInterrupt   => { oid => '.1.3.6.1.4.1.2021.11.56' },
      ssCpuRawSoftIRQ     => { oid => '.1.3.6.1.4.1.2021.11.61' },
      ssCpuRawSteal       => { oid => '.1.3.6.1.4.1.2021.11.64' },
      ssCpuRawGuest       => { oid => '.1.3.6.1.4.1.2021.11.65' },
      ssCpuRawGuestNice   => { oid => '.1.3.6.1.4.1.2021.11.66' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_systemStats = '.1.3.6.1.4.1.2021.11';
      my $snmp_result = $options{snmp}->get_table(
          oid => $oid_systemStats,
          start => $mapping->{ssCpuRawUser}->{oid},
          nothing_quit => 1
      );
  
      my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => '0');
  
      $self->{cache_name} = "snmpstandard_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  
      $self->{global} = { %$result };
  }
  
  1;
  
  
  =head1 MODE
  
  Check system CPUs (UCD-SNMP-MIB) (C<User>, C<Nice>, C<System>, C<Idle>, C<Wait>, C<Kernel>, C<Interrupt>, C<SoftIRQ>, C<Steal>, C<Guest>, C<GuestNice>)
  An average of all CPUs.
  
  =over 8
  
  =item B<--warning-guest>
  
  Threshold in percentage.
  
  =item B<--critical-guest>
  
  Threshold in percentage.
  
  =item B<--warning-guestnice>
  
  Threshold in percentage.
  
  =item B<--critical-guestnice>
  
  Threshold in percentage.
  
  =item B<--warning-idle>
  
  Threshold in percentage.
  
  =item B<--critical-idle>
  
  Threshold in percentage.
  
  =item B<--warning-interrupt>
  
  Threshold in percentage.
  
  =item B<--critical-interrupt>
  
  Threshold in percentage.
  
  =item B<--warning-kernel>
  
  Threshold in percentage.
  
  =item B<--critical-kernel>
  
  Threshold in percentage.
  
  =item B<--warning-nice>
  
  Threshold in percentage.
  
  =item B<--critical-nice>
  
  Threshold in percentage.
  
  =item B<--warning-softirq>
  
  Threshold in percentage.
  
  =item B<--critical-softirq>
  
  Threshold in percentage.
  
  =item B<--warning-steal>
  
  Threshold in percentage.
  
  =item B<--critical-steal>
  
  Threshold in percentage.
  
  =item B<--warning-system>
  
  Threshold in percentage.
  
  =item B<--critical-system>
  
  Threshold in percentage.
  
  =item B<--warning-user>
  
  Threshold in percentage.
  
  =item B<--critical-user>
  
  Threshold in percentage.
  
  =item B<--warning-wait>
  
  Threshold in percentage.
  
  =item B<--critical-wait>
  
  Threshold in percentage.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_CPUDETAILED

$fatpacked{"snmp_standard/mode/interfaces.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_INTERFACES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::interfaces;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::statefile;
  use Digest::MD5 qw(md5_hex);
  use Safe;
  use File::Copy qw(copy);
  
  #########################
  # Calc functions
  #########################
  sub custom_threshold_output {
      my ($self, %options) = @_;
      my $status = 'ok';
  
      if (defined($self->{instance_mode}->{option_results}->{critical_status}) && $self->{instance_mode}->{option_results}->{critical_status} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{critical_status})) {
          $status = 'critical';
      } elsif (defined($self->{instance_mode}->{option_results}->{warning_status}) && $self->{instance_mode}->{option_results}->{warning_status} ne '' &&
               $self->eval(value => $self->{instance_mode}->{option_results}->{warning_status})) {
          $status = 'warning';
      }
  
      $self->{instance_mode}->{last_status} = 1;
      if (defined($self->{instance_mode}->{option_results}->{check_metrics}) && $self->{instance_mode}->{option_results}->{check_metrics} ne '' &&
          !$self->eval(value => $self->{instance_mode}->{option_results}->{check_metrics})) {
          $self->{instance_mode}->{last_status} = 0;
      }
  
      return $status;
  }
  
  sub custom_status_output {
      my ($self, %options) = @_;
  
      my $msg = 'Status : ' . $self->{result_values}->{opstatus} . ' (admin: ' . $self->{result_values}->{admstatus} . ')';
      if (defined($self->{instance_mode}->{option_results}->{add_duplex_status})) {
          $msg .= ' (duplex: ' . $self->{result_values}->{duplexstatus} . ')';
      }
  
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{opstatus} = $options{new_datas}->{$self->{instance} . '_opstatus'};
      $self->{result_values}->{admstatus} = $options{new_datas}->{$self->{instance} . '_admstatus'};
      $self->{result_values}->{duplexstatus} = $options{new_datas}->{$self->{instance} . '_duplexstatus'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  ###############
  # Cast
  sub custom_cast_perfdata {
      my ($self, %options) = @_;
  
      if ($self->{instance_mode}->{option_results}->{units_cast} =~ /percent/) {
          my $nlabel = $self->{nlabel};
          $nlabel =~ s/count$/percentage/;
          $self->{output}->perfdata_add(
              force_new_perfdata => 1,
              nlabel             => $nlabel,
              instances          => $self->{result_values}->{display},
              value              => sprintf('%.2f', $self->{result_values}->{prct}),
              warning            => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical           => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              unit               => '%',
              min                => 0,
              max                => 100
          );
      } elsif ($self->{instance_mode}->{option_results}->{units_cast} eq 'deltaps') {
          my $nlabel = $self->{nlabel};
          $nlabel =~ s/count$/persecond/;
          $self->{output}->perfdata_add(
              force_new_perfdata => 1,
              nlabel             => $nlabel,
              instances          => $self->{result_values}->{display},
              value              => sprintf('%.2f', $self->{result_values}->{used_ps}),
              warning            => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical           => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              unit               => '/s',
              min                => 0
          );
      } else {
          $self->{output}->perfdata_add(
              force_new_perfdata => 1,
              nlabel             => $self->{nlabel},
              instances          => $self->{result_values}->{display},
              value              => $self->{result_values}->{used},
              warning            => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical           => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              min                => 0,
              max                => $self->{result_values}->{total}
          );
      }
  }
  
  sub custom_cast_threshold {
      my ($self, %options) = @_;
  
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_cast} =~ /percent/) {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{prct},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_cast} eq 'deltaps') {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{used_ps},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } else {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{used},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_cast_output {
      my ($self, %options) = @_;
  
      if ($self->{instance_mode}->{option_results}->{units_cast} eq 'deltaps') {
          return sprintf(
              '%s %s : %.2f/s (%.2f%% - %s on %s)',
              $self->{result_values}->{cast_going} eq 'i' ? 'In' : 'Out',
              ucfirst($self->{result_values}->{cast_test}),
              $self->{result_values}->{used_ps},
              $self->{result_values}->{prct},
              $self->{result_values}->{used},
              $self->{result_values}->{total}
          );
      }
  
      return sprintf(
          '%s %s : %.2f%% (%s on %s)',
          $self->{result_values}->{cast_going} eq 'i' ? 'In' : 'Out',
          ucfirst($self->{result_values}->{cast_test}),
          $self->{result_values}->{prct},
          $self->{result_values}->{used},
          $self->{result_values}->{total}
      );
  }
  
  sub custom_cast_calc {
      my ($self, %options) = @_;
  
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_cast'} ne $options{old_datas}->{$self->{instance} . '_mode_cast'}) {
          $self->{error_msg} = "buffer creation";
          return -2;
      }
  
      my $cast_diff = ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . $options{extra_options}->{cast_test} } -
                       $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . $options{extra_options}->{cast_test} });
      my $total_diff =
          ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'ucast' } - $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}
              ->{cast_going}                                                                                                           . 'ucast' })
          + ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'bcast' } - $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}
              ->{cast_going}                                                                                                             . 'bcast' })
          + ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'mcast' } - $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}
              ->{cast_going}                                                                                                             . 'mcast' });
      my $cast = $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . $options{extra_options}->{cast_test} };
      my $total =
          $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'ucast' }
          + $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'bcast' }
          + $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{cast_going} . 'mcast' };
  
      $self->{result_values}->{prct} = 0;
      $self->{result_values}->{used} = $cast_diff;
      $self->{result_values}->{total} = $total_diff;
      if ($self->{instance_mode}->{option_results}->{units_cast} eq 'percent_delta') {
          $self->{result_values}->{prct} = $cast_diff * 100 / $total_diff if ($total_diff > 0);
      } elsif ($self->{instance_mode}->{option_results}->{units_cast} eq 'percent') {
          $self->{result_values}->{prct} = $cast * 100 / $total if ($total > 0);
          $self->{result_values}->{used} = $cast;
          $self->{result_values}->{total} = $total;
      } elsif ($self->{instance_mode}->{option_results}->{units_cast} eq 'delta') {
          $self->{result_values}->{prct} = $cast_diff * 100 / $total_diff if ($total_diff > 0);
          $self->{result_values}->{used} = $cast_diff;
      } elsif ($self->{instance_mode}->{option_results}->{units_cast} eq 'deltaps') {
          $self->{result_values}->{prct} = $cast_diff * 100 / $total_diff if ($total_diff > 0);
          $self->{result_values}->{used} = $cast_diff;
          $self->{result_values}->{used_ps} = $cast_diff / $options{delta_time};
      } else {
          $self->{result_values}->{prct} = $cast_diff * 100 / $total_diff if ($total_diff > 0);
          $self->{result_values}->{used} = $cast;
          $self->{result_values}->{total} = $total;
      }
      $self->{result_values}->{cast_going} = $options{extra_options}->{cast_going};
      $self->{result_values}->{cast_test} = $options{extra_options}->{cast_test};
      $self->{result_values}->{display} = $options{new_datas}->{ $self->{instance} . '_display' };
  
      return 0;
  }
  
  ##############
  # Traffic
  sub custom_traffic_perfdata {
      my ($self, %options) = @_;
  
      if (defined($self->{instance_mode}->{option_results}->{nagvis_perfdata})) {
          $self->{result_values}->{traffic_per_seconds} /= 8;
          $self->{result_values}->{speed} /= 8 if (defined($self->{result_values}->{speed}));
      }
  
      my ($warning, $critical);
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq 'percent_delta' && defined($self->{result_values}->{speed})) {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, total => $self->{result_values}->{speed}, cast_int => 1);
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, total => $self->{result_values}->{speed}, cast_int => 1);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} =~ /bps|counter/) {
          $warning = $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel});
          $critical = $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel});
      }
  
      if (defined($self->{instance_mode}->{option_results}->{nagvis_perfdata})) {
          $self->{output}->perfdata_add(
              label     => $self->{result_values}->{label},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value     => sprintf('%.2f', $self->{result_values}->{traffic_per_seconds}),
              warning   => $warning,
              critical  => $critical,
              min       => 0,
              max       => $self->{result_values}->{speed}
          );
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'counter') {
          my $nlabel = $self->{nlabel};
          $nlabel =~ s/bitspersecond/bits/;
          $self->{output}->perfdata_add(
              force_new_perfdata => 1,
              nlabel             => $nlabel,
              unit               => 'b',
              instances          => $self->{result_values}->{display},
              value              => $self->{result_values}->{traffic_counter},
              warning            => $warning,
              critical           => $critical,
              min                => 0
          );
      } else {
          $self->{output}->perfdata_add(
              label     => 'traffic_' . $self->{result_values}->{label},
              unit      => 'b/s',
              nlabel    => $self->{nlabel},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value     => sprintf('%.2f', $self->{result_values}->{traffic_per_seconds}),
              warning   => $warning,
              critical  => $critical,
              min       => 0,
              max       => $self->{result_values}->{speed}
          );
      }
  }
  
  sub custom_traffic_threshold {
      my ($self, %options) = @_;
  
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_traffic} eq 'percent_delta' && defined($self->{result_values}->{speed})) {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{traffic_prct},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'bps') {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{traffic_per_seconds},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_traffic} eq 'counter') {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{traffic_counter},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_traffic_output {
      my ($self, %options) = @_;
  
      my ($traffic_value, $traffic_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{traffic_per_seconds}, network => 1);
      return sprintf(
          'Traffic %s : %s/s (%s)',
          ucfirst($self->{result_values}->{label}), $traffic_value . $traffic_unit,
          defined($self->{result_values}->{traffic_prct}) ? sprintf('%.2f%%', $self->{result_values}->{traffic_prct}) : '-'
      );
  }
  
  sub custom_traffic_calc {
      my ($self, %options) = @_;
  
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_traffic'} ne $options{old_datas}->{$self->{instance} . '_mode_traffic'}) {
          $self->{error_msg} = 'buffer creation';
          return -2;
      }
  
      my $diff_traffic = ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{label_ref} } - $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}
          ->{label_ref} });
      $self->{result_values}->{traffic_per_seconds} = $diff_traffic / $options{delta_time};
      $self->{result_values}->{traffic_counter} = $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{label_ref} };
      if (defined($options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}}) &&
          $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}} > 0) {
          $self->{result_values}->{traffic_prct} = $self->{result_values}->{traffic_per_seconds} * 100 / $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}};
          $self->{result_values}->{speed} = $options{new_datas}->{$self->{instance} . '_speed_' . $options{extra_options}->{label_ref}};
      }
  
      $self->{result_values}->{label} = $options{extra_options}->{label_ref};
      $self->{result_values}->{display} = $options{new_datas}->{ $self->{instance} . '_display' };
  
      if ($self->{result_values}->{traffic_prct} > 100) {
          my $time_str = time();
          # Copy statefile to a new file for debug
          my $statefile = $self->{statefile}->{statefile_dir} . '/' . $self->{statefile}->{statefile};
          copy($statefile, $statefile . '_' . $time_str . '.json') or warn "Impossible de copier $statefile to " . $statefile . ".corrupted: $!";
          # Save old and new datas to a file for debug
          my $datafile = "$self->{statefile}->{statefile_dir}/" . $self->{label} . "_" . $self->{instance} . "_" . $time_str . ".log";
          open(my $fh, '>', $datafile) or warn "Creation of $datafile failed: $!";
          print $fh "Old datas:\n", map { "$_ => $options{old_datas}->{$_}\n" } keys %{$options{old_datas}};
          print $fh "\nNew datas:\n", map { "$_ => $options{new_datas}->{$_}\n" } keys %{$options{new_datas}};
          close($fh);
          # delete the cache file
          unlink $statefile or warn "Could not delete file $statefile: $!";
          $self->{error_msg} = 'clear buffer';
          return -2;
      }
      return 0;
  }
  
  ##############
  # Errors
  sub custom_errors_perfdata {
      my ($self, %options) = @_;
  
      if ($self->{instance_mode}->{option_results}->{units_errors} =~ /percent/) {
          my $nlabel = $self->{nlabel};
          $nlabel =~ s/count$/percentage/;
          $self->{output}->perfdata_add(
              label     => 'packets_' . $self->{result_values}->{label2} . '_' . $self->{result_values}->{label1},
              unit      => '%',
              nlabel    => $nlabel,
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value     => sprintf('%.2f', $self->{result_values}->{prct}),
              warning   => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical  => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              min       => 0,
              max       => 100
          );
      } elsif ($self->{instance_mode}->{option_results}->{units_errors} eq 'deltaps') {
          my $nlabel = $self->{nlabel};
          $nlabel =~ s/count$/persecond/;
          $self->{output}->perfdata_add(
              force_new_perfdata => 1,
              nlabel             => $nlabel,
              unit               => '/s',
              instances          => $self->{result_values}->{display},
              value              => sprintf('%.2f', $self->{result_values}->{used_ps}),
              warning            => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical           => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              min                => 0
          );
      } else {
          $self->{output}->perfdata_add(
              label     => 'packets_' . $self->{result_values}->{label2} . '_' . $self->{result_values}->{label1},
              nlabel    => $self->{nlabel},
              instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
              value     => $self->{result_values}->{used},
              warning   => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
              critical  => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
              min       => 0,
              max       => $self->{result_values}->{total}
          );
      }
  }
  
  sub custom_errors_threshold {
      my ($self, %options) = @_;
  
      my $exit = 'ok';
      if ($self->{instance_mode}->{option_results}->{units_errors} =~ /percent/) {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{prct},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } elsif ($self->{instance_mode}->{option_results}->{units_errors} eq 'deltaps') {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{used_ps},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      } else {
          $exit = $self->{perfdata}->threshold_check(value     =>
                                                     $self->{result_values}->{used},
                                                     threshold =>
                                                     [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
                                                       { label => 'warning-' . $self->{thlabel}, exit_litteral => 'warning' } ]);
      }
      return $exit;
  }
  
  sub custom_errors_output {
      my ($self, %options) = @_;
  
      if ($self->{instance_mode}->{option_results}->{units_errors} eq 'deltaps') {
          return sprintf(
              'Packets %s : %.2f/s (%.2f%% - %s on %s)',
              $self->{result_values}->{label},
              $self->{result_values}->{used_ps},
              $self->{result_values}->{prct},
              $self->{result_values}->{used},
              $self->{result_values}->{total}
          );
      }
  
      return sprintf(
          'Packets %s : %.2f%% (%s on %s)',
          $self->{result_values}->{label},
          $self->{result_values}->{prct},
          $self->{result_values}->{used},
          $self->{result_values}->{total}
      );
  }
  
  sub custom_errors_calc {
      my ($self, %options) = @_;
  
      return -10 if (defined($self->{instance_mode}->{last_status}) && $self->{instance_mode}->{last_status} == 0);
      if ($options{new_datas}->{$self->{instance} . '_mode_cast'} ne $options{old_datas}->{$self->{instance} . '_mode_cast'}) {
          $self->{error_msg} = "buffer creation";
          return -2;
      }
  
      my $errors = $options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{label_ref1} . $options{extra_options}->{label_ref2} };
      my $errors_diff = ($options{new_datas}->{ $self->{instance} . '_' . $options{extra_options}->{label_ref1} . $options{extra_options}->{label_ref2} } -
                         $options{old_datas}->{ $self->{instance} . '_' . $options{extra_options}->{label_ref1} . $options{extra_options}->{label_ref2} });
      my $total = $options{new_datas}->{$self->{instance} . '_total_' . $options{extra_options}->{label_ref1} . '_packets'};
      my $total_diff = ($options{new_datas}->{$self->{instance} . '_total_' . $options{extra_options}->{label_ref1} . '_packets'} -
                        $options{old_datas}->{$self->{instance} . '_total_' . $options{extra_options}->{label_ref1} . '_packets'});
  
      $self->{result_values}->{prct} = 0;
      $self->{result_values}->{used} = $errors_diff;
      $self->{result_values}->{total} = $total_diff;
      if ($self->{instance_mode}->{option_results}->{units_errors} eq 'percent_delta') {
          $self->{result_values}->{prct} = $errors_diff * 100 / $total_diff if ($total_diff > 0);
      } elsif ($self->{instance_mode}->{option_results}->{units_errors} eq 'percent') {
          $self->{result_values}->{prct} = $errors * 100 / $total if ($total > 0);
          $self->{result_values}->{used} = $errors;
          $self->{result_values}->{total} = $total;
      } elsif ($self->{instance_mode}->{option_results}->{units_errors} eq 'delta') {
          $self->{result_values}->{prct} = $errors_diff * 100 / $total_diff if ($total_diff > 0);
          $self->{result_values}->{used} = $errors_diff;
      } elsif ($self->{instance_mode}->{option_results}->{units_errors} eq 'deltaps') {
          $self->{result_values}->{prct} = $errors_diff * 100 / $total_diff if ($total_diff > 0);
          $self->{result_values}->{used} = $errors_diff;
          $self->{result_values}->{used_ps} = $errors_diff / $options{delta_time};
      } else {
          $self->{result_values}->{prct} = $errors * 100 / $total if ($total > 0);
          $self->{result_values}->{used} = $errors;
          $self->{result_values}->{total} = $total;
      }
  
      if (defined($options{extra_options}->{label})) {
          $self->{result_values}->{label} = $options{extra_options}->{label};
      } else {
          $self->{result_values}->{label} = ucfirst($options{extra_options}->{label_ref1}) . ' ' . ucfirst($options{extra_options}->{label_ref2});
      }
      $self->{result_values}->{label1} = $options{extra_options}->{label_ref1};
      $self->{result_values}->{label2} = $options{extra_options}->{label_ref2};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
  
      if ($self->{result_values}->{prct} > 100) {
          my $time_str = time();
          # Copy statefile to a new file for debug
          my $statefile = $self->{statefile}->{statefile_dir} . '/' . $self->{statefile}->{statefile};
          copy($statefile, $statefile . '_' . $time_str . '.json') or warn "Impossible de copier $statefile to " . $statefile . ".corrupted: $!";
          # Save old and new datas to a file for debug
          my $datafile = "$self->{statefile}->{statefile_dir}/" . $self->{label} . "_" . $self->{instance} . "_" . $time_str . ".log";
          open(my $fh, '>', $datafile) or warn "Creation of $datafile failed: $!";
          print $fh "Old datas:\n", map { "$_ => $options{old_datas}->{$_}\n" } keys %{$options{old_datas}};
          print $fh "\nNew datas:\n", map { "$_ => $options{new_datas}->{$_}\n" } keys %{$options{new_datas}};
          close($fh);
          # delete the cache file
          unlink $statefile or warn "Could not delete file $statefile: $!";
          $self->{error_msg} = 'clear buffer';
          return -2;
      }
  
      return 0;
  }
  
  sub custom_speed_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{speed} = $options{new_datas}->{$self->{instance} . '_speed'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  #########################
  # OIDs mapping functions
  #########################
  
  sub set_counters_global {
      my ($self, %options) = @_;
  
      push @{$self->{maps_counters}->{global}},
           { label => 'total-port', filter => 'add_global', nlabel => 'total.interfaces.count', set => {
               key_values      => [ { name => 'total_port' } ],
               output_template => 'Total port : %s', output_error_template => 'Total port : %s',
               output_use      => 'total_port', threshold_use => 'total_port',
               perfdatas       => [
                   { label => 'total_port', value => 'total_port', template => '%s',
                     min   => 0, max => 'total_port' }
               ]
           }
           },
           { label => 'total-admin-up', filter => 'add_global', nlabel => 'total.interfaces.admin.up.count', set => {
               key_values      => [ { name => 'global_admin_up' }, { name => 'total_port' } ],
               output_template => 'AdminStatus Up : %s', output_error_template => 'AdminStatus Up : %s',
               output_use      => 'global_admin_up', threshold_use => 'global_admin_up',
               perfdatas       => [
                   { label => 'total_admin_up', template => '%s', min => 0, max => 'total_port' }
               ]
           }
           },
           { label => 'total-admin-down', filter => 'add_global', nlabel => 'total.interfaces.admin.down.count', set => {
               key_values      => [ { name => 'global_admin_down' }, { name => 'total_port' } ],
               output_template => 'AdminStatus Down : %s', output_error_template => 'AdminStatus Down : %s',
               output_use      => 'global_admin_down', threshold_use => 'global_admin_down',
               perfdatas       => [
                   { label => 'total_admin_down', template => '%s', min => 0, max => 'total_port' }
               ]
           }
           },
           { label => 'total-oper-up', filter => 'add_global', nlabel => 'total.interfaces.operational.up.count', set => {
               key_values      => [ { name => 'global_oper_up' }, { name => 'total_port' } ],
               output_template => 'OperStatus Up : %s', output_error_template => 'OperStatus Up : %s',
               output_use      => 'global_oper_up', threshold_use => 'global_oper_up',
               perfdatas       => [
                   { label => 'total_oper_up', template => '%s', min => 0, max => 'total_port' }
               ]
           }
           },
           { label => 'total-oper-down', filter => 'add_global', nlabel => 'total.interfaces.operational.down.count', set => {
               key_values      => [ { name => 'global_oper_down' }, { name => 'total_port' } ],
               output_template => 'OperStatus Down : %s', output_error_template => 'OperStatus Down : %s',
               output_use      => 'global_oper_down', threshold_use => 'global_oper_down',
               perfdatas       => [
                   { label => 'global_oper_down', template => '%s', min => 0, max => 'total_port' }
               ]
           }
           }
      ;
  }
  
  sub set_counters_status {
      my ($self, %options) = @_;
  
      push @{$self->{maps_counters}->{int}},
           { label => 'status', filter => 'add_status', threshold => 0, set => {
               key_values                     => $self->set_key_values_status(),
               closure_custom_calc            => $self->can('custom_status_calc'),
               closure_custom_output          => $self->can('custom_status_output'),
               closure_custom_perfdata        => sub { return 0; },
               closure_custom_threshold_check => $self->can('custom_threshold_output')
           }
           }
      ;
  }
  
  sub set_counters_traffic {
      my ($self, %options) = @_;
  
      return if ($self->{no_traffic} != 0 && $self->{no_set_traffic} != 0);
  
      push @{$self->{maps_counters}->{int}},
           { label => 'in-traffic', filter => 'add_traffic', nlabel => 'interface.traffic.in.bitspersecond', set => {
               key_values                     => $self->set_key_values_in_traffic(),
               closure_custom_calc            => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'in' },
               closure_custom_output          => $self->can('custom_traffic_output'), output_error_template => 'Traffic In : %s',
               closure_custom_perfdata        => $self->can('custom_traffic_perfdata'),
               closure_custom_threshold_check => $self->can('custom_traffic_threshold')
           }
           },
           { label => 'out-traffic', filter => 'add_traffic', nlabel => 'interface.traffic.out.bitspersecond', set => {
               key_values                     => $self->set_key_values_out_traffic(),
               closure_custom_calc            => $self->can('custom_traffic_calc'), closure_custom_calc_extra_options => { label_ref => 'out' },
               closure_custom_output          => $self->can('custom_traffic_output'), output_error_template => 'Traffic Out : %s',
               closure_custom_perfdata        => $self->can('custom_traffic_perfdata'),
               closure_custom_threshold_check => $self->can('custom_traffic_threshold')
           }
           }
      ;
  }
  
  sub set_counters_errors {
      my ($self, %options) = @_;
  
      return if ($self->{no_errors} != 0 && $self->{no_set_errors} != 0);
  
      push @{$self->{maps_counters}->{int}},
           { label => 'in-discard', filter => 'add_errors', nlabel => 'interface.packets.in.discard.count', set => {
               key_values                     => [ { name => 'indiscard', diff => 1 }, { name => 'total_in_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc            => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'in', label_ref2 => 'discard' },
               closure_custom_output          => $self->can('custom_errors_output'), output_error_template => 'Packets In Discard : %s',
               closure_custom_perfdata        => $self->can('custom_errors_perfdata'),
               closure_custom_threshold_check => $self->can('custom_errors_threshold')
           }
           },
           { label => 'in-error', filter => 'add_errors', nlabel => 'interface.packets.in.error.count', set => {
               key_values                     => [ { name => 'inerror', diff => 1 }, { name => 'total_in_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc            => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'in', label_ref2 => 'error' },
               closure_custom_output          => $self->can('custom_errors_output'), output_error_template => 'Packets In Error : %s',
               closure_custom_perfdata        => $self->can('custom_errors_perfdata'),
               closure_custom_threshold_check => $self->can('custom_errors_threshold')
           }
           },
           { label => 'out-discard', filter => 'add_errors', nlabel => 'interface.packets.out.discard.count', set => {
               key_values                     => [ { name => 'outdiscard', diff => 1 }, { name => 'total_out_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc            => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'out', label_ref2 => 'discard' },
               closure_custom_output          => $self->can('custom_errors_output'), output_error_template => 'Packets Out Discard : %s',
               closure_custom_perfdata        => $self->can('custom_errors_perfdata'),
               closure_custom_threshold_check => $self->can('custom_errors_threshold')
           }
           },
           { label => 'out-error', filter => 'add_errors', nlabel => 'interface.packets.out.error.count', set => {
               key_values                     => [ { name => 'outerror', diff => 1 }, { name => 'total_out_packets', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc            => $self->can('custom_errors_calc'), closure_custom_calc_extra_options => { label_ref1 => 'out', label_ref2 => 'error' },
               closure_custom_output          => $self->can('custom_errors_output'), output_error_template => 'Packets Out Error : %s',
               closure_custom_perfdata        => $self->can('custom_errors_perfdata'),
               closure_custom_threshold_check => $self->can('custom_errors_threshold')
           }
           }
      ;
  }
  
  sub set_counters_cast {
      my ($self, %options) = @_;
  
      return if ($self->{no_cast} != 0 && $self->{no_set_cast} != 0);
  
      push @{$self->{maps_counters}->{int}},
           { label => 'in-ucast', filter => 'add_cast', nlabel => 'interface.packets.in.unicast.count', set => {
               key_values                        => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'i', cast_test => 'ucast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'In Ucast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           },
           { label => 'in-bcast', filter => 'add_cast', nlabel => 'interface.packets.in.broadcast.count', set => {
               key_values                        => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'i', cast_test => 'bcast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'In Bcast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           },
           { label => 'in-mcast', filter => 'add_cast', nlabel => 'interface.packets.in.multicast.count', set => {
               key_values                        => [ { name => 'iucast', diff => 1 }, { name => 'imcast', diff => 1 }, { name => 'ibcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'i', cast_test => 'mcast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'In Mcast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           },
           { label => 'out-ucast', filter => 'add_cast', nlabel => 'interface.packets.out.unicast.count', set => {
               key_values                        => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'o', cast_test => 'ucast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'Out Ucast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           },
           { label => 'out-bcast', filter => 'add_cast', nlabel => 'interface.packets.out.broadcast.count', set => {
               key_values                        => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'o', cast_test => 'bcast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'Out Bcast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           },
           { label => 'out-mcast', filter => 'add_cast', nlabel => 'interface.packets.out.multicast.count', set => {
               key_values                        => [ { name => 'oucast', diff => 1 }, { name => 'omcast', diff => 1 }, { name => 'obcast', diff => 1 }, { name => 'display' }, { name => 'mode_cast' } ],
               closure_custom_calc               => $self->can('custom_cast_calc'),
               closure_custom_calc_extra_options => { cast_going => 'o', cast_test => 'mcast' },
               closure_custom_output             => $self->can('custom_cast_output'), output_error_template => 'Out Mcast : %s',
               closure_custom_perfdata           => $self->can('custom_cast_perfdata'),
               closure_custom_threshold_check    => $self->can('custom_cast_threshold')
           }
           }
      ;
  }
  
  sub set_counters_speed {
      my ($self, %options) = @_;
  
      return if ($self->{no_speed} != 0 && $self->{no_set_speed} != 0);
  
      push @{$self->{maps_counters}->{int}},
           { label => 'speed', filter => 'add_speed', nlabel => 'interface.speed.bitspersecond', set => {
               key_values          => [ { name => 'speed' }, { name => 'display' } ],
               closure_custom_calc => $self->can('custom_speed_calc'),
               output_template     => 'Speed : %s%s/s', output_error_template => 'Speed : %s%s/s',
               output_change_bytes => 2,
               output_use          => 'speed', threshold_use => 'speed',
               perfdatas           => [
                   { value => 'speed', template => '%s',
                     unit  => 'b/s', min => 0, label_extra_instance => 1, instance_use => 'display' }
               ]
           }
           }
      ;
  }
  
  sub set_counters_volume {
      my ($self, %options) = @_;
  
      return if ($self->{no_volume} != 0 && $self->{no_set_volume} != 0);
  
      push @{$self->{maps_counters}->{int}},
           { label => 'in-volume', filter => 'add_volume', nlabel => 'interface.volume.in.bytes', set => {
               key_values          => [ { name => 'in_volume', diff => 1 }, { name => 'display' } ],
               output_template     => 'Volume In : %.2f %s',
               output_change_bytes => 1,
               perfdatas           => [
                   { label => 'volume_in', value => 'in_volume', template => '%s',
                     unit  => 'B', min => 0, label_extra_instance => 1, instance_use => 'display' }
               ]
           }
           },
           { label => 'out-volume', filter => 'add_volume', nlabel => 'interface.volume.out.bytes', set => {
               key_values          => [ { name => 'out_volume', diff => 1 }, { name => 'display' } ],
               output_template     => 'Volume Out : %.2f %s',
               output_change_bytes => 1,
               perfdatas           => [
                   { label => 'volume_out', value => 'out_volume', template => '%s',
                     unit  => 'B', min => 0, label_extra_instance => 1, instance_use => 'display' }
               ]
           }
           }
      ;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, cb_init => 'skip_global' },
          { name             =>
            'int',
            type             =>
            1,
            cb_init          =>
            'skip_interface',
            cb_init_counters =>
            'skip_counters',
            cb_prefix_output =>
            'prefix_interface_output',
            message_multiple =>
            'All interfaces are ok',
            skipped_code     =>
            { -10 => 1 } },
      ];
  
      foreach (('traffic', 'errors', 'cast', 'speed', 'volume')) {
          $self->{'no_' . $_} = defined($options{'no_' . $_}) && $options{'no_' . $_} =~ /^[01]$/ ? $options{'no_' . $_} : 0;
          $self->{'no_set_' . $_} = defined($options{'no_set_' . $_}) && $options{'no_set_' . $_} =~ /^[01]$/ ? $options{'no_set_' . $_} : 0;
      }
  
      $self->{maps_counters} = { int => [], global => [] } if (!defined($self->{maps_counters}));
      $self->set_counters_global();
      $self->set_counters_status();
      $self->set_counters_traffic();
      $self->set_counters_errors();
      $self->set_counters_cast();
      $self->set_counters_speed();
      $self->set_counters_volume();
  }
  
  sub prefix_interface_output {
      my ($self, %options) = @_;
  
      return "Interface '" . $options{instance_value}->{display} . "'$options{instance_value}->{extra_display} "
  }
  
  sub skip_global {
      my ($self, %options) = @_;
  
      return (defined($self->{option_results}->{add_global}) ? 0 : 1);
  }
  
  sub skip_interface {
      my ($self, %options) = @_;
  
      return ($self->{checking} =~ /cast|errors|traffic|status|volume/ ? 0 : 1);
  }
  
  sub skip_counters {
      my ($self, %options) = @_;
  
      return (defined($self->{option_results}->{$options{filter}})) ? 0 : 1;
  }
  
  sub set_key_values_status {
      my ($self, %options) = @_;
  
      return [ { name => 'opstatus' }, { name => 'admstatus' }, { name => 'duplexstatus' }, { name => 'display' } ];
  }
  
  sub set_key_values_in_traffic {
      my ($self, %options) = @_;
  
      return [ { name => 'in', diff => 1 }, { name => 'speed_in' }, { name => 'display' }, { name => 'mode_traffic' } ];
  }
  
  sub set_key_values_out_traffic {
      my ($self, %options) = @_;
  
      return [ { name => 'out', diff => 1 }, { name => 'speed_out' }, { name => 'display' }, { name => 'mode_traffic' } ];
  }
  
  sub set_oids_label {
      my ($self, %options) = @_;
  
      $self->{oids_label} = {
          'ifdesc'  => { oid => '.1.3.6.1.2.1.2.2.1.2', get => 'reload_get_simple', cache => 'reload_cache_index_value' },
          'ifalias' => { oid => '.1.3.6.1.2.1.31.1.1.1.18', get => 'reload_get_simple', cache => 'reload_cache_index_value' },
          'ifname'  => { oid => '.1.3.6.1.2.1.31.1.1.1.1', get => 'reload_get_simple', cache => 'reload_cache_index_value' },
          'ipaddr'  => { oid => '.1.3.6.1.2.1.4.20.1.2', get => 'reload_get_simple', cache => 'reload_cache_values_index' }
      };
  }
  
  sub set_oids_status {
      my ($self, %options) = @_;
  
      $self->{oid_adminstatus} = '.1.3.6.1.2.1.2.2.1.7';
      $self->{oid_adminstatus_mapping} = {
          0 => 'noStatus', 1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown'
      };
      $self->{oid_opstatus} = '.1.3.6.1.2.1.2.2.1.8';
      $self->{oid_opstatus_mapping} = {
          0 => 'noStatus', 1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown'
      };
      $self->{oid_duplexstatus} = '.1.3.6.1.2.1.10.7.2.1.19';
      $self->{oid_duplexstatus_mapping} = {
          1 => 'unknown', 2 => 'halfDuplex', 3 => 'fullDuplex'
      };
  }
  
  sub set_oids_errors {
      my ($self, %options) = @_;
  
      $self->{oid_ifInDiscards} = '.1.3.6.1.2.1.2.2.1.13';
      $self->{oid_ifInErrors} = '.1.3.6.1.2.1.2.2.1.14';
      $self->{oid_ifOutDiscards} = '.1.3.6.1.2.1.2.2.1.19';
      $self->{oid_ifOutErrors} = '.1.3.6.1.2.1.2.2.1.20';
  }
  
  sub set_oids_traffic {
      my ($self, %options) = @_;
  
      $self->{oid_speed32} = '.1.3.6.1.2.1.2.2.1.5';     # in b/s
      $self->{oid_in32} = '.1.3.6.1.2.1.2.2.1.10';       # in B
      $self->{oid_out32} = '.1.3.6.1.2.1.2.2.1.16';      # in B
      $self->{oid_speed64} = '.1.3.6.1.2.1.31.1.1.1.15'; # need multiple by '1000000'
      $self->{oid_in64} = '.1.3.6.1.2.1.31.1.1.1.6';     # in B
      $self->{oid_out64} = '.1.3.6.1.2.1.31.1.1.1.10';   # in B
      $self->{oid_iftype} = '.1.3.6.1.2.1.2.2.1.3';
      $self->{oid_adslAtucCurrAttainableRate} = '.1.3.6.1.2.1.10.94.1.1.2.1.8';
      $self->{oid_adslAturCurrAttainableRate} = '.1.3.6.1.2.1.10.94.1.1.3.1.8';
      $self->{oid_xdsl2LineStatusAttainableRateDs} = '.1.3.6.1.2.1.10.251.1.1.1.1.20';
      $self->{oid_xdsl2LineStatusAttainableRateUs} = '.1.3.6.1.2.1.10.251.1.1.1.1.21';
  }
  
  sub set_oids_cast {
      my ($self, %options) = @_;
  
      # 32bits
      $self->{oid_ifInUcastPkts} = '.1.3.6.1.2.1.2.2.1.11';
      $self->{oid_ifInBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.3';
      $self->{oid_ifInMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.2';
      $self->{oid_ifOutUcastPkts} = '.1.3.6.1.2.1.2.2.1.17';
      $self->{oid_ifOutMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.4';
      $self->{oid_ifOutBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.5';
  
      # 64 bits
      $self->{oid_ifHCInUcastPkts} = '.1.3.6.1.2.1.31.1.1.1.7';
      $self->{oid_ifHCInMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.8';
      $self->{oid_ifHCInBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.9';
      $self->{oid_ifHCOutUcastPkts} = '.1.3.6.1.2.1.31.1.1.1.11';
      $self->{oid_ifHCOutMulticastPkts} = '.1.3.6.1.2.1.31.1.1.1.12';
      $self->{oid_ifHCOutBroadcastPkts} = '.1.3.6.1.2.1.31.1.1.1.13';
  }
  
  sub set_oids_speed {
      my ($self, %options) = @_;
  
      $self->{oid_speed32} = '.1.3.6.1.2.1.2.2.1.5';     # in b/s
      $self->{oid_speed64} = '.1.3.6.1.2.1.31.1.1.1.15'; # need multiple by '1000000'
  }
  
  sub check_oids_label {
      my ($self, %options) = @_;
  
      foreach (('oid_filter', 'oid_display')) {
          $self->{option_results}->{$_} = lc($self->{option_results}->{$_}) if (defined($self->{option_results}->{$_}));
          if (!defined($self->{oids_label}->{$self->{option_results}->{$_}}->{oid})) {
              my $label = $_;
              $label =~ s/_/-/g;
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --" . $label . " option.");
              $self->{output}->option_exit();
          }
      }
  
      if (defined($self->{option_results}->{oid_extra_display})) {
          $self->{option_results}->{oid_extra_display} = lc($self->{option_results}->{oid_extra_display});
          if (!defined($self->{oids_label}->{$self->{option_results}->{oid_extra_display}}->{oid})) {
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --oid-extra-display option.");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub default_check_metrics {
      my ($self, %options) = @_;
  
      return '%{opstatus} eq "up"';
  }
  
  sub default_warning_status {
      my ($self, %options) = @_;
  
      return '';
  }
  
  sub default_critical_status {
      my ($self, %options) = @_;
  
      return '%{admstatus} eq "up" and %{opstatus} ne "up"';
  }
  
  sub default_global_admin_up_rule {
      my ($self, %options) = @_;
  
      return '%{admstatus} eq "up"';
  }
  
  sub default_global_admin_down_rule {
      my ($self, %options) = @_;
  
      return '%{admstatus} ne "up"';
  }
  
  sub default_global_oper_up_rule {
      my ($self, %options) = @_;
  
      return '%{opstatus} eq "up"';
  }
  
  sub default_global_oper_down_rule {
      my ($self, %options) = @_;
  
      return '%{opstatus} ne "up"';
  }
  
  sub default_oid_filter_name {
      my ($self, %options) = @_;
  
      return 'ifname';
  }
  
  sub default_oid_display_name {
      my ($self, %options) = @_;
  
      return 'ifname';
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => defined($options{package}) ? $options{package} : __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
  
      $self->{no_oid_options} = defined($options{no_oid_options}) && $options{no_oid_options} =~ /^[01]$/ ? $options{no_oid_options} : 0;
      $self->{no_interfaceid_options} = defined($options{no_interfaceid_options}) && $options{no_interfaceid_options} =~ /^[01]$/ ?
                                        $options{no_interfaceid_options} : 0;
  
      $options{options}->add_options(arguments => {
          'add-global'               => { name => 'add_global' },
          'add-status'               => { name => 'add_status' },
          'add-duplex-status'        => { name => 'add_duplex_status' },
          'regex-id'                 => { name => 'regex_id' },
          'warning-status:s'         => { name => 'warning_status', default => $self->default_warning_status() },
          'critical-status:s'        => { name => 'critical_status', default => $self->default_critical_status() },
          'check-metrics:s'          => { name => 'check_metrics', default => $self->default_check_metrics() },
          'global-admin-up-rule:s'   => { name => 'global_admin_up_rule', default => $self->default_global_admin_up_rule() },
          'global-oper-up-rule:s'    => { name => 'global_oper_up_rule', default => $self->default_global_oper_up_rule() },
          'global-admin-down-rule:s' => { name => 'global_admin_down_rule', default => $self->default_global_admin_down_rule() },
          'global-oper-down-rule:s'  => { name => 'global_oper_down_rule', default => $self->default_global_oper_down_rule() },
          'interface:s'              => { name => 'interface' },
          'units-traffic:s'          => { name => 'units_traffic', default => 'percent_delta' },
          'units-errors:s'           => { name => 'units_errors', default => 'percent_delta' },
          'units-cast:s'             => { name => 'units_cast', default => 'percent_delta' },
          'speed:s'                  => { name => 'speed' },
          'speed-in:s'               => { name => 'speed_in' },
          'speed-out:s'              => { name => 'speed_out' },
          'no-skipped-counters'      => { name => 'no_skipped_counters' }, # legacy
          'display-transform-src:s'  => { name => 'display_transform_src' },
          'display-transform-dst:s'  => { name => 'display_transform_dst' },
          'show-cache'               => { name => 'show_cache' },
          'reload-cache-time:s'      => { name => 'reload_cache_time', default => 180 },
          'nagvis-perfdata'          => { name => 'nagvis_perfdata' },
          'force-counters32'         => { name => 'force_counters32' },
          'force-counters64'         => { name => 'force_counters64' },
          'map-speed-dsl:s@'         => { name => 'map_speed_dsl' }
      });
      if ($self->{no_traffic} == 0) {
          $options{options}->add_options(arguments => { 'add-traffic' => { name => 'add_traffic' } });
      }
      if ($self->{no_errors} == 0) {
          $options{options}->add_options(arguments => { 'add-errors' => { name => 'add_errors' } });
      }
      if ($self->{no_cast} == 0) {
          $options{options}->add_options(arguments => { 'add-cast' => { name => 'add_cast' }, });
      }
      if ($self->{no_speed} == 0) {
          $options{options}->add_options(arguments => { 'add-speed' => { name => 'add_speed' }, });
      }
      if ($self->{no_volume} == 0) {
          $options{options}->add_options(arguments => { 'add-volume' => { name => 'add_volume' }, });
      }
      if ($self->{no_oid_options} == 0) {
          $options{options}->add_options(arguments => {
              'oid-filter:s'        => { name => 'oid_filter', default => $self->default_oid_filter_name() },
              'oid-display:s'       => { name => 'oid_display', default => $self->default_oid_display_name() },
              'oid-extra-display:s' => { name => 'oid_extra_display' }
          });
      }
      if ($self->{no_interfaceid_options} == 0) {
          $options{options}->add_options(arguments => {
              'name' => { name => 'use_name' }
          });
      }
  
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
  
      $self->{safe} = Safe->new();
      $self->{safe}->share('$assign_var');
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->set_oids_label();
      $self->check_oids_label();
  
      $self->{statefile_cache}->check_options(%options);
      if (defined($self->{option_results}->{add_traffic})) {
          $self->{option_results}->{units_traffic} = 'percent_delta'
              if (!defined($self->{option_results}->{units_traffic}) ||
                  $self->{option_results}->{units_traffic} eq '' ||
                  $self->{option_results}->{units_traffic} eq '%');
          $self->{option_results}->{units_traffic} = 'bps' if ($self->{option_results}->{units_traffic} eq 'absolute'); # compat
          if ($self->{option_results}->{units_traffic} !~ /^(?:percent_delta|bps|counter)$/) {
              $self->{output}->add_option_msg(short_msg => 'Wrong option --units-traffic.');
              $self->{output}->option_exit();
          }
      }
      if (defined($self->{option_results}->{add_errors})) {
          $self->{option_results}->{units_errors} = 'percent_delta'
              if (!defined($self->{option_results}->{units_errors}) ||
                  $self->{option_results}->{units_errors} eq '' ||
                  $self->{option_results}->{units_errors} eq '%');
          $self->{option_results}->{units_errors} = 'delta' if ($self->{option_results}->{units_errors} eq 'absolute'); # compat
          if ($self->{option_results}->{units_errors} !~ /^(?:percent|percent_delta|delta|deltaps|counter)$/) {
              $self->{output}->add_option_msg(short_msg => 'Wrong option --units-errors.');
              $self->{output}->option_exit();
          }
      }
      if (defined($self->{option_results}->{add_cast})) {
          $self->{option_results}->{units_cast} = 'percent_delta'
              if (!defined($self->{option_results}->{units_cast}) || $self->{option_results}->{units_cast} eq '');
          if ($self->{option_results}->{units_cast} !~ /^(?:percent|percent_delta|delta|deltaps|counter)$/) {
              $self->{output}->add_option_msg(short_msg => 'Wrong option --units-cast.');
              $self->{output}->option_exit();
          }
      }
  
      $self->{get_speed} = 0;
      if ((!defined($self->{option_results}->{speed}) || $self->{option_results}->{speed} eq '') &&
          ((!defined($self->{option_results}->{speed_in}) || $self->{option_results}->{speed_in} eq '') ||
           (!defined($self->{option_results}->{speed_out}) || $self->{option_results}->{speed_out} eq ''))) {
          $self->{get_speed} = 1;
      } elsif (defined($self->{option_results}->{add_speed})) {
          $self->{output}->add_option_msg(short_msg => 'Cannot use option --add-speed with --speed, --speed-in or --speed-out options.');
          $self->{output}->option_exit();
      }
  
      # If no options, we set status
      if (!defined($self->{option_results}->{add_global}) &&
          !defined($self->{option_results}->{add_status}) && !defined($self->{option_results}->{add_traffic}) &&
          !defined($self->{option_results}->{add_errors}) && !defined($self->{option_results}->{add_cast})) {
          $self->{option_results}->{add_status} = 1;
      }
      $self->{checking} = '';
      foreach (('add_global', 'add_status', 'add_errors', 'add_traffic', 'add_cast', 'add_speed', 'add_volume')) {
          if (defined($self->{option_results}->{$_})) {
              $self->{checking} .= $_;
          }
      }
  
      $self->change_macros(macros => [ 'warning_status', 'critical_status' ]);
      $self->{option_results}->{check_metrics} =~ s/%\{(.*?)\}/\$values->{$1}/g;
  }
  
  sub get_display_value {
      my ($self, %options) = @_;
  
      our $assign_var = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_display} . "_" . $options{id});
      if (defined($self->{option_results}->{display_transform_src})) {
          $self->{option_results}->{display_transform_dst} = '' if (!defined($self->{option_results}->{display_transform_dst}));
  
          $self->{safe}->reval("\$assign_var =~ s{$self->{option_results}->{display_transform_src}}{$self->{option_results}->{display_transform_dst}}", 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      }
      return $assign_var;
  }
  
  sub check_oids_options_change {
      my ($self, %options) = @_;
  
      my ($regexp, $regexp_append) = ('', '');
      foreach (('oid_display', 'oid_filter', 'oid_extra_display')) {
          if (my $value = $self->{statefile_cache}->get(name => $_)) {
              $regexp .= $regexp_append . $value;
              $regexp_append = '|';
          }
      }
      foreach (('oid_display', 'oid_filter', 'oid_extra_display')) {
          if (defined($self->{option_results}->{$_}) && $self->{option_results}->{$_} !~ /^($regexp)$/i) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub reload_cache_index_value {
      my ($self, %options) = @_;
  
      my $store_index = defined($options{store_index}) && $options{store_index} == 1 ? 1 : 0;
      foreach (keys %{$options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }}) {
          /^$self->{oids_label}->{$options{name}}->{oid}\.(.*)$/;
          push @{$options{datas}->{all_ids}}, $1 if ($store_index == 1);
          $options{datas}->{$options{name} . '_' . $1} = $self->{output}->decode($options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_});
      }
  }
  
  sub reload_cache_values_index {
      my ($self, %options) = @_;
  
      my $store_index = defined($options{store_index}) && $options{store_index} == 1 ? 1 : 0;
      foreach (keys %{$options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }}) {
          /^$self->{oids_label}->{$options{name}}->{oid}\.(.*)$/;
          push @{$options{datas}->{all_ids}}, $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_} if ($store_index == 1);
          if (defined($options{datas}->{$options{name} . '_' . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}})) {
              $options{datas}->{$options{name} . '_' . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}} .= ', ' . $1;
          } else {
              $options{datas}->{$options{name} . '_' . $options{result}->{ $self->{oids_label}->{$options{name}}->{oid} }->{$_}} = $1;
          }
      }
  }
  
  sub reload_get_simple {
      my ($self, %options) = @_;
  
      $options{snmp_get}->{ $options{name} } = { oid => $self->{oids_label}->{ $options{name} }->{oid} };
  }
  
  sub reload_cache {
      my ($self) = @_;
  
      my $datas = {};
      $datas->{oid_filter} = $self->{option_results}->{oid_filter};
      $datas->{oid_display} = $self->{option_results}->{oid_display};
      $datas->{oid_extra_display} = $self->{option_results}->{oid_extra_display};
      $datas->{last_timestamp} = time();
      $datas->{all_ids} = [];
  
      my ($snmp_get, $func) = ({});
      if ($func = $self->can($self->{oids_label}->{ $self->{option_results}->{oid_filter} }->{get})) {
          $func->($self, snmp_get => $snmp_get, name => $self->{option_results}->{oid_filter});
      }
      if ($func = $self->can($self->{oids_label}->{ $self->{option_results}->{oid_display} }->{get})) {
          $func->($self, snmp_get => $snmp_get, name => $self->{option_results}->{oid_display});
      }
      if (defined($self->{option_results}->{oid_extra_display}) &&
          ($func = $self->can($self->{oids_label}->{ $self->{option_results}->{oid_extra_display} }->{get}))) {
          $func->($self, snmp_get => $snmp_get, name => $self->{option_results}->{oid_extra_display});
      }
  
      my $result = $self->{snmp}->get_multiple_table(oids => [ values %$snmp_get ]);
  
      $func = $self->can($self->{oids_label}->{ $self->{option_results}->{oid_filter} }->{cache});
      $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_filter}, store_index => 1);
  
      if (my $custom = $self->can('reload_cache_custom')) {
          $custom->($self, datas => $datas);
      }
  
      if (scalar(@{$datas->{all_ids}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "Can't construct cache...");
          $self->{output}->option_exit();
      }
  
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          $func = $self->can($self->{oids_label}->{$self->{option_results}->{oid_display}}->{cache});
          $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_display});
      }
      if (defined($self->{option_results}->{oid_extra_display}) && $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_display} &&
          $self->{option_results}->{oid_extra_display} ne $self->{option_results}->{oid_filter}) {
          $func = $self->can($self->{oids_label}->{$self->{option_results}->{oid_extra_display}}->{cache});
          $func->($self, result => $result, datas => $datas, name => $self->{option_results}->{oid_extra_display});
      }
  
      $self->{statefile_cache}->write(data => $datas);
  }
  
  sub add_selected_interface {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{id}} = { display => $self->get_display_value(id => $options{id}), extra_display => '' };
      if (defined($self->{option_results}->{oid_extra_display})) {
          my $name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_extra_display} . '_' . $options{id});
          $self->{int}->{$options{id}}->{extra_display} = ' [ ' . (defined($name) ? $name : '') . ' ]';
      }
  }
  
  sub get_selection {
      my ($self, %options) = @_;
  
      # init cache file
      my $has_cache_file = $self->{statefile_cache}->read(statefile => 'cache_snmpstandard_' . $self->{snmp}->get_hostname() . '_' . $self->{snmp}->get_port() . '_' . $self->{mode});
      if (defined($self->{option_results}->{show_cache})) {
          $self->{output}->add_option_msg(long_msg => $self->{statefile_cache}->get_string_content());
          $self->{output}->option_exit();
      }
  
      $self->{int} = {};
      my $timestamp_cache = $self->{statefile_cache}->get(name => 'last_timestamp');
  
      if ($has_cache_file == 0 || $self->check_oids_options_change() ||
          !defined($timestamp_cache) || ((time() - $timestamp_cache) > (($self->{option_results}->{reload_cache_time}) * 60))) {
          $self->reload_cache();
          $self->{statefile_cache}->read();
      }
  
      my $all_ids = $self->{statefile_cache}->get(name => 'all_ids');
      if (!defined($self->{option_results}->{use_name}) && defined($self->{option_results}->{interface})
          && $self->{no_interfaceid_options} == 0) {
  
          for my $id (@{$all_ids}) {
  
              if (defined($self->{option_results}->{regex_id})                         # with option regex_id
                  and $id =~ /$self->{option_results}->{interface}/                    # id must match the regex
                  or !defined($self->{option_results}->{regex_id})                     # without the option
                     and $self->{option_results}->{interface} =~ /(^|\s|,)$id(\s*,|$)/ # the id must be part of the list
              ) {
                  $self->add_selected_interface(id => $id);
              }
          }
      } else {
          foreach (@{$all_ids}) {
              my $filter_name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_filter} . '_' . $_);
              next if (!defined($filter_name));
              if (!defined($self->{option_results}->{interface})) {
                  $self->add_selected_interface(id => $_);
                  next;
              }
              if ($filter_name =~ /$self->{option_results}->{interface}/) {
                  $self->add_selected_interface(id => $_);
              }
          }
      }
  
      if (defined($self->{option_results}->{map_speed_dsl})) {
          $self->{map_speed_dsl} = [];
          foreach (@{$self->{option_results}->{map_speed_dsl}}) {
              my ($src, $dst) = split /,/;
              next if (!defined($dst) || $dst eq '' || !defined($src) || $src eq '');
              push @{$self->{map_speed_dsl}}, { src => $src, dst => $dst };
          }
          foreach (@{$all_ids}) {
              my $filter_name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_filter} . '_' . $_);
              for (my $i = 0; $i < scalar(@{$self->{map_speed_dsl}}); $i++) {
                  $self->{map_speed_dsl}->[$i]->{src_index} = $_ if ($filter_name =~ /$self->{map_speed_dsl}->[$i]->{src}/);
                  $self->{map_speed_dsl}->[$i]->{dst_index} = $_ if ($filter_name =~ /$self->{map_speed_dsl}->[$i]->{dst}/);
              }
          }
      }
  
      if (scalar(keys %{$self->{int}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found (maybe you should reload cache file)");
          $self->{output}->option_exit();
      }
  }
  
  sub load_status {
      my ($self, %options) = @_;
  
      $self->set_oids_status();
      my $oids = [ $self->{oid_adminstatus}, $self->{oid_opstatus} ];
      if (defined($self->{option_results}->{add_duplex_status})) {
          push @$oids, $self->{oid_duplexstatus};
      }
  
      $self->{snmp}->load(oids => $oids, instances => $self->{array_interface_selected});
  }
  
  sub load_traffic {
      my ($self, %options) = @_;
  
      $self->set_oids_traffic();
      if (!defined($self->{option_results}->{force_counters64})) {
          $self->{snmp}->load(oids => [ $self->{oid_in32}, $self->{oid_out32} ], instances => $self->{array_interface_selected});
          if ($self->{get_speed} == 1) {
              $self->{snmp}->load(oids => [ $self->{oid_speed32} ], instances => $self->{array_interface_selected});
          }
      }
  
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [ $self->{oid_in64}, $self->{oid_out64} ], instances => $self->{array_interface_selected});
          if ($self->{get_speed} == 1) {
              $self->{snmp}->load(oids => [ $self->{oid_speed64} ], instances => $self->{array_interface_selected});
          }
      }
  
      return if (!defined($self->{map_speed_dsl}));
      my $dst_indexes = [ map { $_->{dst_index} } grep { defined($_->{dst_index}) } @{$self->{map_speed_dsl}} ];
      if (scalar(@$dst_indexes) <= 0) {
          $self->{map_speed_dsl} = undef;
          return;
      }
  
      $self->{snmp}->load(oids => [ $self->{oid_iftype} ], instances => $dst_indexes);
  }
  
  sub load_errors {
      my ($self, %options) = @_;
  
      $self->set_oids_errors();
      $self->{snmp}->load(
          oids      => [
              $self->{oid_ifInDiscards}, $self->{oid_ifInErrors},
              $self->{oid_ifOutDiscards}, $self->{oid_ifOutErrors}
          ],
          instances => $self->{array_interface_selected}
      );
  }
  
  sub load_cast {
      my ($self, %options) = @_;
  
      $self->set_oids_cast();
      if (!defined($self->{option_results}->{force_counters64})) {
          $self->{snmp}->load(
              oids      => [
                  $self->{oid_ifInUcastPkts}, $self->{oid_ifInBroadcastPkts}, $self->{oid_ifInMulticastPkts},
                  $self->{oid_ifOutUcastPkts}, $self->{oid_ifOutMulticastPkts}, $self->{oid_ifOutBroadcastPkts}
              ],
              instances => $self->{array_interface_selected}
          );
      }
  
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(
              oids      => [
                  $self->{oid_ifHCInUcastPkts}, $self->{oid_ifHCInMulticastPkts}, $self->{oid_ifHCInBroadcastPkts},
                  $self->{oid_ifHCOutUcastPkts}, $self->{oid_ifHCOutMulticastPkts}, $self->{oid_ifHCOutBroadcastPkts}
              ],
              instances => $self->{array_interface_selected}
          );
      }
  }
  
  sub load_speed {
      my ($self, %options) = @_;
  
      return if (defined($self->{option_results}->{add_traffic}) && ($self->{get_speed} == 1));
  
      $self->set_oids_speed();
      $self->{snmp}->load(oids => [ $self->{oid_speed32} ], instances => $self->{array_interface_selected});
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [ $self->{oid_speed64} ], instances => $self->{array_interface_selected});
      }
  }
  
  sub load_volume {
      my ($self, %options) = @_;
  
      return if (defined($self->{option_results}->{add_traffic}));
  
      $self->set_oids_traffic();
      if (!defined($self->{option_results}->{force_counters64})) {
          $self->{snmp}->load(oids => [ $self->{oid_in32}, $self->{oid_out32} ], instances => $self->{array_interface_selected});
      }
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          $self->{snmp}->load(oids => [ $self->{oid_in64}, $self->{oid_out64} ], instances => $self->{array_interface_selected});
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $custom_load_method = $self->can('custom_load');
      my $custom_add_result_method = $self->can('custom_add_result');
  
      $self->get_selection();
      $self->{array_interface_selected} = [ keys %{$self->{int}} ];
      $self->load_status() if (defined($self->{option_results}->{add_status}) || defined($self->{option_results}->{add_global}));
      $self->load_errors() if (defined($self->{option_results}->{add_errors}));
      $self->load_traffic() if (defined($self->{option_results}->{add_traffic}));
      $self->load_cast() if ($self->{no_cast} == 0 && (defined($self->{option_results}->{add_cast}) || defined($self->{option_results}->{add_errors})));
      $self->load_speed() if (defined($self->{option_results}->{add_speed}));
      $self->load_volume() if (defined($self->{option_results}->{add_volume}));
      $self->$custom_load_method() if ($custom_load_method);
  
      $self->{results} = $self->{snmp}->get_leef();
  
      $self->pre_result();
      $self->add_result_global() if (defined($self->{option_results}->{add_global}));
      foreach (@{$self->{array_interface_selected}}) {
          $self->add_result_status(instance => $_) if (defined($self->{option_results}->{add_status}));
          $self->add_result_traffic(instance => $_) if (defined($self->{option_results}->{add_traffic}));
          $self->add_result_errors(instance => $_) if (defined($self->{option_results}->{add_errors}));
          $self->add_result_cast(instance => $_) if ($self->{no_cast} == 0 && (defined($self->{option_results}->{add_cast}) || defined($self->{option_results}->{add_errors})));
          $self->add_result_speed(instance => $_) if (defined($self->{option_results}->{add_speed}));
          $self->add_result_volume(instance => $_) if (defined($self->{option_results}->{add_volume}));
          $self->$custom_add_result_method(instance => $_) if ($custom_add_result_method);
      }
  
      $self->{cache_name} = 'snmpstandard_' . $options{snmp}->get_hostname() . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' .
                            (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all')) . '_' .
                            (defined($self->{option_results}->{interface}) ? md5_hex($self->{option_results}->{interface}) : md5_hex('all')) . '_' .
                            md5_hex($self->{checking});
  }
  
  sub add_result_global {
      my ($self, %options) = @_;
  
      foreach (('global_admin_up_rule', 'global_admin_down_rule', 'global_oper_up_rule', 'global_oper_down_rule')) {
          if (defined($self->{option_results}->{$_})) {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$values->{$1}/g;
          }
      }
  
      $self->{global} = {
          total_port     => 0, global_admin_up => 0, global_admin_down => 0,
          global_oper_up => 0, global_oper_down => 0
      };
      foreach (@{$self->{array_interface_selected}}) {
          my $values = {
              opstatus  => $self->{oid_opstatus_mapping}->{ $self->{results}->{$self->{oid_opstatus} . '.' . $_} },
              admstatus => $self->{oid_adminstatus_mapping}->{ $self->{results}->{$self->{oid_adminstatus} . '.' . $_} }
          };
          foreach (('global_admin_up', 'global_admin_down', 'global_oper_up', 'global_oper_down')) {
              if (defined($self->{option_results}->{$_ . '_rule'}) && $self->{option_results}->{$_ . '_rule'} ne '' &&
                  $self->{output}->test_eval(test => $self->{option_results}->{$_ . '_rule'}, values => $values)) {
                  $self->{global}->{$_}++;
              }
          }
          $self->{global}->{total_port}++;
      }
  }
  
  sub pre_result {
      my ($self, %options) = @_;
  
      if (defined($self->{map_speed_dsl})) {
          my $oids = [];
  
          foreach (@{$self->{map_speed_dsl}}) {
              next if (!defined($_->{dst_index}));
              next if (!defined($self->{results}->{ $self->{oid_iftype} . '.' . $_->{dst_index} }));
              # 94 = adsl, 251 => vdsl2
              if ($self->{results}->{ $self->{oid_iftype} . '.' . $_->{dst_index} } == 94) {
                  push @$oids, $self->{oid_adslAtucCurrAttainableRate} . '.' . $_->{dst_index}, $self->{oid_adslAturCurrAttainableRate} . '.' . $_->{dst_index};
              } elsif ($self->{results}->{ $self->{oid_iftype} . '.' . $_->{dst_index} } == 251) {
                  push @$oids, $self->{oid_xdsl2LineStatusAttainableRateDs} . '.' . $_->{dst_index}, $self->{oid_xdsl2LineStatusAttainableRateUs} . '.' . $_->{dst_index};
              }
          }
  
          if (scalar(@$oids) > 0) {
              my $results = $self->{snmp}->get_leef(oids => $oids);
              for (my $i = 0; $i < scalar(@{$self->{map_speed_dsl}}); $i++) {
                  next if (!defined($self->{map_speed_dsl}->[$i]->{dst_index}));
                  next if (!defined($self->{results}->{ $self->{oid_iftype} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }));
                  # 94 = adsl, 251 => vdsl2
                  if ($self->{results}->{ $self->{oid_iftype} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} } == 94) {
                      $self->{map_speed_dsl}->[$i]->{speed_in} = $results->{ $self->{oid_adslAturCurrAttainableRate} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }
                          if (defined($results->{ $self->{oid_adslAturCurrAttainableRate} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }));
                      $self->{map_speed_dsl}->[$i]->{speed_out} = $results->{ $self->{oid_adslAtucCurrAttainableRate} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }
                          if (defined($results->{ $self->{oid_adslAtucCurrAttainableRate} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }));
                  } elsif ($self->{results}->{ $self->{oid_iftype} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} } == 251) {
                      $self->{map_speed_dsl}->[$i]->{speed_in} = $results->{ $self->{oid_xdsl2LineStatusAttainableRateDs} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }
                          if (defined($results->{ $self->{oid_xdsl2LineStatusAttainableRateDs} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }));
                      $self->{map_speed_dsl}->[$i]->{speed_out} = $results->{ $self->{oid_xdsl2LineStatusAttainableRateUs} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }
                          if (defined($results->{ $self->{oid_xdsl2LineStatusAttainableRateUs} . '.' . $self->{map_speed_dsl}->[$i]->{dst_index} }));
                  }
              }
          }
      }
  }
  
  sub add_result_status {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{instance}}->{opstatus} = defined($self->{results}->{$self->{oid_opstatus} . '.' . $options{instance}})
                                                       ? $self->{oid_opstatus_mapping}->{$self->{results}->{                                          $self
                                                                                                                                                          ->{oid_opstatus} . '.' . $options{instance}}}
                                                       : undef;
      $self->{int}->{$options{instance}}->{admstatus} = defined($self->{results}->{$self->{oid_adminstatus} . '.' . $options{instance}})
                                                        ? $self->{oid_adminstatus_mapping}->{$self->{results}->{                                                $self
                                                                                                                                                                    ->{oid_adminstatus} . '.' . $options{instance}}}
                                                        : undef;
      $self->{int}->{$options{instance}}->{duplexstatus} =          defined($self->{results}->{$self->{oid_duplexstatus} . '.' . $options{instance}}) ? $self->{oid_duplexstatus_mapping}->{$self
          ->{results}
          ->{$self->{oid_duplexstatus} . '.' . $options{instance}}} : 'n/a';
  }
  
  sub add_result_errors {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{instance}}->{indiscard} = $self->{results}->{$self->{oid_ifInDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{inerror} = $self->{results}->{$self->{oid_ifInErrors} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outdiscard} = $self->{results}->{$self->{oid_ifOutDiscards} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{outerror} = $self->{results}->{$self->{oid_ifOutErrors} . '.' . $options{instance}};
  }
  
  sub add_result_traffic {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{instance}}->{mode_traffic} = 32;
      $self->{int}->{$options{instance}}->{in} = $self->{results}->{$self->{oid_in32} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{out} = $self->{results}->{$self->{oid_out32} . '.' . $options{instance}};
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          if (defined($self->{results}->{$self->{oid_in64} . '.' . $options{instance}}) && $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} ne '' &&
              ($self->{results}->{$self->{oid_in64} . '.' . $options{instance}} != 0 || defined($self->{option_results}->{force_counters64}))) {
              $self->{int}->{$options{instance}}->{mode_traffic} = 64;
              $self->{int}->{$options{instance}}->{in} = $self->{results}->{$self->{oid_in64} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{out} = $self->{results}->{$self->{oid_out64} . '.' . $options{instance}};
          }
      }
      $self->{int}->{$options{instance}}->{in} *= 8 if (defined($self->{int}->{$options{instance}}->{in}));
      $self->{int}->{$options{instance}}->{out} *= 8 if (defined($self->{int}->{$options{instance}}->{out}));
  
      $self->{int}->{$options{instance}}->{speed_in} = 0;
      $self->{int}->{$options{instance}}->{speed_out} = 0;
      if ($self->{get_speed} == 0) {
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed} * 1000000;
              $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed} * 1000000;
          }
          $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed_in} * 1000000 if (defined($self->{option_results}->{speed_in}) && $self->{option_results}->{speed_in} ne '');
          $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed_out} * 1000000 if (defined($self->{option_results}->{speed_out}) && $self->{option_results}->{speed_out}
                                                                                                                                                                ne '');
      } else {
          my $interface_speed = 0;
          if (defined($self->{results}->{$self->{oid_speed64} . '.' . $options{instance}}) && $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} ne '') {
              $interface_speed = $self->{results}->{$self->{oid_speed64} . '.' . $options{instance}} * 1000000;
              # If 0, we put the 32 bits
              if ($interface_speed == 0 && !defined($self->{option_results}->{force_counters64})) {
                  $interface_speed = $self->{results}->{$self->{oid_speed32} . '.' . $options{instance}};
              }
          } else {
              $interface_speed = $self->{results}->{$self->{oid_speed32} . '.' . $options{instance}};
          }
  
          $self->{int}->{$options{instance}}->{speed_in} = $interface_speed;
          $self->{int}->{$options{instance}}->{speed_out} = $interface_speed;
  
          if (defined($self->{map_speed_dsl})) {
              foreach (@{$self->{map_speed_dsl}}) {
                  next if (!defined($_->{src_index}) || $_->{src_index} != $options{instance});
                  $self->{int}->{$options{instance}}->{speed_in} = $_->{speed_in} if (defined($_->{speed_in}));
                  $self->{int}->{$options{instance}}->{speed_out} = $_->{speed_out} if (defined($_->{speed_out}));
              }
          }
  
          $self->{int}->{$options{instance}}->{speed_in} = $self->{option_results}->{speed_in} * 1000000 if (defined($self->{option_results}->{speed_in}) && $self->{option_results}->{speed_in} ne '');
          $self->{int}->{$options{instance}}->{speed_out} = $self->{option_results}->{speed_out} * 1000000 if (defined($self->{option_results}->{speed_out}) && $self->{option_results}->{speed_out}
                                                                                                                                                                ne '');
      }
  }
  
  sub add_result_cast {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{instance}}->{mode_cast} = 32;
      $self->{int}->{$options{instance}}->{iucast} = $self->{results}->{$self->{oid_ifInUcastPkts} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{ibcast} = defined($self->{results}->{$self->{oid_ifInBroadcastPkts} . '.' . $options{instance}})
                                                     ? $self->{results}->{                                                            $self
                                                                                                                                          ->{oid_ifInBroadcastPkts} . '.' . $options{instance}}
                                                     : 0;
      $self->{int}->{$options{instance}}->{imcast} = defined($self->{results}->{$self->{oid_ifInMulticastPkts} . '.' . $options{instance}})
                                                     ? $self->{results}->{                                                            $self
                                                                                                                                          ->{oid_ifInMulticastPkts} . '.' . $options{instance}}
                                                     : 0;
      $self->{int}->{$options{instance}}->{oucast} = $self->{results}->{$self->{oid_ifOutUcastPkts} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{omcast} = defined($self->{results}->{$self->{oid_ifOutMulticastPkts} . '.' . $options{instance}})
                                                     ? $self->{results}->{                                                              $self
                                                                                                                                            ->{oid_ifOutMulticastPkts} . '.' . $options{instance}}
                                                     : 0;
      $self->{int}->{$options{instance}}->{obcast} = defined($self->{results}->{$self->{oid_ifOutBroadcastPkts} . '.' . $options{instance}})
                                                     ? $self->{results}->{                                                              $self
                                                                                                                                            ->{oid_ifOutBroadcastPkts} . '.' . $options{instance}}
                                                     : 0;
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          my $iucast = $self->{results}->{$self->{oid_ifHCInUcastPkts} . '.' . $options{instance}};
  
          if (defined($iucast) && $iucast ne '' &&
              ($iucast != 0 || defined($self->{option_results}->{force_counters64}))) {
              $self->{int}->{$options{instance}}->{iucast} = $iucast;
              $self->{int}->{$options{instance}}->{imcast} = defined($self->{results}->{$self->{oid_ifHCInMulticastPkts} . '.' . $options{instance}})
                                                             ? $self->{results}->{                                                                $self
                                                                                                                                                      ->{oid_ifHCInMulticastPkts} . '.' . $options{instance}}
                                                             : 0;
              $self->{int}->{$options{instance}}->{ibcast} = defined($self->{results}->{$self->{oid_ifHCInBroadcastPkts} . '.' . $options{instance}})
                                                             ? $self->{results}->{                                                                $self
                                                                                                                                                      ->{oid_ifHCInBroadcastPkts} . '.' . $options{instance}}
                                                             : 0;
              $self->{int}->{$options{instance}}->{oucast} = $self->{results}->{$self->{oid_ifHCOutUcastPkts} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{omcast} = defined($self->{results}->{$self->{oid_ifHCOutMulticastPkts} . '.' . $options{instance}})
                                                             ? $self->{results}->{                                                                  $self
                                                                                                                                                        ->{oid_ifHCOutMulticastPkts} . '.' . $options{instance}}
                                                             : 0;
              $self->{int}->{$options{instance}}->{obcast} = defined($self->{results}->{$self->{oid_ifHCOutBroadcastPkts} . '.' . $options{instance}})
                                                             ? $self->{results}->{                                                                  $self
                                                                                                                                                        ->{oid_ifHCOutBroadcastPkts} . '.' . $options{instance}}
                                                             : 0;
              $self->{int}->{$options{instance}}->{mode_cast} = 64;
          }
      }
  
      foreach (('iucast', 'imcast', 'ibcast', 'oucast', 'omcast', 'obcast')) {
          $self->{int}->{$options{instance}}->{$_} = 0 if (!defined($self->{int}->{$options{instance}}->{$_}));
      }
  
      # https://tools.ietf.org/html/rfc3635 : The IF-MIB octet counters
      # count the number of octets sent to or received from the layer below
      # this interface, whereas the packet counters count the number of
      # packets sent to or received from the layer above.  Therefore,
      # received MAC Control frames, ifInDiscards, and ifInUnknownProtos are
      # counted by ifInOctets, but not ifInXcastPkts.  Transmitted MAC
      # Control frames are counted by ifOutOctets, but not ifOutXcastPkts.
      # ifOutDiscards and ifOutErrors are counted by ifOutXcastPkts, but not
      # ifOutOctets.
      $self->{int}->{$options{instance}}->{total_in_packets} = $self->{int}->{$options{instance}}->{iucast} + $self->{int}->{$options{instance}}->{imcast} + $self->{int}->{$options{instance}}->{ibcast};
      if (defined($self->{int}->{$options{instance}}->{indiscard})) {
          $self->{int}->{$options{instance}}->{total_in_packets} += $self->{int}->{$options{instance}}->{indiscard};
      }
      $self->{int}->{$options{instance}}->{total_out_packets} = $self->{int}->{$options{instance}}->{oucast} + $self->{int}->{$options{instance}}->{omcast} + $self
          ->{int}
          ->{$options{instance}}
          ->{obcast};
  }
  
  sub add_result_speed {
      my ($self, %options) = @_;
  
      my $interface_speed = 0;
      if (defined($self->{results}->{$self->{oid_speed64} . "." . $options{instance}}) && $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} ne '') {
          $interface_speed = $self->{results}->{$self->{oid_speed64} . "." . $options{instance}} * 1000000;
          # If 0, we put the 32 bits
          if ($interface_speed == 0 && !defined($self->{option_results}->{force_counters64})) {
              $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
          }
      } else {
          $interface_speed = $self->{results}->{$self->{oid_speed32} . "." . $options{instance}};
      }
  
      $self->{int}->{$options{instance}}->{speed} = $interface_speed;
  }
  
  sub add_result_volume {
      my ($self, %options) = @_;
  
      $self->{int}->{$options{instance}}->{mode_traffic} = 32;
      $self->{int}->{$options{instance}}->{in_volume} = $self->{results}->{$self->{oid_in32} . '.' . $options{instance}};
      $self->{int}->{$options{instance}}->{out_volume} = $self->{results}->{$self->{oid_out32} . '.' . $options{instance}};
      if (!$self->{snmp}->is_snmpv1() && !defined($self->{option_results}->{force_counters32})) {
          if (defined($self->{results}->{$self->{oid_in64} . '.' . $options{instance}}) && $self->{results}->{$self->{oid_in64} . '.' . $options{instance}} ne '' &&
              ($self->{results}->{$self->{oid_in64} . '.' . $options{instance}} != 0 || defined($self->{option_results}->{force_counters64}))) {
              $self->{int}->{$options{instance}}->{mode_traffic} = 64;
              $self->{int}->{$options{instance}}->{in_volume} = $self->{results}->{$self->{oid_in64} . '.' . $options{instance}};
              $self->{int}->{$options{instance}}->{out_volume} = $self->{results}->{$self->{oid_out64} . '.' . $options{instance}};
          }
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check interfaces.
  
  =over 8
  
  =item B<--add-global>
  
  Check global port statistics (by default if no --add-* option is set).
  
  =item B<--add-status>
  
  Check interface status.
  
  =item B<--add-duplex-status>
  
  Check duplex status (with --warning-status and --critical-status).
  
  =item B<--add-traffic>
  
  Check interface traffic.
  
  =item B<--add-errors>
  
  Check interface errors.
  
  =item B<--add-cast>
  
  Check interface cast.
  
  =item B<--add-speed>
  
  Check interface speed.
  
  =item B<--add-volume>
  
  Check interface data volume between two checks (not supposed to be graphed, useful for BI reporting).
  
  =item B<--check-metrics>
  
  If the expression is true, metrics are checked (default: '%{opstatus} eq "up"').
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING.
  You can use the following variables: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{admstatus} eq "up" and %{opstatus} ne "up"').
  You can use the following variables: %{admstatus}, %{opstatus}, %{duplexstatus}, %{display}
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'total-port', 'total-admin-up', 'total-admin-down', 'total-oper-up', 'total-oper-down',
  'in-traffic', 'out-traffic', 'in-error', 'in-discard', 'out-error', 'out-discard',
  'in-ucast', 'in-bcast', 'in-mcast', 'out-ucast', 'out-bcast', 'out-mcast',
  'speed' (b/s).
  
  =item B<--units-traffic>
  
  Units of thresholds for the traffic (default: 'percent_delta') ('percent_delta', 'bps', 'counter').
  
  =item B<--units-errors>
  
  Units of thresholds for errors/discards (default: 'percent_delta') ('percent_delta', 'percent', 'delta', 'deltaps', 'counter').
  
  =item B<--units-cast>
  
  Units of thresholds for communication types (default: 'percent_delta') ('percent_delta', 'percent', 'delta', 'deltaps', 'counter').
  
  =item B<--nagvis-perfdata>
  
  Display traffic perfdata to be compatible with NagVis widget.
  
  =item B<--interface>
  
  Check only the interfaces with the specified IDs (OID indexes, e.g.: 1,2,...). If empty, all interfaces will be monitored.
  To filter on interface names, see --name.
  
  =item B<--name>
  
  With this option, the interfaces will be filtered by name (given in option --interface) instead of OID index. The name matching mode supports regular expressions.
  
  =item B<--regex-id>
  
  With this option, interface IDs will be filtered using the --interface parameter as a regular expression instead of a list of IDs.
  
  =item B<--speed>
  
  Set interface speed for incoming/outgoing traffic (in Mb).
  
  =item B<--speed-in>
  
  Set interface speed for incoming traffic (in Mb).
  
  =item B<--speed-out>
  
  Set interface speed for outgoing traffic (in Mb).
  
  =item B<--map-speed-dsl>
  
  Get interface speed configuration for interfaces of type 'ADSL' and 'VDSL2'.
  
  Syntax: --map-speed-dsl=interface-src-name,interface-dsl-name
  
  E.g: --map-speed-dsl=Et0.835,Et0-vdsl2
  
  =item B<--force-counters64>
  
  Force to use 64 bits counters only. Can be used to improve performance.
  
  =item B<--force-counters32>
  
  Force to use 32-bit counters (even with SNMP versions 2c and 3). To use when 64 bits counters are buggy.
  
  =item B<--reload-cache-time>
  
  Time in minutes before reloading cache file (default: 180).
  
  =item B<--oid-filter>
  
  Define the OID to be used to filter interfaces (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-display>
  
  Define the OID that will be used to name the interfaces (default: ifName) (values: ifDesc, ifAlias, ifName, IpAddr).
  
  =item B<--oid-extra-display>
  
  Add an OID to display.
  
  =item B<--display-transform-src> B<--display-transform-dst>
  
  Modify the interface name displayed by using a regular expression.
  
  Example: adding --display-transform-src='eth' --display-transform-dst='ens'  will replace all occurrences of 'eth' with 'ens'
  
  =item B<--show-cache>
  
  Display cache interface data.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_INTERFACES

$fatpacked{"snmp_standard/mode/listinterfaces.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_LISTINTERFACES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::listinterfaces;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use Safe;
  use snmp_standard::mode::resources::types qw($map_iftype);
  
  my $oid_speed32 = '.1.3.6.1.2.1.2.2.1.5'; # in b/s
  my $oid_speed64 = '.1.3.6.1.2.1.31.1.1.1.15';
  
  sub set_oids_status {
      my ($self, %options) = @_;
  
      $self->{oid_adminstatus} = '.1.3.6.1.2.1.2.2.1.7';
      $self->{oid_adminstatus_mapping} = {
          0 => 'noStatus', 1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown'
      };
      $self->{oid_opstatus} = '.1.3.6.1.2.1.2.2.1.8';
      $self->{oid_opstatus_mapping} = {
          0 => 'noStatus', 1 => 'up', 2 => 'down', 3 => 'testing', 4 => 'unknown', 5 => 'dormant', 6 => 'notPresent', 7 => 'lowerLayerDown'
      };
      $self->{oid_mac_address} = '.1.3.6.1.2.1.2.2.1.6';
      $self->{oid_iftype} = '.1.3.6.1.2.1.2.2.1.3';
  }
  
  sub check_oids_label {
      my ($self, %options) = @_;
  
      foreach (('oid_filter', 'oid_display')) {
          $self->{option_results}->{$_} = lc($self->{option_results}->{$_}) if (defined($self->{option_results}->{$_}));
          if (!defined($self->{oids_label}->{$self->{option_results}->{$_}})) {
              my $label = $_;
              $label =~ s/_/-/g;
              $self->{output}->add_option_msg(short_msg => "Unsupported oid in --" . $label . " option.");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub set_oids_label {
      my ($self, %options) = @_;
  
      $self->{oids_label} = {
          'ifdesc' => '.1.3.6.1.2.1.2.2.1.2',
          'ifalias' => '.1.3.6.1.2.1.31.1.1.1.18',
          'ifname' => '.1.3.6.1.2.1.31.1.1.1.1'
      };
  }
  
  sub default_oid_filter_name {
      my ($self, %options) = @_;
  
      return 'ifname';
  }
  
  sub default_oid_display_name {
      my ($self, %options) = @_;
  
      return 'ifname';
  }
  
  sub is_admin_status_down {
      my ($self, %options) = @_;
  
      if (defined($self->{option_results}->{use_adminstatus}) && defined($options{admin_status}) && 
          $self->{oid_adminstatus_mapping}->{$options{admin_status}} ne 'up') {
          return 1;
      }
      return 0;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => defined($options{package}) ? $options{package} : __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{no_speed} = defined($options{no_speed}) && $options{no_speed} =~ /^[01]$/ ? $options{no_speed} : 0;
      $options{options}->add_options(arguments => { 
          'name'                    => { name => 'use_name' },
          'interface:s'             => { name => 'interface' },
          'speed:s'                 => { name => 'speed' },
          'filter-status:s'         => { name => 'filter_status' },
          'skip-speed0'             => { name => 'skip_speed0' },
          'use-adminstatus'         => { name => 'use_adminstatus' },
          'oid-filter:s'            => { name => 'oid_filter', default => $self->default_oid_filter_name() },
          'oid-display:s'           => { name => 'oid_display', default => $self->default_oid_display_name() },
          'display-transform-src:s' => { name => 'display_transform_src' },
          'display-transform-dst:s' => { name => 'display_transform_dst' },
          'add-extra-oid:s@'        => { name => 'add_extra_oid' },
          'add-mac-address'         => { name => 'add_mac_address' }
      });
  
      $self->{interface_id_selected} = [];
  
      $self->{safe} = Safe->new();
      $self->{safe}->share('$assign_var');
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      $self->set_oids_label();
      $self->check_oids_label();
      $self->set_oids_status();
  
      $self->{extra_oids} = {};
      foreach (@{$self->{option_results}->{add_extra_oid}}) {
          next if ($_ eq '');
          my ($name, $oid, $matching) = split /,/;
          $matching = '%{instance}$' if (!defined($matching));
          if (!defined($oid) || $oid !~ /^(\.\d+){1,}$/ || $name eq '') {
              $self->{output}->add_option_msg(short_msg => "Wrong syntax for add-extra-oid '" . $_ . "' option.");
              $self->{output}->option_exit();
          }
          $self->{extra_oids}->{$name} = { oid => $oid, matching => $matching };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
      my $result = $self->get_additional_information();
      foreach (sort @{$self->{interface_id_selected}}) {
          my $display_value = $self->get_display_value(id => $_);
  
          my $interface_speed = 0;
          if ($self->{no_speed} == 0) {
              $interface_speed = (defined($result->{$oid_speed64 . "." . $_}) && $result->{$oid_speed64 . "." . $_} ne '' && $result->{$oid_speed64 . "." . $_} != 0) ? 
                                  ($result->{$oid_speed64 . "." . $_}) : 
                                      (defined($result->{$oid_speed32 . "." . $_}) && $result->{$oid_speed32 . "." . $_} ne '' && $result->{$oid_speed32 . "." . $_} != 0 ?
                                          (sprintf("%g", $result->{$oid_speed32 . "." . $_} / 1000 / 1000)) : '');
          }
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $interface_speed = $self->{option_results}->{speed};
          }
  
          if (defined($self->{option_results}->{skip_speed0}) && ($interface_speed eq '' || $interface_speed == 0)) {
              $self->{output}->output_add(long_msg => "skipping interface '" . $display_value . "': interface speed is 0 and option --skip-speed0 is set");
              next;
          }
          if (defined($self->{option_results}->{filter_status}) && defined($result->{$self->{oid_opstatus} . "." . $_}) && 
              $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} !~ /$self->{option_results}->{filter_status}/i) {
              $self->{output}->output_add(long_msg => "skipping interface '" . $display_value . "': no matching filter status");
              next;
          }
          if ($self->is_admin_status_down(admin_status => $result->{$self->{oid_adminstatus} . "." . $_})) {
              $self->{output}->output_add(long_msg => "skipping interface '" . $display_value . "': adminstatus is not 'up' and option --use-adminstatus is set");
              next;
          }
  
          my $extra_values = $self->get_extra_values_by_instance(result => $result, instance => $_);
          my $extra_display = '';
          foreach my $name (keys %{$extra_values}) {
              $extra_display .= '[' . $name . ' = ' . $extra_values->{$name} . ']';
          }
          if (defined($self->{oid_iftype})) {
              $extra_display .= sprintf(
                  '[type = %s]',
                  defined($result->{ $self->{oid_iftype} . '.' . $_}) && defined($map_iftype->{ $result->{ $self->{oid_iftype} . '.' . $_ } }) ?
                      $map_iftype->{ $result->{ $self->{oid_iftype} . '.' . $_ } } :
                      'unknown' 
              );
          }
  
          $self->{output}->output_add(
              long_msg => sprintf(
                  "'%s' [speed = %s][status = %s][id = %s]%s",
                  $display_value,
                  $interface_speed,
                  (defined($result->{$self->{oid_opstatus} . "." . $_}) ?  $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} : ''),
                  $_,
                  $extra_display
              )
          );
      }
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'List interfaces:'
      );
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub get_additional_information {
      my ($self, %options) = @_;
  
      my $oids = [];
      push @$oids, $self->{oid_adminstatus} if (defined($self->{oid_adminstatus}));
      push @$oids, $self->{oid_opstatus} if (defined($self->{oid_opstatus}));
      push @$oids, $self->{oid_mac_address} if (defined($self->{option_results}->{add_mac_address}));
      push @$oids, $self->{oid_iftype} if (defined($self->{oid_iftype}));
      push @$oids, $oid_speed32 if ($self->{no_speed} == 0);
      push @$oids, $oid_speed64 if (!$self->{snmp}->is_snmpv1() && $self->{no_speed} == 0);
  
      $self->{snmp}->load(oids => $oids, instances => $self->{interface_id_selected});
      return $self->{snmp}->get_leef();
  }
  
  sub get_display_value {
      my ($self, %options) = @_;
  
      our $assign_var = $self->{datas}->{$self->{option_results}->{oid_display} . '_' . $options{id}};
      if (defined($self->{option_results}->{display_transform_src})) {
          $self->{option_results}->{display_transform_dst} = '' if (!defined($self->{option_results}->{display_transform_dst}));
  
          $self->{safe}->reval("\$assign_var =~ s{$self->{option_results}->{display_transform_src}}{$self->{option_results}->{display_transform_dst}}", 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      }
  
      return $assign_var;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oids = [{ oid => $self->{oids_label}->{$self->{option_results}->{oid_filter}} }];
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          push @$oids, { oid => $self->{oids_label}->{$self->{option_results}->{oid_display}} };
      }
      if (scalar(keys %{$self->{extra_oids}}) > 0) {
          foreach (keys %{$self->{extra_oids}}) {
              push @$oids, { oid => $self->{extra_oids}->{$_}->{oid} };
          }
      }
  
      $self->{datas} = {};
      $self->{results} = $self->{snmp}->get_multiple_table(oids => $oids);
      $self->{datas}->{all_ids} = [];
      foreach my $key ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{ $self->{oids_label}->{$self->{option_results}->{oid_filter}} }})) {
          next if ($key !~ /^$self->{oids_label}->{$self->{option_results}->{oid_filter}}\.(.*)$/);
          $self->{datas}->{$self->{option_results}->{oid_filter} . "_" . $1} = $self->{output}->decode($self->{results}->{$self->{oids_label}->{ $self->{option_results}->{oid_filter}} }->{$key});
          push @{$self->{datas}->{all_ids}}, $1;
      }
  
      if (scalar(@{$self->{datas}->{all_ids}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "Can't get interfaces...");
          $self->{output}->option_exit();
      }
  
      if ($self->{option_results}->{oid_filter} ne $self->{option_results}->{oid_display}) {
          foreach my $key ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{ $self->{oids_label}->{$self->{option_results}->{oid_display}} }})) {
              next if ($key !~ /^$self->{oids_label}->{$self->{option_results}->{oid_display}}\.(.*)$/);
              $self->{datas}->{$self->{option_results}->{oid_display} . "_" . $1} = $self->{output}->decode($self->{results}->{$self->{oids_label}->{ $self->{option_results}->{oid_display}} }->{$key});
          }
      }
  
      if (!defined($self->{option_results}->{use_name}) && defined($self->{option_results}->{interface})) {
          foreach (@{$self->{datas}->{all_ids}}) {
              if ($self->{option_results}->{interface} =~ /(^|\s|,)$_(\s*,|$)/) {
                  push @{$self->{interface_id_selected}}, $_;
              }
          }
      } else {
          foreach (@{$self->{datas}->{all_ids}}) {
              my $filter_name = $self->{datas}->{$self->{option_results}->{oid_filter} . "_" . $_};
              next if (!defined($filter_name));
  
              if (!defined($self->{option_results}->{interface})) {
                  push @{$self->{interface_id_selected}}, $_;
                  next;
              }
              if ($filter_name =~ /$self->{option_results}->{interface}/) {
                  push @{$self->{interface_id_selected}}, $_; 
              }
          }
      }
  
      if (scalar(@{$self->{interface_id_selected}}) <= 0 && !defined($options{disco})) {
          $self->{output}->add_option_msg(short_msg => 'No entry found');
          $self->{output}->option_exit();
      }
  }
  
  sub get_extra_values_by_instance {
      my ($self, %options) = @_;
  
      my $extra_values = {};
      foreach my $name (keys %{$self->{extra_oids}}) {
          my $matching = $self->{extra_oids}->{$name}->{matching};
          $matching =~ s/%\{instance\}/$options{instance}/g;
          next if (!defined($self->{results}->{ $self->{extra_oids}->{$name}->{oid} }));
  
          my $append = '';
          foreach (keys %{$self->{results}->{ $self->{extra_oids}->{$name}->{oid} }}) {
              if (/^$self->{extra_oids}->{$name}->{oid}\.$matching/) {
                  $extra_values->{$name} = '' if (!defined($extra_values->{$name}));
                  $extra_values->{$name} .= $append . $self->{output}->decode($self->{results}->{ $self->{extra_oids}->{$name}->{oid} }->{$_});
                  $append = ',';
              }
          }
      }
  
      if (defined($self->{option_results}->{add_mac_address})) {
          my $macaddress = defined($options{result}->{$self->{oid_mac_address} . "." . $_}) ? unpack('H*', $options{result}->{$self->{oid_mac_address} . "." . $_}) : '';
          $macaddress =~ s/(..)(?=.)/$1:/g;
          $extra_values->{macaddress} = $macaddress;
      }
  
      return $extra_values;
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      my $names = ['name', 'total', 'status', 'interfaceid'];
      if (scalar(keys %{$self->{extra_oids}}) > 0) {
          push @$names, keys %{$self->{extra_oids}};
      }
      if (defined($self->{option_results}->{add_mac_address})) {
          push @$names, 'macaddress';
      }
      push @$names, 'type' if (defined($self->{oid_iftype}));
  
      $self->{output}->add_disco_format(elements => $names);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->{snmp} = $options{snmp};
      $self->manage_selection(disco => 1);
      return if (scalar(@{$self->{interface_id_selected}}) == 0);
      my $result = $self->get_additional_information();
      foreach (sort @{$self->{interface_id_selected}}) {
          my $display_value = $self->get_display_value(id => $_);
  
          my $interface_speed = 0;
          if ($self->{no_speed} == 0) {
              $interface_speed = (defined($result->{$oid_speed64 . "." . $_}) && $result->{$oid_speed64 . "." . $_} ne '' && $result->{$oid_speed64 . "." . $_} != 0) ? 
                                  ($result->{$oid_speed64 . "." . $_}) : 
                                      (defined($result->{$oid_speed32 . "." . $_}) && $result->{$oid_speed32 . "." . $_} ne '' && $result->{$oid_speed32 . "." . $_} != 0 ?
                                          (sprintf("%g", $result->{$oid_speed32 . "." . $_} / 1000 / 1000)) : '');
          }
          if (defined($self->{option_results}->{speed}) && $self->{option_results}->{speed} ne '') {
              $interface_speed = $self->{option_results}->{speed};
          }
          next if (defined($self->{option_results}->{skip_speed0}) && $interface_speed == 0);
          next if (defined($self->{option_results}->{filter_status}) && defined($result->{$self->{oid_opstatus} . "." . $_}) && 
              $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} !~ /$self->{option_results}->{filter_status}/i);
          next if ($self->is_admin_status_down(admin_status => $result->{$self->{oid_adminstatus} . "." . $_}));
  
          my $extra_values = $self->get_extra_values_by_instance(result => $result, instance => $_);
          if (defined($self->{oid_iftype})) {
              $extra_values->{type} = defined($result->{ $self->{oid_iftype} . '.' . $_ }) && defined($map_iftype->{ $result->{ $self->{oid_iftype} . '.' . $_ } }) ? 
                  $map_iftype->{ $result->{ $self->{oid_iftype} . '.' . $_ } } : 'unknown';
          }
  
          $self->{output}->add_disco_entry(
              name => $display_value,
              total => $interface_speed,
              status => defined($result->{$self->{oid_opstatus} . "." . $_}) ? $self->{oid_opstatus_mapping}->{$result->{$self->{oid_opstatus} . "." . $_}} : '',
              interfaceid => $_,
              %$extra_values
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  =over 8
  
  =item B<--interface>
  
  Define which interfaces to monitor (number expected). Example: 1,2... (empty means 'check all interfaces').
  
  =item B<--name>
  
  Allows you to define the interface (in option --interface) by name instead of OID index. The name matching mode supports regular expressions.
  
  =item B<--speed>
  
  Set interface speed (in Mb).
  
  =item B<--skip-speed0>
  
  Avoid displaying interfaces with bandwidth/speed equal to 0.
  
  =item B<--filter-status>
  
  Filter interfaces based on their status using a regular expression (example: 'up|UP').
  
  =item B<--use-adminstatus>
  
  Display interfaces with C<AdminStatus> 'up'.
  
  =item B<--oid-filter>
  
  Define the OID to be used to filter interfaces (default: C<ifName>).
  Available OIDs: C<ifDesc>, C<ifAlias>, C<ifName>).
  
  =item B<--oid-display>
  
  Define the OID that will be used to name the interfaces (default: ifName).
  Available OIDs: C<ifDesc>, C<ifAlias>, C<ifName>).
  
  =item B<--display-transform-src> B<--display-transform-dst>
  
  Modify the interface name displayed by using a regular expression.
  
  Example: adding C<--display-transform-src='eth' --display-transform-dst='ens'>  will replace all occurrences of 'eth' with 'ens'
  
  =item B<--add-extra-oid>
  
  Display an OID.
  Example: C<--add-extra-oid='alias,.1.3.6.1.2.1.31.1.1.1.18'>
  or C<--add-extra-oid='vlan,.1.3.6.1.2.1.31.19,%{instance}\..*'>
  
  =item B<--add-mac-address>
  
  Display interfaces MAC addresses.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_LISTINTERFACES

$fatpacked{"snmp_standard/mode/loadaverage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_LOADAVERAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::loadaverage;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          'warning:s'   => { name => 'warning', default => '' },
          'critical:s'  => { name => 'critical', default => '' },
          'average'     => { name => 'average' }
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      ($self->{warn1}, $self->{warn5}, $self->{warn15}) = split /,/, $self->{option_results}->{warning};
      ($self->{crit1}, $self->{crit5}, $self->{crit15}) = split /,/, $self->{option_results}->{critical};
      
      if (($self->{perfdata}->threshold_validate(label => 'warn1', value => $self->{warn1})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong warning (1min) threshold '" . $self->{warn1} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'warn5', value => $self->{warn5})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong warning (5min) threshold '" . $self->{warn5} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'warn15', value => $self->{warn15})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong warning (15min) threshold '" . $self->{warn15} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'crit1', value => $self->{crit1})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong critical (1min) threshold '" . $self->{crit1} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'crit5', value => $self->{crit5})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong critical (5min) threshold '" . $self->{crit5} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'crit15', value => $self->{crit15})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong critical (15min) threshold '" . $self->{crit15} . "'.");
         $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
     
      my $oid_CountCpu = '.1.3.6.1.2.1.25.3.3.1.2'; 
      my $oid_CpuLoad1m = '.1.3.6.1.4.1.2021.10.1.3.1';
      my $oid_CpuLoad5m = '.1.3.6.1.4.1.2021.10.1.3.2';
      my $oid_CpuLoad15m = '.1.3.6.1.4.1.2021.10.1.3.3';
  
      my $result = $self->{snmp}->get_leef(oids => [$oid_CpuLoad1m, $oid_CpuLoad5m, $oid_CpuLoad15m], nothing_quit => 1);
  
      my ($msg, $cpu_load1, $cpu_load5, $cpu_load15);
      $result->{$oid_CpuLoad1m} =~ s/,/\./g;
      $result->{$oid_CpuLoad5m} =~ s/,/\./g;
      $result->{$oid_CpuLoad15m} =~ s/,/\./g;
  
      if (defined($self->{option_results}->{average})) {    
          my $result2 = $self->{snmp}->get_table(oid => $oid_CountCpu);
          if (scalar(keys %$result2) <= 0){
              $self->{output}->output_add(
                  severity => 'unknown',
                  short_msg => 'Unable to get number of CPUs'
              );
              $self->{output}->display();
              $self->{output}->exit();    
          }
  
          my $countCpu = scalar(keys %$result2);
  
          $cpu_load1 = sprintf("%0.2f", $result->{$oid_CpuLoad1m} / $countCpu);
          $cpu_load5 = sprintf("%0.2f", $result->{$oid_CpuLoad5m} / $countCpu);
          $cpu_load15 = sprintf("%0.2f", $result->{$oid_CpuLoad15m} / $countCpu);
          $msg = sprintf(
              "Load average: %s [%s/%s CPUs], %s [%s/%s CPUs], %s [%s/%s CPUs]",
              $cpu_load1, $result->{$oid_CpuLoad1m}, $countCpu,
              $cpu_load5, $result->{$oid_CpuLoad5m}, $countCpu,
              $cpu_load15, $result->{$oid_CpuLoad15m}, $countCpu
          );
          $self->{output}->perfdata_add(
              label => 'avg_load1',
              nlabel => 'load.1m.average.count',
              value => $cpu_load1,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn1'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit1'),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'avg_load5',
              nlabel => 'load.5m.average.count',
              value => $cpu_load5,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn5'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit5'),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'avg_load15',
              nlabel => 'load.15m.average.count',
              value => $cpu_load15,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn15'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit15'),
              min => 0);
           $self->{output}->perfdata_add(
              label => 'load1',
              nlabel => 'load.1m.count',
              value => $result->{$oid_CpuLoad1m},
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn1', op => '*', value => $countCpu),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit1', op => '*', value => $countCpu),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'load5',
              nlabel => 'load.5m.count',
              value => $result->{$oid_CpuLoad5m},
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn5', op => '*', value => $countCpu),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit5', op => '*', value => $countCpu),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'load15',
              nlabel => 'load.15m.count',
              value => $result->{$oid_CpuLoad15m},
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn15', op => '*', value => $countCpu),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit15', op => '*', value => $countCpu),
              min => 0
          );
      } else {
          $cpu_load1 = $result->{$oid_CpuLoad1m};
          $cpu_load5 = $result->{$oid_CpuLoad5m};
          $cpu_load15 = $result->{$oid_CpuLoad15m};
      
          $msg = sprintf("Load average: %s, %s, %s", $cpu_load1, $cpu_load5, $cpu_load15);
          $self->{output}->perfdata_add(
              label => 'load1',
              nlabel => 'load.1m.count',
              value => $cpu_load1,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn1'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit1'),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'load5',
              nlabel => 'load.5m.count',
              value => $cpu_load5,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn5'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit5'),
              min => 0
          );
          $self->{output}->perfdata_add(
              label => 'load15',
              nlabel => 'load.15m.count',
              value => $cpu_load15,
              warning => $self->{perfdata}->get_perfdata_for_output(label => 'warn15'),
              critical => $self->{perfdata}->get_perfdata_for_output(label => 'crit15'),
              min => 0
          );
      }
      
      my $exit1 = $self->{perfdata}->threshold_check(
          value => $cpu_load1,
          threshold => [ { label => 'crit1', exit_litteral => 'critical' }, { label => 'warn1', exit_litteral => 'warning' } ]
      );
      my $exit2 = $self->{perfdata}->threshold_check(
          value => $cpu_load5,
          threshold => [ { label => 'crit5', exit_litteral => 'critical' }, { label => 'warn5', exit_litteral => 'warning' } ]
      );
      my $exit3 = $self->{perfdata}->threshold_check(
          value => $cpu_load15,
          threshold => [ { label => 'crit15', exit_litteral => 'critical' }, { label => 'warn15', exit_litteral => 'warning' } ]
      );
      my $exit = $self->{output}->get_most_critical(status => [ $exit1, $exit2, $exit3 ]);
      $self->{output}->output_add(
          severity => $exit,
          short_msg => $msg
      );
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check system load-average.
  
  =over 8
  
  =item B<--warning>
  
  Warning threshold (1min,5min,15min).
  
  =item B<--critical>
  
  Critical threshold (1min,5min,15min).
  
  =item B<--average>
  
  Load average for the number of CPUs.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_LOADAVERAGE

$fatpacked{"snmp_standard/mode/memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_MEMORY';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::memory;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      return sprintf(
          'Ram Total: %s %s Used (-buffers/cache): %s %s (%.2f%%) Free: %s %s (%.2f%%)',
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{total}),
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{used}),
          $self->{result_values}->{prct_used},
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{free}),
          $self->{result_values}->{prct_free}
      );
  }
  
  sub custom_swap_output {
      my ($self, %options) = @_;
      
      return sprintf(
          'Swap Total: %s %s Used: %s %s (%.2f%%) Free: %s %s (%.2f%%)',
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{total}),
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{used}),
          $self->{result_values}->{prct_used},
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{free}),
          $self->{result_values}->{prct_free}
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'ram', type => 0, skipped_code => { -10 => 1 } },
          { name => 'swap', type => 0, message_separator => ' - ', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{ram} = [
          { label => 'usage', nlabel => 'memory.usage.bytes', set => {
                  key_values => [ { name => 'used' }, { name => 'free' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_usage_output'),
                  perfdatas => [
                      { label => 'used', template => '%d', min => 0, max => 'total', unit => 'B', cast_int => 1 }
                  ]
              }
          },
          { label => 'usage-free', display_ok => 0, nlabel => 'memory.free.bytes', set => {
                  key_values => [ { name => 'free' }, { name => 'used' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_usage_output'),
                  perfdatas => [
                      { label => 'free', template => '%d', min => 0, max => 'total', unit => 'B', cast_int => 1 }
                  ]
              }
          },
          { label => 'usage-prct', display_ok => 0, nlabel => 'memory.usage.percentage', set => {
                  key_values => [ { name => 'prct_used' }, { name => 'used' }, { name => 'free' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_usage_output'),
                  perfdatas => [
                      { label => 'used_prct', template => '%.2f', min => 0, max => 100, unit => '%' }
                  ]
              }
          },
          { label => 'buffer', nlabel => 'memory.buffer.bytes', set => {
                  key_values => [ { name => 'memBuffer' } ],
                  output_template => 'Buffer: %s %s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'buffer', template => '%d', min => 0, unit => 'B' }
                  ]
              }
          },
          { label => 'cached', nlabel => 'memory.cached.bytes', set => {
                  key_values => [ { name => 'memCached' } ],
                  output_template => 'Cached: %s %s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'cached', template => '%d', min => 0, unit => 'B' }
                  ]
              }
          },
          { label => 'shared', nlabel => 'memory.shared.bytes', set => {
                  key_values => [ { name => 'memShared' } ],
                  output_template => 'Shared: %s %s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'shared', template => '%d', min => 0, unit => 'B' }
                  ]
              }
          }
      ];
      $self->{maps_counters}->{swap} = [
          { label => 'swap', nlabel => 'swap.usage.bytes', set => {
                  key_values => [ { name => 'used' }, { name => 'free' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_swap_output'),
                  perfdatas => [
                      { label => 'swap', template => '%d', min => 0, max => 'total', unit => 'B', cast_int => 1 }
                  ]
              }
          },
          { label => 'swap-free', display_ok => 0, nlabel => 'swap.free.bytes', set => {
                  key_values => [ { name => 'free' }, { name => 'used' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_swap_output'),
                  perfdatas => [
                      { label => 'swap_free', template => '%d', min => 0, max => 'total',
                        unit => 'B', cast_int => 1 }
                  ]
              }
          },
          { label => 'swap-prct', display_ok => 0, nlabel => 'swap.usage.percentage', set => {
                  key_values => [ { name => 'prct_used' } ],
                  output_template => 'Swap Used : %.2f %%',
                  perfdatas => [
                      { label => 'swap_prct', template => '%.2f', min => 0, max => 100, unit => '%' }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'units:s'                => { name => 'units', default => '%' },
          'force-64bits-counters'  => { name => 'force_64bits_counters' },
          'free'                   => { name => 'free' },
          'swap'                   => { name => 'check_swap' },
          'patch-redhat'           => { name => 'patch_redhat' },
          'redhat'                 => { name => 'redhat' },           # for legacy (do nothing)
          'autodetect-redhat'      => { name => 'autodetect_redhat' } # for legacy (do nothing)
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      # Compatibility
      $self->compat_threshold_counter(%options, 
          compat => { 
              th => [ ['usage', { free => 'usage-free', prct => 'usage-prct'} ], [ 'memory-usage-bytes', { free => 'memory-free-bytes', prct => 'memory-usage-percentage' } ] ], 
              units => $options{option_results}->{units}, free => $options{option_results}->{free}
          }
      );
      $self->compat_threshold_counter(%options, 
          compat => {
              th => [ ['swap', { free => 'swap-free', prct => 'swap-prct' } ], [ 'swap-usage-bytes', { free => 'swap-free-bytes', prct => 'swap-usage-percentage' } ] ], 
              units => $options{option_results}->{units}, free => $options{option_results}->{free}
          }
      );
      $self->SUPER::check_options(%options);
  }
  
  # legacy counters
  my $mapping_32 = {
      memTotalSwap => { oid => '.1.3.6.1.4.1.2021.4.3' },
      memAvailSwap => { oid => '.1.3.6.1.4.1.2021.4.4' },
      memTotalReal => { oid => '.1.3.6.1.4.1.2021.4.5' },
      memAvailReal => { oid => '.1.3.6.1.4.1.2021.4.6' },
      memTotalFree => { oid => '.1.3.6.1.4.1.2021.4.11' },
      memShared    => { oid => '.1.3.6.1.4.1.2021.4.13' },
      memBuffer    => { oid => '.1.3.6.1.4.1.2021.4.14' },
      memCached    => { oid => '.1.3.6.1.4.1.2021.4.15' }
  };
  
  my $mapping_64 = {
      memTotalSwap => { oid => '.1.3.6.1.4.1.2021.4.18' },
      memAvailSwap => { oid => '.1.3.6.1.4.1.2021.4.19' },
      memTotalReal => { oid => '.1.3.6.1.4.1.2021.4.20' },
      memAvailReal => { oid => '.1.3.6.1.4.1.2021.4.21' },
      memTotalFree => { oid => '.1.3.6.1.4.1.2021.4.23' },
      memShared    => { oid => '.1.3.6.1.4.1.2021.4.24' },
      memBuffer    => { oid => '.1.3.6.1.4.1.2021.4.25' },
      memCached    => { oid => '.1.3.6.1.4.1.2021.4.26' }
  };
  
  sub memory_calc {
      my ($self, %options) = @_;
  
      my $available = ($options{result}->{memAvailReal}) ? $options{result}->{memAvailReal} * 1024 : 0;
      my $total     = ($options{result}->{memTotalReal}) ? $options{result}->{memTotalReal} * 1024 : 0;
      my $buffer    = ($options{result}->{memBuffer}) ? $options{result}->{memBuffer} * 1024 : 0;
      my $cached    = ($options{result}->{memCached}) ? $options{result}->{memCached} * 1024 : 0;
  
      my ($used, $free, $prct_used, $prct_free) = (0, 0, 0, 0);
  
      # rhel patch introduced: net-snmp-5.7.2-43.el7 (https://bugzilla.redhat.com/show_bug.cgi?id=1250060)
      # rhel patch reverted:   net-snmp-5.7.2-47.el7 (https://bugzilla.redhat.com/show_bug.cgi?id=1779609)
  
      if ($total != 0) {
          $used      = (defined($self->{option_results}->{patch_redhat})) ? $total - $available : $total - $available - $buffer - $cached;
          $free      = (defined($self->{option_results}->{patch_redhat})) ? $available : $total - $used;
          $prct_used = $used * 100 / $total;
          $prct_free = 100 - $prct_used;
      }
  
      $self->{ram} = {
          total     => $total,
          used      => $used,
          free      => $free,
          prct_used => $prct_used,
          prct_free => $prct_free,
          memShared => ($options{result}->{memShared}) ? $options{result}->{memShared} * 1024 : 0,
          memBuffer => $buffer,
          memCached => $cached
      };
  }
  
  sub swap_calc {
      my ($self, %options) = @_;
  
      my $free  = ($options{result}->{memAvailSwap}) ? $options{result}->{memAvailSwap} * 1024 : 0;
      my $total = ($options{result}->{memTotalSwap}) ? $options{result}->{memTotalSwap} * 1024 : 0;
  
      my ($used, $prct_used, $prct_free) = (0, 0, 0, 0);
  
      if ($total != 0) {
          $used      = $total - $free;
          $prct_used = $used * 100 / $total;
          $prct_free = 100 - $prct_used;
      }
  
      $self->{swap} = {
          total     => $total,
          used      => $used,
          free      => $free,
          prct_used => $prct_used,
          prct_free => $prct_free
      };
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $mapping = $mapping_32;
      # If asked to use 64bits counters AND if using v2c or v3 (v1 does not support 64bits counters)
      if (defined($self->{option_results}->{force_64bits_counters})
              && defined($self->{option_results}->{snmp_version})
              && !$options{snmp}->is_snmpv1()) {
          $mapping = $mapping_64;
      }
      my @oids    = sort map($_->{oid} . '.0', values(%$mapping));
  
      my $results = $options{snmp}->get_leef(
          oids => \@oids,
          nothing_quit => 1
      );
      my $result = $options{snmp}->map_instance(mapping => $mapping, results => $results, instance => 0);
  
      $self->memory_calc(result => $result);
      if (defined($self->{option_results}->{check_swap})) {
          $self->swap_calc(result => $result);
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check memory usage (UCD-SNMP-MIB).
  
  =over 8
  
  =item B<--units>
  
  Units of thresholds (default: '%') ('%', 'absolute') (deprecated. Please use new counters directly)
  
  =item B<--free>
  
  Thresholds are on free space left (deprecated. Please use new counters directly)
  
  =item B<--swap>
  
  Check swap also.
  
  =item B<--warning-buffer>
  
  Threshold in bytes.
  
  =item B<--critical-buffer>
  
  Threshold in bytes.
  
  =item B<--warning-cached>
  
  Threshold in bytes.
  
  =item B<--critical-cached>
  
  Threshold in bytes.
  
  =item B<--warning-shared>
  
  Threshold in bytes.
  
  =item B<--critical-shared>
  
  Threshold in bytes.
  
  =item B<--warning-swap>
  
  Threshold in bytes.
  
  =item B<--critical-swap>
  
  Threshold in bytes.
  
  =item B<--warning-swap-free>
  
  Threshold in bytes.
  
  =item B<--critical-swap-free>
  
  Threshold in bytes.
  
  =item B<--warning-swap-prct>
  
  Threshold in percentage.
  
  =item B<--critical-swap-prct>
  
  Threshold in percentage.
  
  =item B<--warning-usage>
  
  Threshold in bytes.
  
  =item B<--critical-usage>
  
  Threshold in bytes.
  
  =item B<--warning-usage-free>
  
  Threshold in bytes.
  
  =item B<--critical-usage-free>
  
  Threshold in bytes.
  
  =item B<--warning-usage-prct>
  
  Threshold in percentage.
  
  =item B<--critical-usage-prct>
  
  Threshold in percentage.
  
  =item B<--patch-redhat>
  
  If using Red Hat distribution with net-snmp >= 5.7.2-43 and net-snmp < 5.7.2-47. But you should update net-snmp!!!!
  
  This version: used = memTotalReal - memAvailReal // free = memAvailReal
  
  Others versions: used = memTotalReal - memAvailReal - memBuffer - memCached // free = total - used
  
  =item B<--force-64bits-counters>
  
  Use this option to monitor a server/device that has more than 2 TB of RAM, the maximum size of a signed 32 bits integer.
  If you omit it you'll get the remainder of the Euclidean division of the actual value by 2 TB.
  NB: it cannot work with version 1 of SNMP protocol. 64 bits counters are supported starting version 2c.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_MEMORY

$fatpacked{"snmp_standard/mode/resources/types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_RESOURCES_TYPES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::resources::types;
  
  use strict;
  use warnings;
  use Exporter;
  
  our $map_iftype;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw($map_iftype);
  
  $map_iftype = {
      1 => 'other', 2 => 'regular1822', 3 => 'hdh1822', 4 => 'ddnX25', 5 => 'rfc877x25', 6 => 'ethernetCsmacd', 
      7 => 'iso88023Csmacd', 8 => 'iso88024TokenBus', 9 => 'iso88025TokenRing', 10 => 'iso88026Man', 11 => 'starLan', 
      12 => 'proteon10Mbit', 13 => 'proteon80Mbit', 14 => 'hyperchannel', 15 => 'fddi', 16 => 'lapb', 17 => 'sdlc', 18 => 'ds1', 
      19 => 'e1', 20 => 'basicISDN', 21 => 'primaryISDN', 22 => 'propPointToPointSerial', 23 => 'ppp', 24 => 'softwareLoopback',
      25 => 'eon', 26 => 'ethernet3Mbit', 27 => 'nsip', 28 => 'slip', 29 => 'ultra', 30 => 'ds3', 31 => 'sip', 32 => 'frameRelay',
      33 => 'rs232', 34 => 'para', 35 => 'arcnet', 36 => 'arcnetPlus', 37 => 'atm', 38 => 'miox25', 39 => 'sonet', 40 => 'x25ple', 41 => 'iso88022llc',
      42 => 'localTalk', 43 => 'smdsDxi', 44 => 'frameRelayService', 45 => 'v35', 46 => 'hssi', 47 => 'hippi', 48 => 'modem', 49 => 'aal5', 
      50 => 'sonetPath', 51 => 'sonetVT', 52 => 'smdsIcip', 53 => 'propVirtual', 54 => 'propMultiplexor', 55 => 'ieee80212', 56 => 'fibreChannel', 
      57 => 'hippiInterface', 58 => 'frameRelayInterconnect', 59 => 'aflane8023', 60 => 'aflane8025', 61 => 'cctEmul', 62 => 'fastEther', 63 => 'isdn',
      64 => 'v11', 65 => 'v36', 66 => 'g703at64k', 67 => 'g703at2mb', 68 => 'qllc', 69 => 'fastEtherFX', 70 => 'channel', 71 => 'ieee80211', 
      72 => 'ibm370parChan', 73 => 'escon', 74 => 'dlsw', 75 => 'isdns', 76 => 'isdnu', 77 => 'lapd', 78 => 'ipSwitch', 79 => 'rsrb', 80 => 'atmLogical',
      81 => 'ds0', 82 => 'ds0Bundle', 83 => 'bsc', 84 => 'async', 85 => 'cnr', 86 => 'iso88025Dtr', 87 => 'eplrs', 88 => 'arap', 89 => 'propCnls',
      90 => 'hostPad', 91 => 'termPad', 92 => 'frameRelayMPI', 93 => 'x213', 94 => 'adsl', 95 => 'radsl', 96 => 'sdsl', 97 => 'vdsl',
      98 => 'iso88025CRFPInt', 99 => 'myrinet', 100 => 'voiceEM', 101 => 'voiceFXO', 102 => 'voiceFXS', 103 => 'voiceEncap', 104 => 'voiceOverIp',
      105 => 'atmDxi', 106 => 'atmFuni', 107 => 'atmIma', 108 => 'pppMultilinkBundle', 109 => 'ipOverCdlc', 110 => 'ipOverClaw', 111 => 'stackToStack',
      112 => 'virtualIpAddress', 113 => 'mpc', 114 => 'ipOverAtm', 115 => 'iso88025Fiber', 116 => 'tdlc', 117 => 'gigabitEthernet', 118 => 'hdlc',
      119 => 'lapf', 120 => 'v37', 121 => 'x25mlp', 122 => 'x25huntGroup', 123 => 'transpHdlc', 124 => 'interleave', 125 => 'fast', 126 => 'ip',
      127 => 'docsCableMaclayer', 128 => 'docsCableDownstream', 129 => 'docsCableUpstream', 130 => 'a12MppSwitch', 131 => 'tunnel', 132 => 'coffee',
      133 => 'ces', 134 => 'atmSubInterface', 135 => 'l2vlan', 136 => 'l3ipvlan', 137 => 'l3ipxvlan', 138 => 'digitalPowerline', 139 => 'mediaMailOverIp',
      140 => 'dtm', 141 => 'dcn', 142 => 'ipForward', 143 => 'msdsl', 144 => 'ieee1394', 145 => 'if-gsn', 146 => 'dvbRccMacLayer', 147 => 'dvbRccDownstream',
      148 => 'dvbRccUpstream', 149 => 'atmVirtual', 150 => 'mplsTunnel', 151 => 'srp', 152 => 'voiceOverAtm', 153 => 'voiceOverFrameRelay', 154 => 'idsl',
      155 => 'compositeLink', 156 => 'ss7SigLink', 157 => 'propWirelessP2P', 158 => 'frForward', 159 => 'rfc1483', 160 => 'usb', 161 => 'ieee8023adLag',
      162 => 'bgppolicyaccounting', 163 => 'frf16MfrBundle', 164 => 'h323Gatekeeper', 165 => 'h323Proxy', 166 => 'mpls', 167 => 'mfSigLink', 168 => 'hdsl2',
      169 => 'shdsl', 170 => 'ds1FDL', 171 => 'pos', 172 => 'dvbAsiIn', 173 => 'dvbAsiOut', 174 => 'plc', 175 => 'nfas', 176 => 'tr008', 177 => 'gr303RDT',
      178 => 'gr303IDT', 179 => 'isup', 180 => 'propDocsWirelessMaclayer', 181 => 'propDocsWirelessDownstream', 182 => 'propDocsWirelessUpstream', 183 => 'hiperlan2',
      184 => 'propBWAp2Mp', 185 => 'sonetOverheadChannel', 186 => 'digitalWrapperOverheadChannel', 187 => 'aal2', 188 => 'radioMAC', 189 => 'atmRadio',
      190 => 'imt', 191 => 'mvl', 192 => 'reachDSL', 193 => 'frDlciEndPt', 194 => 'atmVciEndPt', 195 => 'opticalChannel', 196 => 'opticalTransport',
      197 => 'propAtm', 198 => 'voiceOverCable', 199 => 'infiniband', 200 => 'teLink', 201 => 'q2931', 202 => 'virtualTg', 203 => 'sipTg', 204 => 'sipSig',
      205 => 'docsCableUpstreamChannel', 206 => 'econet', 207 => 'pon155', 208 => 'pon622', 209 => 'bridge', 210 => 'linegroup', 211 => 'voiceEMFGD',
      212 => 'voiceFGDEANA', 213 => 'voiceDID', 214 => 'mpegTransport', 215 => 'sixToFour', 216 => 'gtp', 217 => 'pdnEtherLoop1', 218 => 'pdnEtherLoop2',
      219 => 'opticalChannelGroup', 220 => 'homepna', 221 => 'gfp', 222 => 'ciscoISLvlan', 223 => 'actelisMetaLOOP', 224 => 'fcipLink', 225 => 'rpr', 226 => 'qam',
      227 => 'lmp', 228 => 'cblVectaStar', 229 => 'docsCableMCmtsDownstream', 230 => 'adsl2', 231 => 'macSecControlledIF', 232 => 'macSecUncontrolledIF',
      233 => 'aviciOpticalEther', 234 => 'atmbond', 235 => 'voiceFGDOS', 236 => 'mocaVersion1', 237 => 'ieee80216WMAN', 238 => 'adsl2plus', 239 => 'dvbRcsMacLayer',
      240 => 'dvbTdm', 241 => 'dvbRcsTdma', 242 => 'x86Laps', 243 => 'wwanPP', 244 => 'wwanPP2', 245 => 'voiceEBS', 246 => 'ifPwType', 247 => 'ilan', 248 => 'pip',
      249 => 'aluELP', 250 => 'gpon', 251 => 'vdsl2', 252 => 'capwapDot11Profile', 253 => 'capwapDot11Bss', 254 => 'capwapWtpVirtualRadio', 255 => 'bits',
      256 => 'docsCableUpstreamRfPort', 257 => 'cableDownstreamRfPort', 258 => 'vmwareVirtualNic', 259 => 'ieee802154', 260 => 'otnOdu', 261 => 'otnOtu',
      262 => 'ifVfiType', 263 => 'g9981', 264 => 'g9982', 265 => 'g9983', 266 => 'aluEpon', 267 => 'aluEponOnu', 268 => 'aluEponPhysicalUni',
      269 => 'aluEponLogicalLink', 270 => 'aluGponOnu', 271 => 'aluGponPhysicalUni', 272 => 'vmwareNicTeam', 277 => 'docsOfdmDownstream', 278 => 'docsOfdmaUpstream',
      279 => 'gfast', 280 => 'sdci', 281 => 'xboxWireless', 282 => 'fastdsl', 283 => 'docsCableScte55d1FwdOob', 284 => 'docsCableScte55d1RetOob',
      285 => 'docsCableScte55d2DsOob', 286 => 'docsCableScte55d2UsOob', 287 => 'docsCableNdf', 288 => 'docsCableNdr', 289 => 'ptm', 290 => 'ghn', 291 => 'otnOtsi',
      292 => 'otnOtuc', 293 => 'otnOduc', 294 => 'otnOtsig', 295 => 'microwaveCarrierTermination', 296 => 'microwaveRadioLinkTerminal', 297 => 'ieee8021axDrni',
      298 => 'ax25', 299 => 'ieee19061nanocom', 300 => 'cpri'
  };
  
  1;
SNMP_STANDARD_MODE_RESOURCES_TYPES

$fatpacked{"snmp_standard/mode/storage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_STORAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::storage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::statefile;
  use Digest::MD5 qw(md5_hex);
  use Safe;
  
  my %oids_hrStorageTable = (
      'hrstoragedescr'    => '.1.3.6.1.2.1.25.2.3.1.3',
      'hrfsmountpoint'    => '.1.3.6.1.2.1.25.3.8.1.2',
      'hrfsstorageindex'  => '.1.3.6.1.2.1.25.3.8.1.7',
      'hrstoragetype'     => '.1.3.6.1.2.1.25.2.3.1.2'
  );
  my %storage_types_manage = (
      '.1.3.6.1.2.1.25.2.1.1'  => 'hrStorageOther',
      '.1.3.6.1.2.1.25.2.1.2'  => 'hrStorageRam',
      '.1.3.6.1.2.1.25.2.1.3'  => 'hrStorageVirtualMemory',
      '.1.3.6.1.2.1.25.2.1.4'  => 'hrStorageFixedDisk',
      '.1.3.6.1.2.1.25.2.1.5'  => 'hrStorageRemovableDisk',
      '.1.3.6.1.2.1.25.2.1.6'  => 'hrStorageFloppyDisk',
      '.1.3.6.1.2.1.25.2.1.7'  => 'hrStorageCompactDisc',
      '.1.3.6.1.2.1.25.2.1.8'  => 'hrStorageRamDisk',
      '.1.3.6.1.2.1.25.2.1.9'  => 'hrStorageFlashMemory',
      '.1.3.6.1.2.1.25.2.1.10' => 'hrStorageNetworkDisk',
      '.1.3.6.1.2.1.25.3.9.1'  => 'hrFSOther',
      '.1.3.6.1.2.1.25.3.9.2'  => 'hrFSUnknown',
      '.1.3.6.1.2.1.25.3.9.3'  => 'hrFSBerkeleyFFS', # For Freebsd
      '.1.3.6.1.2.1.25.3.9.4'  => 'hrFSSys5FS',
      '.1.3.6.1.2.1.25.3.9.5'  => 'hrFSFat',
      '.1.3.6.1.2.1.25.3.9.6'  => 'hrFSHPFS',
      '.1.3.6.1.2.1.25.3.9.7'  => 'hrFSHFS',
      '.1.3.6.1.2.1.25.3.9.8'  => 'hrFSMFS',
      '.1.3.6.1.2.1.25.3.9.9'  => 'hrFSNTFS',
      '.1.3.6.1.2.1.25.3.9.10' => 'hrFSVNode',
      '.1.3.6.1.2.1.25.3.9.11' => 'hrFSJournaled',
      '.1.3.6.1.2.1.25.3.9.12' => 'hrFSiso9660',
      '.1.3.6.1.2.1.25.3.9.13' => 'hrFSRockRidge',
      '.1.3.6.1.2.1.25.3.9.14' => 'hrFSNFS',
      '.1.3.6.1.2.1.25.3.9.15' => 'hrFSNetware',
      '.1.3.6.1.2.1.25.3.9.16' => 'hrFSAFS',
      '.1.3.6.1.2.1.25.3.9.17' => 'hrFSDFS',
      '.1.3.6.1.2.1.25.3.9.18' => 'hrFSAppleshare',
      '.1.3.6.1.2.1.25.3.9.19' => 'hrFSRFS',
      '.1.3.6.1.2.1.25.3.9.20' => 'hrFSDGCFS',
      '.1.3.6.1.2.1.25.3.9.21' => 'hrFSBFS',
      '.1.3.6.1.2.1.25.3.9.22' => 'hrFSFAT32',
      '.1.3.6.1.2.1.25.3.9.23' => 'hrFSLinuxExt2'
  );
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
  
      my ($label, $nlabel) = ('used', $self->{nlabel});
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          ($label, $nlabel) = ('free', 'storage.space.free.bytes');
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          nlabel => $nlabel,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
  
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(
          value => $threshold_value,
          threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' }
          ]
      );
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
  
      my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
      my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
      return sprintf(
          'Usage Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)',
          $total_size_value . " " . $total_size_unit,
          $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
          $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free}
      );
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_size'} * $options{new_datas}->{$self->{instance} . '_allocation_units'};
      my $reserved_value = 0;
      if (defined($self->{instance_mode}->{option_results}->{space_reservation})) {
          $reserved_value = $self->{instance_mode}->{option_results}->{space_reservation} * $self->{result_values}->{total} / 100;
      }
  
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'} * $options{new_datas}->{$self->{instance} . '_allocation_units'};
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used} - $reserved_value;
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / ($self->{result_values}->{total} - $reserved_value);
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      
      # limit to 100. Better output.
      if ($self->{result_values}->{prct_used} > 100) {
          $self->{result_values}->{free} = 0;
          $self->{result_values}->{prct_used} = 100;
          $self->{result_values}->{prct_free} = 0;
      }
  
      return 0;
  }
  
  sub custom_access_perfdata {
      my ($self, %options) = @_;
  
      $self->{output}->perfdata_add(
          nlabel => $self->{nlabel},
          instances => $self->{result_values}->{display},
          value => $self->{result_values}->{access},
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-access'),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-access'),
          min => 1, max => 2
      );
  }
  
  sub custom_access_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(
          value => $self->{result_values}->{access},
          threshold => [
              { label => 'critical-access', exit_litteral => 'critical' },
              { label => 'warning-access', exit_litteral => 'warning' }
          ]
      );
  }
  
  sub custom_access_output {
      my ($self, %options) = @_;
  
      return sprintf(
          'Access: %s', 
          $self->{result_values}->{access} == 1 ? 'readWrite' : 'readOnly'
      );
  }
  
  sub prefix_storage_output {
      my ($self, %options) = @_;
  
      return "Storage '" . $options{instance_value}->{display} . "' ";
  }
  
  sub default_storage_type {
      my ($self, %options) = @_;
  
      return '^(hrStorageFixedDisk|hrStorageNetworkDisk|hrFSBerkeleyFFS)$';
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 },
          { name => 'storage', type => 1, cb_prefix_output => 'prefix_storage_output', message_multiple => 'All storages are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'count', nlabel => 'storage.partitions.count', display_ok => 0, set => {
                  key_values => [ { name => 'count' } ],
                  output_template => 'Partitions count: %d',
                  perfdatas => [
                      { label => 'count', template => '%d', min => 0 }
                  ]
              }
          }
      ];
  
      $self->{maps_counters}->{storage} = [
          { label => 'usage', nlabel => 'storage.space.usage.bytes', set => {
                  key_values => [ { name => 'display' }, { name => 'used' }, { name => 'size' }, { name => 'allocation_units' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold')
              }
          },
          { label => 'access', nlabel => 'storage.access.count', threshold => 0, set => {
                  key_values => [ { name => 'access' }, { name => 'display' } ],
                  closure_custom_output => $self->can('custom_access_output'),
                  closure_custom_threshold_check => $self->can('custom_access_threshold'),
                  closure_custom_perfdata => $self->can('custom_access_perfdata')
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'units:s'                 => { name => 'units', default => '%' },
          'free'                    => { name => 'free' },
          'reload-cache-time:s'     => { name => 'reload_cache_time', default => 180 },
          'name'                    => { name => 'use_name' },
          'storage:s'               => { name => 'storage' },
          'regexp'                  => { name => 'use_regexp' },
          'regexp-isensitive'       => { name => 'use_regexpi' }, # compatibility
          'regexp-insensitive'      => { name => 'use_regexpi' },
          'path-best-match'         => { name => 'use_path_best_match' },
          'oid-filter:s'            => { name => 'oid_filter', default => 'hrStorageDescr'},
          'oid-display:s'           => { name => 'oid_display', default => 'hrStorageDescr'},
          'display-transform-src:s' => { name => 'display_transform_src' },
          'display-transform-dst:s' => { name => 'display_transform_dst' },
          'show-cache'              => { name => 'show_cache' },
          'space-reservation:s'     => { name => 'space_reservation' },
          'filter-duplicate'        => { name => 'filter_duplicate' },
          'filter-storage-type:s'   => { name => 'filter_storage_type', default => $self->default_storage_type() },
          'add-access'              => { name => 'add_access' },
          'counters-overflow'       => { name => 'counters_overflow' },
          'warning-access:s'        => { name => 'warning_access' },
          'critical-access:s'       => { name => 'critical_access' }
      });
  
      $self->{storage_id_selected} = [];
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
  
      $self->{safe} = Safe->new();
      $self->{safe}->share('$assign_var');
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      foreach (('warning', 'critical')) {
          next if (!defined($self->{option_results}->{$_ . '_access'}));
          $self->{option_results}->{$_ . '_access'} = '@2:2' if ($self->{option_results}->{$_ . '_access'} =~ /readOnly/i);
          $self->{option_results}->{$_ . '_access'} = '@1:1' if ($self->{option_results}->{$_ . '_access'} =~ /readWrite/i);
          if (($self->{perfdata}->threshold_validate(label => $_ . '-access', value => $self->{option_results}->{$_ . '_access'})) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong $_-access threshold '" . $self->{option_results}->{$_ . '_access'} . "'.");
              $self->{output}->option_exit();
          }
      }
  
      if (defined($self->{option_results}->{space_reservation}) && 
          ($self->{option_results}->{space_reservation} < 0 || $self->{option_results}->{space_reservation} > 100)) {
          $self->{output}->add_option_msg(short_msg => "Space reservation argument must be between 0 and 100 percent.");
          $self->{output}->option_exit();
      }
  
      $self->{option_results}->{oid_filter} = lc($self->{option_results}->{oid_filter});
      if ($self->{option_results}->{oid_filter} !~ /^(hrstoragedescr|hrfsmountpoint)$/) {
          $self->{output}->add_option_msg(short_msg => "Unsupported --oid-filter option.");
          $self->{output}->option_exit();
      }
      $self->{option_results}->{oid_display} = lc($self->{option_results}->{oid_display});
      if ($self->{option_results}->{oid_display} !~ /^(hrstoragedescr|hrfsmountpoint)$/) {
          $self->{output}->add_option_msg(short_msg => "Unsupported --oid-display option.");
          $self->{output}->option_exit();
      }
  
      $self->{statefile_cache}->check_options(%options);
  }
  
  sub access_result {
      my ($self, %options) = @_;
  
      return {}
          if (!defined($self->{option_results}->{add_access}));
      my $oid_hrFSAccess = '.1.3.6.1.2.1.25.3.8.1.5';
      my $relations = $self->{statefile_cache}->get(name => 'relation_storageindex_fsstorageindex');
      return {} if (!defined($relations) || scalar(keys %$relations) <= 0);
      my $instances = [];
      foreach (@{$self->{storage_id_selected}}) {
          if (defined($relations->{$_})) {
              push @$instances, $relations->{$_};
          }
      }
  
      $options{snmp}->load(
          oids => [$oid_hrFSAccess], 
          instances => $instances,
          nothing_quit => 1
      );
      my $snmp_result = $options{snmp}->get_leef();
      my $result = {};
      foreach (@{$self->{storage_id_selected}}) {
          if (defined($snmp_result->{$oid_hrFSAccess . '.' . $relations->{$_}})) {
              $result->{$_} = $snmp_result->{$oid_hrFSAccess . '.' . $relations->{$_}};
          }
      }
  
      return $result;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->get_selection(snmp => $options{snmp});
  
      my $oid_hrStorageAllocationUnits = '.1.3.6.1.2.1.25.2.3.1.4';
      my $oid_hrStorageSize = '.1.3.6.1.2.1.25.2.3.1.5';
      my $oid_hrStorageUsed = '.1.3.6.1.2.1.25.2.3.1.6';
      my $oid_hrStorageType = '.1.3.6.1.2.1.25.2.3.1.2';
  
      $options{snmp}->load(
          oids => [$oid_hrStorageAllocationUnits, $oid_hrStorageSize, $oid_hrStorageUsed], 
          instances => $self->{storage_id_selected},
          nothing_quit => 1
      );
      my $result = $options{snmp}->get_leef();
      my $access_result = $self->access_result(snmp => $options{snmp});
  
      $self->{global}->{count} = 0;
      $self->{storage} = {};
      foreach (sort @{$self->{storage_id_selected}}) {
          my $name_storage = $self->get_display_value(id => $_);
  
          if (!defined($result->{$oid_hrStorageAllocationUnits . '.' . $_})) {
              $self->{output}->add_option_msg(
                  long_msg => sprintf(
                      "skipping storage '%s': not found (need to reload the cache)", 
                      $name_storage
                  )
              );
              next;
          }
          if ($result->{$oid_hrStorageAllocationUnits . '.' . $_} == 0) {
              $self->{output}->add_option_msg(
                  long_msg => sprintf(
                      "skipping storage '%s': allocation units 0", 
                      $name_storage
                  )
              );
              next;
          }
  
          # in bytes hrStorageAllocationUnits
          my $size = $result->{$oid_hrStorageSize . '.' . $_};
          my $used = $result->{$oid_hrStorageUsed . '.' . $_};
          if (defined($self->{option_results}->{counters_overflow})) {
              $size += 2**32 if ($size <= 0);
              $used += 2**32 if ($used <= 0);
          }
  
          if ($size <= 0) {
              $self->{output}->output_add(
                  long_msg => sprintf(
                      "skipping storage '%s': total size is <= 0 (%s) (try option --counters-overflow)", 
                      $name_storage,
                      $size
                  ),
                  debug => 1
              );
              next;
          }
  
          if (defined($self->{option_results}->{filter_duplicate})) {
              my $duplicate = 0;
              foreach my $entry (values %{$self->{storage}}) {
                  if (($entry->{allocation_units} == $result->{$oid_hrStorageAllocationUnits . '.' . $_}) &&
                      ($entry->{size} == $result->{$oid_hrStorageSize . '.' . $_}) &&
                      ($entry->{used} == $result->{$oid_hrStorageUsed . '.' . $_})) {
                      $duplicate = 1;
                      last;
                  }
              }
              next if ($duplicate == 1);
          }
  
          $self->{storage}->{$_} = {
              display => $name_storage,
              allocation_units => $result->{$oid_hrStorageAllocationUnits . '.' . $_},
              size => $size,
              used => $used,
              access => defined($access_result->{$_}) ? $access_result->{$_} : undef
          };
          $self->{global}->{count}++;
      }
  
      if (scalar(keys %{$self->{storage}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'Issue with storage information (see details)');
          $self->{output}->option_exit();
      }
  }
  
  sub reload_cache {
      my ($self, %options) = @_;
      my $datas = {};
  
      $datas->{oid_filter} = $self->{option_results}->{oid_filter};
      $datas->{oid_display} = $self->{option_results}->{oid_display};
      $datas->{last_timestamp} = time();
      $datas->{all_ids} = [];
      $datas->{relation_storageindex_fsstorageindex} = {};
      
      my $request = [ { oid => $oids_hrStorageTable{hrstoragetype} } ];
      my $added = {};
      my $build_relation = 0;
      foreach (($self->{option_results}->{oid_filter}, $self->{option_results}->{oid_display} )) {
          next if (defined($added->{$_}));
          $added->{$_} = 1;
          if (/hrFSMountPoint/i) {
              push @{$request}, ({ oid => $oids_hrStorageTable{hrfsmountpoint} }, { oid => $oids_hrStorageTable{hrfsstorageindex} });
              $build_relation = 1;
          } else {
              push @{$request}, { oid => $oids_hrStorageTable{hrstoragedescr} };
          }
      }
      
      if (defined($self->{option_results}->{add_access}) && !defined($added->{hrFSMountPoint})) {
          push @{$request}, { oid => $oids_hrStorageTable{hrfsstorageindex} };
          $build_relation = 1;
      }
  
      my $result = $options{snmp}->get_multiple_table(oids => $request);
      foreach ((['filter', $self->{option_results}->{oid_filter}], ['display', $self->{option_results}->{oid_display}], ['type', 'hrstoragetype'])) {
          foreach my $key ($options{snmp}->oid_lex_sort(keys %{$result->{ $oids_hrStorageTable{$$_[1]} }})) {
              next if ($key !~ /\.([0-9]+)$/);
              # get storage index
              my $storage_index = $1;
              if ($$_[1] =~ /hrFSMountPoint/i) {
                  $storage_index = $result->{ $oids_hrStorageTable{hrfsstorageindex} }->{$oids_hrStorageTable{hrfsstorageindex} . '.' . $storage_index};
              }            
              if ($$_[0] eq 'filter') {
                  push @{$datas->{all_ids}}, $storage_index;
              }
  
              $datas->{$$_[1] . "_" . $storage_index} = $self->{output}->decode($result->{ $oids_hrStorageTable{$$_[1]} }->{$key});
          }
      }
      
      if ($build_relation == 1) {
          foreach (keys %{$result->{ $oids_hrStorageTable{hrfsstorageindex} }}) {
              /\.([0-9]+)$/;
              $datas->{relation_storageindex_fsstorageindex}->{ $result->{ $oids_hrStorageTable{hrfsstorageindex} }->{$_} } = $1;
          }
      }
  
      if (scalar(@{$datas->{all_ids}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "Can't construct cache...");
          $self->{output}->option_exit();
      }
  
      $self->{statefile_cache}->write(data => $datas);
  }
  
  sub filter_type {
      my ($self, %options) = @_;
  
      # some equipments doesn't have hrstoragetype
      return 1 if ($self->{option_results}->{filter_storage_type} eq '');
  
      my $storage_type = $self->{statefile_cache}->get(name => "hrstoragetype_" . $options{id});
      if (defined($storage_type) && 
          ($storage_types_manage{$storage_type} =~ /$self->{option_results}->{filter_storage_type}/i)) {
          return 1;
      }
      return 0;
  }
  
  sub get_selection {
      my ($self, %options) = @_;
  
      # init cache file
      my $has_cache_file = $self->{statefile_cache}->read(statefile => 'cache_snmpstandard_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode});
      if (defined($self->{option_results}->{show_cache})) {
          $self->{output}->add_option_msg(long_msg => $self->{statefile_cache}->get_string_content());
          $self->{output}->option_exit();
      }
  
      my $timestamp_cache = $self->{statefile_cache}->get(name => 'last_timestamp');
      my $oid_display = $self->{statefile_cache}->get(name => 'oid_display');
      my $oid_filter = $self->{statefile_cache}->get(name => 'oid_filter');
      if ($has_cache_file == 0 ||
          ($self->{option_results}->{oid_display} !~ /^($oid_display|$oid_filter)$/i || $self->{option_results}->{oid_filter} !~ /^($oid_display|$oid_filter)$/i) ||
          !defined($timestamp_cache) || ((time() - $timestamp_cache) > (($self->{option_results}->{reload_cache_time}) * 60))) {
              $self->reload_cache(snmp => $options{snmp});
              $self->{statefile_cache}->read();
      }
  
      my $all_ids = $self->{statefile_cache}->get(name => 'all_ids');
      if (!defined($self->{option_results}->{use_name}) && defined($self->{option_results}->{storage})) {
          # get by ID
          my $name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_filter} . "_" . $self->{option_results}->{storage});
          push @{$self->{storage_id_selected}}, $self->{option_results}->{storage} if (defined($name) && $self->filter_type(id => $self->{option_results}->{storage}));
      } else {
          my $path_best_match_score = -1;
          my $path_best_match = -1;
  
          foreach my $i (@{$all_ids}) {
              my $filter_name = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_filter} . "_" . $i);
              next if (!defined($filter_name));
              
              if (!defined($self->{option_results}->{storage})) {
                  push @{$self->{storage_id_selected}}, $i if ($self->filter_type(id => $i));
                  next;
              }
              if (defined($self->{option_results}->{use_regexp}) && defined($self->{option_results}->{use_regexpi}) && $filter_name =~ /$self->{option_results}->{storage}/i) {
                  push @{$self->{storage_id_selected}}, $i if ($self->filter_type(id => $i));
              }
              if (defined($self->{option_results}->{use_regexp}) && !defined($self->{option_results}->{use_regexpi}) && $filter_name =~ /$self->{option_results}->{storage}/) {
                  push @{$self->{storage_id_selected}}, $i if ($self->filter_type(id => $i));
              }
              if (!defined($self->{option_results}->{use_regexp}) && !defined($self->{option_results}->{use_regexpi}) && $filter_name eq $self->{option_results}->{storage}) {
                  push @{$self->{storage_id_selected}}, $i if ($self->filter_type(id => $i));
              }
              if (defined($self->{option_results}->{use_path_best_match})) {
                  if ($path_best_match_score < length($filter_name) && $self->{option_results}->{storage} =~ /^$filter_name/) {
                      $path_best_match_score = length($filter_name);
                      $path_best_match = $i;
                  }
                  $self->{output}->output_add(
                      long_msg => sprintf(
                          "- searching [%s] filter-name [%s] length [%i] score [%i] index [%i]\n",
                          $self->{option_results}->{storage}, $filter_name , length($filter_name), $path_best_match_score, $path_best_match
                      ),
                      debug => 1
                  );
              }
          }
          if (0 < $path_best_match_score) {
              push @{$self->{storage_id_selected}}, $path_best_match;
          }
      }
  
      if (scalar(@{$self->{storage_id_selected}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No storage found. Can be: filters, cache file.");
          $self->{output}->option_exit();
      }
  }
  
  sub get_display_value {
      my ($self, %options) = @_;
  
      our $assign_var = $self->{statefile_cache}->get(name => $self->{option_results}->{oid_display} . "_" . $options{id});
      if (defined($self->{option_results}->{display_transform_src})) {
          $self->{option_results}->{display_transform_dst} = '' if (!defined($self->{option_results}->{display_transform_dst}));
  
          $self->{safe}->reval("\$assign_var =~ s{$self->{option_results}->{display_transform_src}}{$self->{option_results}->{display_transform_dst}}", 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      }
  
      return $assign_var;
  }
  
  1;
  
  
  =head1 MODE
  
  =over 8
  
  =item B<--warning-usage>
  
  Warning threshold.
  
  =item B<--critical-usage>
  
  Critical threshold.
  
  =item B<--warning-access>
  
  Warning threshold. 
  
  =item B<--critical-access>
  
  Critical threshold.
  Check if storage is readOnly: --critical-access=readOnly
  
  =item B<--add-access>
  
  Check storage access (readOnly, readWrite).
  
  =item B<--units>
  
  Units of thresholds (default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--storage>
  
  Set the storage (number expected) example: 1, 2,... (empty means 'check all storage').
  
  =item B<--name>
  
  Allows to use storage name with option --storage instead of storage oid index.
  
  =item B<--regexp>
  
  Allows to use regexp to filter storage (with option --name).
  
  =item B<--regexp-insensitive>
  
  Allows to use regexp non case-sensitive (with --regexp).
  
  =item B<--path-best-match>
  
  Allows to select best path mount point (with --name).
  
  =item B<--reload-cache-time>
  
  Time in minutes before reloading cache file (default: 180).
  
  =item B<--oid-filter>
  
  Choose OID used to filter storage (default: hrStorageDescr) (values: hrStorageDescr, hrFSMountPoint).
  
  =item B<--oid-display>
  
  Choose OID used to display storage (default: hrStorageDescr) (values: hrStorageDescr, hrFSMountPoint).
  
  =item B<--display-transform-src> B<--display-transform-dst>
  
  Modify the storage name displayed by using a regular expression.
  
  Example: adding --display-transform-src='dev' --display-transform-dst='run'  will replace all occurrences of 'dev' with 'run'
  
  =item B<--show-cache>
  
  Display cache storage data.
  
  =item B<--space-reservation>
  
  Some filesystem has space reserved (like ext4 for root).
  The value is in percent of total (default: none) (results like 'df' command).
  
  =item B<--filter-duplicate>
  
  Filter duplicate storages (in used size and total size).
  
  =item B<--filter-storage-type>
  
  Filter storage types with a regexp (default: '^(hrStorageFixedDisk|hrStorageNetworkDisk|hrFSBerkeleyFFS)$').
  
  =back
  
  =cut
SNMP_STANDARD_MODE_STORAGE

$fatpacked{"snmp_standard/mode/swap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_SWAP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package snmp_standard::mode::swap;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  
  sub custom_swap_output {
      my ($self, %options) = @_;
      
      my $msg = sprintf("Swap Total: %s %s Used: %s %s (%.2f%%) Free: %s %s (%.2f%%)",
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{total}),
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{used}),
          $self->{result_values}->{prct_used},
          $self->{perfdata}->change_bytes(value => $self->{result_values}->{free}),
          $self->{result_values}->{prct_free});
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'swap', type => 0, message_separator => ' - ', skipped_code => { -10 => 1 } },
      ];
  
      $self->{maps_counters}->{swap} = [
          { label => 'usage', nlabel => 'swap.usage.bytes', set => {
                  key_values => [ { name => 'used' }, { name => 'free' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_swap_output'),
                  perfdatas => [
                      { label => 'used', value => 'used', template => '%d', min => 0, max => 'total',
                        unit => 'B', cast_int => 1 },
                  ],
              }
          },
          { label => 'usage-free', display_ok => 0, nlabel => 'swap.free.bytes', set => {
                  key_values => [ { name => 'free' }, { name => 'used' }, { name => 'prct_used' }, { name => 'prct_free' }, { name => 'total' } ],
                  closure_custom_output => $self->can('custom_swap_output'),
                  perfdatas => [
                      { label => 'free', value => 'free', template => '%d', min => 0, max => 'total',
                        unit => 'B', cast_int => 1 },
                  ],
              }
          },
          { label => 'usage-prct', display_ok => 0, nlabel => 'swap.usage.percentage', set => {
                  key_values => [ { name => 'prct_used' } ],
                  output_template => 'Used : %.2f %%',
                  perfdatas => [
                      { label => 'used_prct', value => 'prct_used', template => '%.2f', min => 0, max => 100,
                        unit => '%' },
                  ],
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          'no-swap:s' => { name => 'no_swap' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->{no_swap} = 'critical';
      if (defined($self->{option_results}->{no_swap}) && $self->{option_results}->{no_swap} ne '') {
          if ($self->{output}->is_litteral_status(status => $self->{option_results}->{no_swap}) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong --no-swap status '" . $self->{option_results}->{no_swap} . "'.");
              $self->{output}->option_exit();
          }
          $self->{no_swap} = $self->{option_results}->{no_swap};
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $oid_memTotalSwap = '.1.3.6.1.4.1.2021.4.3.0'; # KB
      my $oid_memAvailSwap = '.1.3.6.1.4.1.2021.4.4.0'; # KB
      my $result = $options{snmp}->get_leef(oids => [$oid_memTotalSwap, $oid_memAvailSwap], nothing_quit => 1);
  
      if ($result->{$oid_memTotalSwap} == 0) {
          $self->{output}->output_add(severity => $self->{no_swap},
                                      short_msg => 'No active swap');
          return ;
      }
  
      my $free = $result->{$oid_memAvailSwap} * 1024;
      my $total = $result->{$oid_memTotalSwap} * 1024;
      my $prct_used = ($total - $free) * 100 / $total;
      $self->{swap} = {
          total => $total,
          used => $total - $free,
          free => $free,
          prct_used => $prct_used,
          prct_free => 100 - $prct_used,
      };
  }
  
  1;
  
  
  =head1 MODE
  
  Check swap memory (UCD-SNMP-MIB).
  
  =over 8
  
  =item B<--no-swap>
  
  Threshold if no active swap (default: 'critical').
  
  =item B<--warning-usage>
  
  Threshold in bytes.
  
  =item B<--critical-usage>
  
  Threshold in bytes.
  
  =item B<--warning-usage-free>
  
  Threshold in bytes.
  
  =item B<--critical-usage-free>
  
  Threshold in bytes.
  
  =item B<--warning-usage-prct>
  
  Threshold in percentage.
  
  =item B<--critical-usage-prct>
  
  Threshold in percentage.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_SWAP

$fatpacked{"snmp_standard/mode/uptime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_UPTIME';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  
  
  package snmp_standard::mode::uptime;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use POSIX;
  use centreon::plugins::misc;
  use centreon::plugins::statefile;
  use Time::HiRes qw(time);
  
  my $unitdiv = { s => 1, w => 604800, d => 86400, h => 3600, m => 60 };
  my $unitdiv_long = { s => 'seconds', w => 'weeks', d => 'days', h => 'hours', m => 'minutes' };
  
  sub custom_uptime_output { 
      my ($self, %options) = @_;
  
      my $msg = sprintf(
          'System uptime is: %s',
          centreon::plugins::misc::change_seconds(value => $self->{result_values}->{uptime}, start => 'd')
      );
      if (defined($self->{instance_mode}->{option_results}->{add_sysdesc})) {
          $msg .= sprintf(', %s', $self->{result_values}->{sysdesc});
      }
  
      return $msg;
  }
  
  sub custom_uptime_perfdata {
      my ($self, %options) = @_;
  
      $self->{output}->perfdata_add(
          label => 'uptime', unit => $self->{instance_mode}->{option_results}->{unit},
          nlabel => 'system.uptime.' . $unitdiv_long->{ $self->{instance_mode}->{option_results}->{unit} },
          value => sprintf("%.2f", $self->{result_values}->{uptime} / $unitdiv->{ $self->{instance_mode}->{option_results}->{unit} }),
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
          min => 0
      );
  }
  
  sub custom_uptime_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(
          value => sprintf("%.2f", $self->{result_values}->{uptime} / $unitdiv->{ $self->{instance_mode}->{option_results}->{unit} }),
          threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' },
              { label => 'unknown-'. $self->{thlabel}, exit_litteral => 'unknown' }
          ]
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'uptime', set => {
                  key_values => [ { name => 'uptime' }, { name => 'sysdesc' } ],
                  closure_custom_output => $self->can('custom_uptime_output'),
                  closure_custom_perfdata => $self->can('custom_uptime_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_uptime_threshold')
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'force-oid:s'     => { name => 'force_oid' },
          'check-overload'  => { name => 'check_overload' },
          'reboot-window:s' => { name => 'reboot_window', default => 5000 },
          'unit:s'          => { name => 'unit', default => 's' },
          'add-sysdesc'     => { name => 'add_sysdesc' }
      });
  
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      if ($self->{option_results}->{unit} eq '' || !defined($unitdiv->{$self->{option_results}->{unit}})) {
          $self->{option_results}->{unit} = 's';
      }
  
      $self->{statefile_cache}->check_options(%options);
  }
  
  sub check_overload {
      my ($self, %options) = @_;
      
      return $options{timeticks} if (!defined($self->{option_results}->{check_overload}));
      
      my $current_time = floor(time() * 100);
      $self->{new_datas} = { last_time => $current_time, uptime => $options{timeticks} };
      $self->{statefile_cache}->read(statefile => 'cache_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode});
      my $old_uptime = $self->{statefile_cache}->get(name => 'uptime');
      my $last_time = $self->{statefile_cache}->get(name => 'last_time');
      $self->{new_datas}->{overload} = $self->{statefile_cache}->get(name => 'overload') || 0;
      
      if (defined($old_uptime) && $options{timeticks} < $old_uptime) {
          my $diff_time = $current_time - $last_time;
          my $overflow = ($old_uptime + $diff_time) % 4294967296;
          my $division = ($old_uptime + $diff_time) / 4294967296;
          if ($division >= 1 && 
              $overflow >= ($options{timeticks} - ($self->{option_results}->{reboot_window} / 2)) &&
              $overflow <= ($options{timeticks} + ($self->{option_results}->{reboot_window} / 2))) {
              $self->{new_datas}->{overload}++;
          } else {
              $self->{new_datas}->{overload} = 0;
          }
      }
      $options{timeticks} += ($self->{new_datas}->{overload} * 4294967296);
  
      $self->{statefile_cache}->write(data => $self->{new_datas});
      return $options{timeticks};
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_sysDescr = '.1.3.6.1.2.1.1.1.0';
      my @oids = ();
      if (defined($self->{option_results}->{add_sysdesc})) {
          @oids = ($oid_sysDescr);
      }
  
      # To be used first for OS
      my $oid_hrSystemUptime = '.1.3.6.1.2.1.25.1.1.0';
      # For network equipment or others
      my $oid_sysUpTime = '.1.3.6.1.2.1.1.3.0';
      my ($result, $value);
  
      if (defined($self->{option_results}->{force_oid})) {
          $result = $options{snmp}->get_leef(oids => [ @oids, $self->{option_results}->{force_oid} ], nothing_quit => 1);
          $value = $result->{ $self->{option_results}->{force_oid} };
      } else {
          $result = $options{snmp}->get_leef(oids => [ @oids, $oid_hrSystemUptime, $oid_sysUpTime ], nothing_quit => 1);
          if (defined($result->{$oid_hrSystemUptime})) {
              $value = $result->{$oid_hrSystemUptime};
          } else {
              $value = $result->{$oid_sysUpTime};
          }
      }
  
      $value = $self->check_overload(timeticks => $value, snmp => $options{snmp});
      $value = floor($value / 100);
  
      $self->{global} = { uptime => $value, sysdesc => defined($result->{$oid_sysDescr}) ? $result->{$oid_sysDescr} : '-' };
  }
  
  1;
  
  
  =head1 MODE
  
  Check system uptime.
  
  =over 8
  
  =item B<--warning-uptime>
  
  Warning threshold.
  
  =item B<--critical-uptime>
  
  Critical threshold.
  
  =item B<--add-sysdesc>
  
  Display system description.
  
  =item B<--force-oid>
  
  Can choose your OID (numeric format only).
  
  =item B<--check-overload>
  
  Uptime counter limit is 4294967296 and overflow.
  With that option, we manage the counter going back. But there is a few chance we can miss a reboot.
  
  =item B<--reboot-window>
  
  To be used with check-overload option. Time in milliseconds (default: 5000)
  You increase the chance of not missing a reboot if you decrease that value.
  
  =item B<--unit>
  
  Select the time unit for thresholds. May be 's' for seconds, 'm' for minutes, 'h' for hours, 'd' for days, 'w' for weeks. Default is seconds.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_UPTIME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Copyright 2024 Centreon (http://www.centreon.com/)
#
# Centreon is a full-fledged industry-strength solution that meets
# the needs in IT infrastructure and application monitoring for
# service performance.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
# Not perl embedded compliant at all
use FindBin;
use lib "$FindBin::Bin";
# use lib '/usr/lib/nagios/plugins/';

use centreon::plugins::script;

centreon::plugins::script->new()->run();
