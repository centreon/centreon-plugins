#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"centreon/plugins/alternative/FatPackerOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::FatPackerOptions;
  
  use base qw(centreon::plugins::options);
  
  use strict;
  use warnings;
  use Pod::Usage;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      return $self;
  }
  
  sub display_help {
      my ($self, %options) = @_;
      
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          
          {
              my $pp = $_->{package} . ".pm";
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh,
                        -verbose => 99, 
                        -sections => $_->{sections});
              
              close $str_fh;
          }
          
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_FATPACKEROPTIONS

$fatpacked{"centreon/plugins/alternative/Getopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_ALTERNATIVE_GETOPT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::alternative::Getopt;
  
  use strict;
  use warnings;
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  BEGIN {
      @EXPORT    = qw(&GetOptions);
      @EXPORT_OK = qw();
  }
  
  use vars @EXPORT, @EXPORT_OK;
  
  our $warn_message = 0;
  
  sub get_assigned_value {
      my (%options) = @_;
      
      if (!defined($options{val}) || $options{val} eq '') {
          # Add defined also. Hardened code: already see: $ARGV[6] = undef for example
          if ($options{pos} + 1 < $options{num_args} && defined($ARGV[$options{pos} + 1]) && $ARGV[$options{pos} + 1] !~ /^--/) {
              my $val = $ARGV[$options{pos} + 1];
              splice @ARGV, $options{pos} + 1, 1;
              return ($options{num_args} - 1, $val);
          } else {
              return ($options{num_args}, '');
          }
      }
      
      return ($options{num_args}, $options{val});
  }
  
  sub GetOptions {
      my (%opts) = @_;
  
      my $search_str = ',' . join(',', keys %opts) . ',';
      my $num_args = scalar(@ARGV);
      for (my $i = 0; $i < $num_args;) {
          if (defined($ARGV[$i]) && $ARGV[$i] =~ /^--(.*?)(?:=|$)((?s).*)/) {
              my ($option, $value) = ($1, $2);
  
              # The special argument "--" forces an end of option-scanning.
              # All arguments placed after are stored in a list with the special option key '_double_dash_'.
              if ($option eq '' && $value eq '') {
                  my @values = splice @ARGV, $i + 1, $num_args - $i - 1;
                  push @{${$opts{'_double_dash_'}}}, @values;
                  splice @ARGV, $i, 1;
                  last;
              }
  
              # find type of option
              if ($search_str !~ /,((?:[^,]*?\|){0,}$option(?:\|.*?){0,}(:.*?){0,1}),/) {
  
                  # for old format plugins (with run function) that not allowed list-counters options
                  if($option =~ /list-counters/){
                      warn "list-counters option not available yet for this mode." if ($warn_message == 1);
                  }else{
                      warn "Unknown option: $option" if ($warn_message == 1);
                  }
                  $i++;
                  next;
              }
  
              my ($option_selected, $type_opt) = ($1, $2);
              if (!defined($type_opt)) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned ne '0') {
                      ${$opts{$option_selected}} = 1;
                  }
              } elsif ($type_opt =~ /:s$/) {
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  ${$opts{$option_selected}} = $assigned;
              } elsif ($type_opt =~ /:s\@$/) {
                  ${$opts{$option . $type_opt}} = [] if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  push @{${$opts{$option_selected}}}, $assigned;
              } elsif ($type_opt =~ /:s\%$/) {
                  ${$opts{$option . $type_opt}} = {} if (!defined(${$opts{$option . $type_opt}}));
                  ($num_args, my $assigned) = get_assigned_value(num_args => $num_args, pos => $i, val => $value);
                  if ($assigned =~ /^(.*?)=(.*)/) {
                      ${$opts{$option_selected}}->{$1} = $2;
                  }
              } 
              
              splice @ARGV, $i, 1;
              $num_args--;
          } else {
              warn "argument $ARGV[$i] alone" if ($warn_message == 1 && $i != 0 && defined($ARGV[$i]));
              $i++;
          }
      }
  }
  
  1;
  
CENTREON_PLUGINS_ALTERNATIVE_GETOPT

$fatpacked{"centreon/plugins/backend/http/curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_CURL';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::curl;
  
  use strict;
  use warnings;
  use URI;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'curl-opt:s@' => { name => 'curl_opt' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'BACKEND CURL OPTIONS', once => 1);
      }
  
      $self->{output} = $options{output};
  
      $self->{curl_log} = $options{curl_logger};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output},
          module => 'Net::Curl::Easy',
          error_msg => "Cannot load module 'Net::Curl::Easy'."
      );
      centreon::plugins::misc::mymodule_load(
          output => $self->{output},
          module => 'centreon::plugins::backend::http::curlconstants',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::curlconstants'."
      );
      $self->{constant_cb} = \&centreon::plugins::backend::http::curlconstants::get_constant_value;
  
      foreach (('unknown_status', 'warning_status', 'critical_status')) {
          if (defined($options{request}->{$_})) {
              $options{request}->{$_} =~ s/%\{http_code\}/\$values->{code}/g;
          }
      }
  
      if (!defined($options{request}->{curl_opt})) {
          $options{request}->{curl_opt} = [];
      }
  }
  
  my $http_code_explained = {
      100 => 'Continue',
      101 => 'Switching Protocols',
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      306 => '(Unused)',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Long',
      415 => 'Unsupported Media Type',
      416 => 'Requested Range Not Satisfiable',
      417 => 'Expectation Failed',
      450 => 'Timeout reached', # custom code
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported'
  };
  
  sub cb_debug {
      my ($easy, $type, $data, $uservar) = @_;
  
      my $msg = '';
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_TEXT')) {
          $msg = sprintf("== Info: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_HEADER_OUT')) {
          $msg = sprintf("=> Send header: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_DATA_OUT')) {
          $msg = sprintf("=> Send data: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_HEADER_IN')) {
          $msg = sprintf("=> Recv header: %s", $data);
      }
      if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_DATA_IN')) {
          $msg = sprintf("=> Recv data: %s", $data);
      }
      return 0 if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_SSL_DATA_OUT'));
      return 0 if ($type == $uservar->{constant_cb}->(name => 'CURLINFO_SSL_DATA_IN'));
  
      $uservar->{output}->output_add(long_msg => $msg, debug => 1);
      return 0;
  }
  
  sub curl_setopt {
      my ($self, %options) = @_;
  
      eval {
          $self->{curl_easy}->setopt($options{option}, $options{parameter});
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "curl setopt error: '" . $@ . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set_method {
      my ($self, %options) = @_;
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => undef);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => undef);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPGET'), parameter => 1);
  
      my $skip_log_post = 0;
      # POST inferred by CURLOPT_POSTFIELDS
      if ($options{content_type_forced} == 1) {
          if (defined($options{request}->{query_form_post})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => $options{request}->{query_form_post});
              $self->{curl_log}->log("--data-raw", $options{request}->{query_form_post});
              $skip_log_post = 1;
          }
      } elsif (defined($options{request}->{post_params})) {
          my $uri_post = URI->new();
          $uri_post->query_form($options{request}->{post_params});
          my $urlencodedheader = 'Content-Type: application/x-www-form-urlencoded';
          push @{$options{headers}}, $urlencodedheader;
  
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POSTFIELDS'), parameter => $uri_post->query);
          $self->{curl_log}->log("-H", $urlencodedheader);
  
          $self->{curl_log}->log("--data-raw", $uri_post->query);
          $skip_log_post = 1;
      }
  
      if ($options{request}->{method} eq 'GET') {
          # no curl_log call because GET is the default value
          return;
      }
  
      if ($options{request}->{method} eq 'POST') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_POST'), parameter => 1);
          $self->{curl_log}->log('-X', $options{request}->{method}) unless $skip_log_post;
          return;
      }
  
      $self->{curl_log}->log('-X', $options{request}->{method});
      if ($options{request}->{method} eq 'PUT') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
      if ($options{request}->{method} eq 'DELETE') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
      if ($options{request}->{method} eq 'PATCH') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CUSTOMREQUEST'), parameter => $options{request}->{method});
      }
  }
  
  sub set_auth {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{credentials})) {
          if (defined($options{request}->{basic})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_BASIC'));
              $self->{curl_log}->log('--basic');
          } elsif (defined($options{request}->{ntlmv2})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_NTLM'));
              $self->{curl_log}->log('--ntlm');
          } elsif (defined($options{request}->{digest})) {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_DIGEST'));
              $self->{curl_log}->log('--digest');
          }else {
              $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPAUTH'), parameter => $self->{constant_cb}->(name => 'CURLAUTH_ANY'));
              $self->{curl_log}->log('--anyauth');
          }
          my $userpassword = $options{request}->{username}  . ':' . $options{request}->{password};
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_USERPWD'), parameter => $userpassword);
          $self->{curl_log}->log('--user', $userpassword);
      }
  
      if (defined($options{request}->{cert_file}) &&  $options{request}->{cert_file} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERT'), parameter => $options{request}->{cert_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLKEY'), parameter => $options{request}->{key_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_KEYPASSWD'), parameter => $options{request}->{cert_pwd});
  
          $self->{curl_log}->log('--cert', $options{request}->{cert_file});
          $self->{curl_log}->log('--key', $options{request}->{key_file});
          $self->{curl_log}->log('--pass', $options{request}->{cert_pwd}) if defined $options{request}->{cert_pwd} && $options{request}->{cert_pwd} ne '';
      }
  
      if (defined($options{request}->{cert_pkcs12})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERTTYPE'), parameter => "P12");
          $self->{curl_log}->log('--cert-type', 'p12');
      } else {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSLCERTTYPE'), parameter => "PEM");
          # no curl_log call because PEM is the default value
      }
  }
  
  sub set_form {
      my ($self, %options) = @_;
  
      if (!defined($self->{form_loaded})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Net::Curl::Form',
              error_msg => "Cannot load module 'Net::Curl::Form'."
          );
          $self->{form_loaded} = 1;
      }
  
      my $form = Net::Curl::Form->new();
      foreach (@{$options{form}}) {
          my %args = ();
          $args{ $self->{constant_cb}->(name => 'CURLFORM_COPYNAME()') } = $_->{copyname}
              if (defined($_->{copyname}));
          $args{ $self->{constant_cb}->(name => 'CURLFORM_COPYCONTENTS()') } = $_->{copycontents}
              if (defined($_->{copycontents}));
          $form->add(%args);
  
          $self->{curl_log}->log("--form-string", $_->{copyname}."=".$_->{copycontents})
              if defined($_->{copyname}) && defined($_->{copycontents});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HTTPPOST()'), parameter => $form);
  }
  
  sub set_proxy {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{proxyurl}) && $options{request}->{proxyurl} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_PROXY'), parameter => $options{request}->{proxyurl});
          $self->{curl_log}->log("--proxy", $options{request}->{proxyurl});
      }
  
      if (defined($options{request}->{proxypac}) && $options{request}->{proxypac} ne '') {
          $self->{output}->add_option_msg(short_msg => 'Unsupported proxypac option');
          $self->{output}->option_exit();
      }
  }
  
  sub set_extra_curl_opt {
      my ($self, %options) = @_;
  
      my $entries = {};
      foreach (@{$options{request}->{curl_opt}}) {
          my ($key, $value) = split /=>/;
          $key = centreon::plugins::misc::trim($key);
  
          if (!defined($entries->{$key})) {
              $entries->{$key} = { val => [], constants => [], force_array => 0 };
          }
  
          $value = centreon::plugins::misc::trim($value);
  
          # Here we want to convert a string containing curl options into a single value or into
          # an array of values depending on whether it begins with '[' and ends with ']'.
          # We also remove the quotes.
          # for example:
          #
          # $opt = ["CURLOPT_SSL_VERIFYPEER =>[opt1,'opt2','opt3']"];
          # is converted to a Perl array like this:
          # $VAR1 = [
          #  'opt1',
          #  'opt2',
          #  'opt3'
          # ];
          #
          # $opt = [ "CURLOPT_SSL_VERIFYPEER => 'opt1'" ];
          # is converted to:
          # $VAR1 = 'opt1';
          if ($value =~ /^\[(.*)\]$/) {
              $entries->{$key}->{force_array} = 1;
              $value = centreon::plugins::misc::trim($1);
              push @{$entries->{$key}->{constants}}, map { $_ = centreon::plugins::misc::trim($_); s/^'(.*)'$/$1/; $_  } split ',', $value;
          } else {
              push @{$entries->{$key}->{constants}}, $value =~ /^'(.*)'$/ ? $1 : $value;
          }
  
          if ($value  =~ /^CURLOPT|CURL/) {
              $value = $self->{constant_cb}->(name => $value);
          }
  
          push @{$entries->{$key}->{val}}, $value; 
      }
  
      foreach (keys %$entries) {
          my $key = $_;
  
          if ($self->{curl_log}->is_enabled()) {
              $self->{curl_log}->convert_curlopt_to_cups_parameter(
                  key => $key,
                  parameter => $entries->{$key}->{constants},
              );
          }
  
          if (/^CURLOPT|CURL/) {
              $key = $self->{constant_cb}->(name => $_);
          }
  
          my $parameter;
          if ($entries->{$_}->{force_array} == 1 || scalar(@{$entries->{$_}->{val}}) > 1) {
              $parameter = $entries->{$_}->{val};
          } else {
              $parameter = pop @{$entries->{$_}->{val}};
          }
          $self->curl_setopt(option => $key, parameter => $parameter);
  
      }
  }
  
  sub cb_get_header {
      my ($easy, $header, $uservar) = @_;
  
      $header =~ s/[\r\n]//g;
      if ($header =~ /^[\r\n]*$/) {
          $uservar->{nheaders}++;
      } else {
          $uservar->{response_headers}->[$uservar->{nheaders}] = {}
              if (!defined($uservar->{response_headers}->[$uservar->{nheaders}]));
          if ($header =~  /^(\S(?:.*?))\s*:\s*(.*)/) {
              my $header_name = lc($1);
              $uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name} = []
                  if (!defined($uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name}));
              push @{$uservar->{response_headers}->[$uservar->{nheaders}]->{$header_name}}, $2;
          } else {
             $uservar->{response_headers}->[$uservar->{nheaders}]->{response_line} = $header; 
          }
      }
  
      return length($_[1]);
  }
  
  sub request {
      my ($self, %options) = @_;
  
      # Enable curl logger when debug mode is on
      $self->{curl_log}->init( enabled => $self->{output}->is_debug() );
  
      if (!defined($self->{curl_easy})) {
          $self->{curl_easy} = Net::Curl::Easy->new();
      }
  
      my $url;
      if (defined($options{request}->{full_url})) {
          $url = $options{request}->{full_url};
      } elsif (defined($options{request}->{port}) && $options{request}->{port} =~ /^[0-9]+$/) {
          $url = $options{request}->{proto}. "://" . $options{request}->{hostname} . ':' . $options{request}->{port} . $options{request}->{url_path};
      } else {
          $url = $options{request}->{proto}. "://" . $options{request}->{hostname} . $options{request}->{url_path};
      }
  
      my $uri = URI->new($url);
      if (defined($options{request}->{get_params})) {
          $uri->query_form($options{request}->{get_params});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_URL'), parameter => $uri);
  
      $self->{curl_log}->log($uri);
  
      if ($self->{output}->is_debug()) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_DEBUGFUNCTION'), parameter => \&cb_debug);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_DEBUGDATA'), parameter => $self);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_VERBOSE'), parameter => 1);
  
          $self->{curl_log}->log('--verbose');
      }
  
      if (defined($options{request}->{timeout}) && $options{request}->{timeout} =~ /\d/) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_TIMEOUT'), parameter => $options{request}->{timeout});
          $self->{curl_log}->log("--max-time", $options{request}->{timeout});
      }
  
      if (defined($options{request}->{cookies_file})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_COOKIEFILE'), parameter => $options{request}->{cookies_file});
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_COOKIEJAR'), parameter => $options{request}->{cookies_file});
          $self->{curl_log}->log('--cookie', $options{request}->{cookies_file});
          $self->{curl_log}->log('--cookie-jar', $options{request}->{cookies_file});
      }
  
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FOLLOWLOCATION'), parameter => 1);
      if (defined($options{request}->{no_follow})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FOLLOWLOCATION'), parameter => 0);
      } else {
          $self->{curl_log}->log('-L');
      }
  
      if (defined($options{request}->{http_peer_addr}) && $options{request}->{http_peer_addr} ne '') {
          $url =~ /^(?:http|https):\/\/(.*?)(\/|\:|$)/;
          my $resolve = $1 . ':' . $options{request}->{port_force} . ':' . $options{request}->{http_peer_addr};
          $self->{curl_easy}->setopt(
              $self->{constant_cb}->(name => 'CURLOPT_RESOLVE'),
              [$resolve]
          );
          $self->{curl_log}->log('--resolve', $resolve);
      }    
  
      my $headers = [];
      my $content_type_forced = 0;
      foreach my $key (keys %{$options{request}->{headers}}) {
          my $header = $key . ':' . (defined($options{request}->{headers}->{$key}) ? ' '.$options{request}->{headers}->{$key} : '');
          push @$headers, $header;
          if ($key =~ /content-type/i) {
              $content_type_forced = 1;
          }
          $self->{curl_log}->log("-H", $header);
      }
  
      $self->set_method(%options, content_type_forced => $content_type_forced, headers => $headers);
  
      if (defined($options{request}->{form})) {
          $self->set_form(form => $options{request}->{form});
      }
  
      if (scalar(@$headers) > 0) {
          $self->{curl_easy}->setopt($self->{constant_cb}->(name => 'CURLOPT_HTTPHEADER'), $headers);
      }
  
      if (defined($options{request}->{cacert_file}) && $options{request}->{cacert_file} ne '') {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CAINFO'), parameter => $options{request}->{cacert_file});
          $self->{curl_log}->log('--cacert', $options{request}->{cacert_file});
      }
      if (defined($options{request}->{insecure})) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSL_VERIFYPEER'), parameter => 0);
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_SSL_VERIFYHOST'), parameter => 0);
          $self->{curl_log}->log('--insecure');
      }
  
      $self->set_auth(%options);
      $self->set_proxy(%options);
      $self->set_extra_curl_opt(%options);
      $self->{response_body} = '';
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_FILE'), parameter => \$self->{response_body});
      $self->{nheaders} = 0;
      $self->{response_headers} = [{}];
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HEADERDATA'), parameter => $self);
      $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_HEADERFUNCTION'), parameter => \&cb_get_header);
  
      if (defined($options{request}->{certinfo}) && $options{request}->{certinfo} == 1) {
          $self->curl_setopt(option => $self->{constant_cb}->(name => 'CURLOPT_CERTINFO'), parameter => 1);
          # no curl_log call because there is no equivalent in command line
      }
  
      $self->{response_code} = undef;
  
      if ($self->{curl_log}->is_enabled()) {
          $self->{output}->output_add(long_msg => 'curl request [curl backend]: ' . $self->{curl_log}->get_log());
      }
  
      eval {
          $self->{curl_easy}->perform();
      };
      if ($@) {
          my $err = $@;
          if (ref($@) eq "Net::Curl::Easy::Code") {
              my $num = $@;
              if ($num == $self->{constant_cb}->(name => 'CURLE_OPERATION_TIMEDOUT')) {
                  $self->{response_code} = 450;
              }
          }
  
          if (!defined($self->{response_code})) {
              $self->{output}->add_option_msg(short_msg => 'curl perform error : ' . $err);
              $self->{output}->option_exit();
          }
      }
  
      $self->{response_code} = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_RESPONSE_CODE'))
          if (!defined($self->{response_code}));
  
      # Check response
      my $status = 'ok';
      if (defined($options{request}->{critical_status}) && $options{request}->{critical_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{critical_status}, values => { code => $self->{response_code} })) {
          $status = 'critical';
      } elsif (defined($options{request}->{warning_status}) && $options{request}->{warning_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{warning_status}, values => { code => $self->{response_code} })) {
          $status = 'warning';
      } elsif (defined($options{request}->{unknown_status}) && $options{request}->{unknown_status} ne '' &&
          $self->{output}->test_eval(test => $options{request}->{unknown_status}, values => { code => $self->{response_code} })) {
          $status = 'unknown';
      }
  
      if (!$options{request}->{silently_fail} && !$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          my $short_msg = $self->{response_code} . ' ' . 
              (defined($http_code_explained->{$self->{response_code}}) ? $http_code_explained->{$self->{response_code}} : 'unknown');
  
          $self->{output}->output_add(
              severity => $status,
              short_msg => $short_msg
          );
          $self->{output}->display();
          $self->{output}->exit();
      }
  
      return $self->{response_body};
  }
  
  sub get_headers {
      my ($self, %options) = @_;
  
      my $headers = '';
      foreach (keys %{$self->{response_headers}->[$options{nheader}]}) {
          next if (/response_line/);
          foreach my $value (@{$self->{response_headers}->[$options{nheader}]->{$_}}) {
              $headers .= "$_: " . $value . "\n";
          }
      }
  
      return $headers;
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(nheader => 0);
      }
  
      return undef
          if (!defined($self->{response_headers}->[0]->{ lc($options{name}) }));
      return wantarray ? @{$self->{response_headers}->[0]->{ lc($options{name}) }} : $self->{response_headers}->[0]->{ lc($options{name}) }->[0];
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(nheader => -1);
      }
  
      return undef
          if (!defined($self->{response_headers}->[-1]->{ lc($options{name}) }));
      return wantarray ? @{$self->{response_headers}->[-1]->{ lc($options{name}) }} : $self->{response_headers}->[-1]->{ lc($options{name}) }->[0];
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{response_code};
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return defined($http_code_explained->{$self->{response_code}}) ? $http_code_explained->{$self->{response_code}} : 'Unknown code';
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      my $certs = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_CERTINFO'));
      return ('pem', $certs->[0]->{Cert});
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      # TIME_T = 7.61.0
      my $resolve = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_NAMELOOKUP_TIME'));
      my $connect = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_CONNECT_TIME'));
      my $appconnect = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_APPCONNECT_TIME'));
      my $start = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_STARTTRANSFER_TIME'));
      my $total = $self->{curl_easy}->getinfo($self->{constant_cb}->(name => 'CURLINFO_TOTAL_TIME'));
      my $times = {
          resolve => $resolve * 1000,
          connect => ($connect - $resolve) * 1000,
          transfer => ($total - $start) * 1000
      };
      if ($appconnect > 0) {
          $times->{tls} = ($appconnect - $connect) * 1000;
          $times->{processing} = ($start - $appconnect) * 1000;
      } else {
          $times->{processing} = ($start - $connect) * 1000;
      }
  
      return $times;
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP Curl backend layer.
  
  =head1 SYNOPSIS
  
  HTTP Curl backend layer.
  
  =head1 BACKEND CURL OPTIONS
  
  =over 8
  
  =item B<--curl-opt>
  
  Set CURL Options (--curl-opt="CURLOPT_SSL_VERIFYPEER => 0" --curl-opt="CURLOPT_SSLVERSION => CURL_SSLVERSION_TLSv1_1" ).
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_BACKEND_HTTP_CURL

$fatpacked{"centreon/plugins/backend/http/curlconstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_CURLCONSTANTS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::curlconstants;
  
  use strict;
  use warnings;
  use Net::Curl::Easy qw(:constants);
  use Net::Curl::Form qw(:constants);
  
  sub get_constant_value {
      my (%options) = @_;
  
      return eval $options{name};
  }
  
  1;
CENTREON_PLUGINS_BACKEND_HTTP_CURLCONSTANTS

$fatpacked{"centreon/plugins/backend/http/lwp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_LWP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::lwp;
  
  use strict;
  use warnings;
  use centreon::plugins::backend::http::useragent;
  use URI;
  use IO::Socket::SSL;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'ssl:s'      => { name => 'ssl' },
              'ssl-opt:s@' => { name => 'ssl_opt' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'BACKEND LWP OPTIONS', once => 1);
      }
  
      $self->{output} = $options{output};
      $self->{ua} = undef;
      $self->{debug_handlers} = 0;
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      foreach (('unknown_status', 'warning_status', 'critical_status')) {
          if (defined($options{request}->{$_})) {
              $options{request}->{$_} =~ s/%\{http_code\}/\$values->{code}/g;
          }
      }
  
      $self->{ssl_context} = '';
      if (!defined($options{request}->{ssl_opt})) {
          $options{request}->{ssl_opt} = [];
      }
      if (defined($options{request}->{ssl}) && $options{request}->{ssl} ne '') {
          push @{$options{request}->{ssl_opt}}, 'SSL_version => ' . $options{request}->{ssl};
      }
      if (defined($options{request}->{cert_file}) && !defined($options{request}->{cert_pkcs12})) {
          push @{$options{request}->{ssl_opt}}, 'SSL_use_cert => 1';
          push @{$options{request}->{ssl_opt}}, 'SSL_cert_file => "' . $options{request}->{cert_file} . '"';
          push @{$options{request}->{ssl_opt}}, 'SSL_key_file => "' . $options{request}->{key_file} . '"'
               if (defined($options{request}->{key_file}));
          push @{$options{request}->{ssl_opt}}, 'SSL_ca_file => "' . $options{request}->{cacert_file} . '"'
              if (defined($options{request}->{cacert_file}));
      }
      if ($options{request}->{insecure}) {
          push @{$options{request}->{ssl_opt}}, 'SSL_verify_mode => SSL_VERIFY_NONE';
      }
  
      my $append = '';
      foreach (@{$options{request}->{ssl_opt}}) {
          if ($_ ne '') {
              $self->{ssl_context} .= $append . $_;
              $append = ', ';
          }
      }
  }
  
  sub set_proxy {
      my ($self, %options) = @_;
  
      if (defined($options{request}->{proxypac}) && $options{request}->{proxypac} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'HTTP::ProxyPAC',
              error_msg => "Cannot load module 'HTTP::ProxyPAC'."
          );
          my ($pac, $pac_uri);
          eval {
              if ($options{request}->{proxypac} =~ /^(http|https):\/\//) {
                  $pac_uri = URI->new($options{request}->{proxypac});
                  $pac = HTTP::ProxyPAC->new($pac_uri);
              } else {
                  $pac = HTTP::ProxyPAC->new($options{request}->{proxypac});
              }
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => 'issue to load proxypac: ' . $@);
              $self->{output}->option_exit();
          }
          my $res = $pac->find_proxy($options{url});
          if (defined($res->direct) && $res->direct != 1) {
              my $proxy_uri = URI->new($res->proxy);
              $proxy_uri->userinfo($pac_uri->userinfo) if (defined($pac_uri->userinfo));
              $self->{ua}->proxy(['http', 'https'], $proxy_uri->as_string);
          }
      }
      if (defined($options{request}->{proxyurl}) && $options{request}->{proxyurl} ne '') {
          my $proxyurl = $options{request}->{proxyurl};
          if ($options{request}->{proto} eq "https" ||
              (defined($options{request}->{full_url}) && $options{request}->{full_url} =~ /^https/)) {
              $proxyurl = 'connect://' . $2 if ($proxyurl =~ /^(http|https):\/\/(.*)/);
          }
          $self->{ua}->proxy(['http', 'https'], $proxyurl);
      }
  }
  
  sub request {
      my ($self, %options) = @_;
  
      my %user_agent_params = (keep_alive => 1);
      if (defined($options{request}->{certinfo}) && $options{request}->{certinfo} == 1) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'LWP::ConnCache',
              error_msg => "Cannot load module 'LWP::ConnCache'."
          );
          $self->{cache} = LWP::ConnCache->new();
          $self->{cache}->total_capacity(1);
          %user_agent_params = (conn_cache => $self->{cache});
      }
  
      my $request_options = $options{request};
      if (!defined($self->{ua})) {
          my $timeout;
          $timeout = $1 if (defined($request_options->{timeout}) && $request_options->{timeout} =~ /(\d+)/);
          $self->{ua} = centreon::plugins::backend::http::useragent->new(
              %user_agent_params,
              protocols_allowed => ['http', 'https'], 
              timeout => $timeout,
              credentials => $request_options->{credentials},
              username => $request_options->{username}, 
              password => $request_options->{password}
          );
          if (defined($request_options->{cookies_file})) {
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output},
                  module => 'HTTP::Cookies',
                  error_msg => "Cannot load module 'HTTP::Cookies'."
              );
              $self->{ua}->cookie_jar(
                  HTTP::Cookies->new(
                      file => $request_options->{cookies_file},
                      autosave => 1
                  )
              );
          }
      }
  
      if ($self->{output}->is_debug() && $self->{debug_handlers} == 0) {
          $self->{debug_handlers} = 1;
          $self->{ua}->add_handler('request_send', sub {
              my ($response, $ua, $handler) = @_;
  
              $self->{output}->output_add(long_msg => '======> request send', debug => 1);
              $self->{output}->output_add(long_msg => $response->as_string, debug => 1);
              return ; 
          });
          $self->{ua}->add_handler("response_done", sub { 
              my ($response, $ua, $handler) = @_;
  
              $self->{output}->output_add(long_msg => '======> response done', debug => 1);
              $self->{output}->output_add(long_msg => $response->as_string, debug => 1);
              return ;
          });
      }
  
      if (defined($request_options->{no_follow})) {
          $self->{ua}->requests_redirectable(undef);
      } else {
          $self->{ua}->requests_redirectable([ 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH' ]);
      }
      if (defined($request_options->{http_peer_addr})) {
          push @LWP::Protocol::http::EXTRA_SOCK_OPTS, PeerAddr => $request_options->{http_peer_addr};
      }
  
      my ($req, $url);
      if (defined($request_options->{full_url})) {
          $url = $request_options->{full_url};
      } elsif (defined($request_options->{port}) && $request_options->{port} =~ /^[0-9]+$/) {
          $url = $request_options->{proto}. '://' . $request_options->{hostname} . ':' . $request_options->{port} . $request_options->{url_path};
      } else {
          $url = $request_options->{proto}. '://' . $request_options->{hostname} . $request_options->{url_path};
      }
  
      my $uri = URI->new($url);
      if (defined($request_options->{get_params})) {
          $uri->query_form($request_options->{get_params});
      }
  
      $req = HTTP::Request->new($request_options->{method}, $uri);
  
      my $content_type_forced = 0;
      foreach my $key (keys %{$request_options->{headers}}) {
          $req->header($key => $request_options->{headers}->{$key});
          if ($key =~ /content-type/i) {
              $content_type_forced = 1;
          }
      }
  
      if ($content_type_forced == 1) {
          $req->content($request_options->{query_form_post});
      } elsif (defined($options{request}->{post_params})) {
          my $uri_post = URI->new();
          $uri_post->query_form($request_options->{post_params});
          $req->content_type('application/x-www-form-urlencoded');
          $req->content($uri_post->query);
      }
  
      if (defined($request_options->{form})) {
          $self->{output}->add_option_msg(short_msg => 'unsupported form param');
          $self->{output}->option_exit();
      }
  
      if (defined($request_options->{credentials}) && defined($request_options->{ntlmv2})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Authen::NTLM',
              error_msg => "Cannot load module 'Authen::NTLM'."
          );
          Authen::NTLM::ntlmv2(1);
      }
  
      if (defined($request_options->{credentials}) && (defined($request_options->{basic}) || defined($request_options->{digest}))) {
          $req->authorization_basic($request_options->{username}, $request_options->{password});
      }
  
      $self->set_proxy(request => $request_options, url => $url);
  
      if (defined($request_options->{cert_pkcs12}) && $request_options->{cert_file} ne '' && $request_options->{cert_pwd} ne '') {
          eval 'use Net::SSL'; die $@ if $@;
          $ENV{HTTPS_PKCS12_FILE} = $request_options->{cert_file};
          $ENV{HTTPS_PKCS12_PASSWORD} = $request_options->{cert_pwd};
      }
  
      if (defined($self->{ssl_context}) && $self->{ssl_context} ne '') {
          my $context = new IO::Socket::SSL::SSL_Context(eval $self->{ssl_context});
          IO::Socket::SSL::set_default_context($context);
      }
  
      $self->{response} = $self->{ua}->request($req);
  
      $self->{response_code} = $self->{response}->code();
      $self->{response_message} = $self->{response}->message();
      $self->{headers} = $self->{response}->headers();
  
      if ($self->{response_code} == 500) {
          my $client_warning = $self->get_header(name => 'Client-Warning');
          if (defined($client_warning) && $client_warning eq 'Internal response' && $self->{response_message} =~ /connection timed out/mi) {
              $self->{response_code} = 450;
              $self->{response_message} = 'Timeout reached';
          }
      }
  
      # Check response
      my $status = 'ok';
      if (defined($request_options->{critical_status}) && $request_options->{critical_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{critical_status}, values => { code => $self->{response_code} })) {
          $status = 'critical';
      } elsif (defined($request_options->{warning_status}) && $request_options->{warning_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{warning_status}, values => { code => $self->{response_code} })) {
          $status = 'warning';
      } elsif (defined($request_options->{unknown_status}) && $request_options->{unknown_status} ne '' &&
          $self->{output}->test_eval(test => $request_options->{unknown_status}, values => { code => $self->{response_code} })) {
          $status = 'unknown';
      }
      if (!$request_options->{silently_fail} && !$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          my $short_msg = $self->{response}->status_line;
          if ($short_msg =~ /^401/) {
              $short_msg .= ' (' . $1 . ' authentication expected)' if (defined($self->{response}->www_authenticate) &&
                  $self->{response}->www_authenticate =~ /(\S+)/);
          }
  
          $self->{output}->output_add(
              severity => $status,
              short_msg => $short_msg
          );
          $self->{output}->display();
          $self->{output}->exit();
      }
  
      return $self->{response}->content;
  }
  
  sub get_headers {
      my ($self, %options) = @_;
  
      my $headers = '';
      foreach ($options{response}->header_field_names()) {
          my $value = $options{response}->header($_);
          $headers .= "$_: " . (defined($value) ? $value : '') . "\n";
      }
  
      return $headers;
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      my @redirects = $self->{response}->redirects();
      if (!defined($options{name})) {
          return $self->get_headers(response => defined($redirects[0]) ? $redirects[0] : $self->{response});
      }
  
      return
          defined($redirects[0]) ? 
          $redirects[0]->headers()->header($options{name}) :
          $self->{headers}->header($options{name})
      ;
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      if (!defined($options{name})) {
          return $self->get_headers(response => $self->{response});
      }
      return $self->{headers}->header($options{name});
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{response_code};
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return $self->{response_message};
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      my ($con) = $self->{cache}->get_connections('https');
      return ('socket', $con);
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      return undef;
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP LWP backend layer.
  
  =head1 SYNOPSIS
  
  HTTP LWP backend layer.
  
  =head1 BACKEND LWP OPTIONS
  
  =over 8
  
  =item B<--ssl-opt>
  
  Set SSL Options (--ssl-opt="SSL_version => TLSv1" --ssl-opt="SSL_verify_mode => SSL_VERIFY_NONE").
  
  =item B<--ssl>
  
  Set SSL version (--ssl=TLSv1).
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_BACKEND_HTTP_LWP

$fatpacked{"centreon/plugins/backend/http/useragent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_BACKEND_HTTP_USERAGENT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::backend::http::useragent;
  
  use strict;
  use warnings;
  use base 'LWP::UserAgent';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self = LWP::UserAgent::new(@_);
      $self->agent("centreon::plugins::backend::http::useragent");
  
      $self->{credentials} = $options{credentials} if defined($options{credentials});
      $self->{username} = $options{username} if defined($options{username});
      $self->{password} = $options{password} if defined($options{password});
  
      return $self;
  }
  
  sub get_basic_credentials {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->{username}, $self->{password} if $self->{credentials} and wantarray;
      return $self->{username} . ':' . $self->{password} if $self->{credentials};
      return undef;
  }
  
  1;
CENTREON_PLUGINS_BACKEND_HTTP_USERAGENT

$fatpacked{"centreon/plugins/constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_CONSTANTS';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  #
  
  package centreon::plugins::constants;
  
  use strict;
  use warnings;
  use Exporter qw(import);
  
  use constant {
      BUFFER_CREATION => -1,
      NO_VALUE => -10,
  
      MSG_JSON_DECODE_ERROR => 'Cannot decode response (add --debug option to display returned content)'
  };
  
  our %EXPORT_TAGS = (
      values => [ qw(NO_VALUE BUFFER_CREATION) ],
      messages => [ qw(MSG_JSON_DECODE_ERROR) ]
  );
  $EXPORT_TAGS{all} = [ map { @$_ } values %EXPORT_TAGS ];
  
  our @EXPORT_OK = @{$EXPORT_TAGS{all}};
  
  1;
CENTREON_PLUGINS_CONSTANTS

$fatpacked{"centreon/plugins/curllogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_CURLLOGGER';
  #
  # Copyright 2025 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::curllogger;
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{log_as_curl} = [];
      $self->{is_log_as_curl} = 0;
  
      # As this is only used for debugging purposes, we disable it if the ShellQuote
      # module is missing
      eval "use String::ShellQuote";
      if ($@) {
          $self->{is_log_as_curl} = -1;
      }
  
      $self;
  }
  
  sub init {
      my ($self, %options) = @_;
  
      $self->{log_as_curl} = [];
      return if $self->{is_log_as_curl} == -1;
  
      $self->{is_log_as_curl} = $options{enabled} || 0;
  }
  
  sub is_enabled {
      my ($self) = @_;
  
      return $self->{is_log_as_curl} == 1;
  }
  
  sub log {
      my ($self, @params) = @_;
  
      return unless $self->{is_log_as_curl} == 1 && @params;
  
      push @{$self->{log_as_curl}}, shell_quote(@params);
  }
  
  sub get_log {
      my ($self) = @_;
  
      return "curl ".join ' ', @{$self->{log_as_curl}};
  }
  
  # Conversion of some parameters manually passed to the set_extra_curl_opt function
  # into their command-line equivalents. Only the parameters used in the plugin code
  # are handled. If new parameters are added, this hash must be updated.
  # The hash contains curl parameters CURLOPT_*. Its keys map to either a hash when
  # multiple values are handled, or directly to an array when only one response is
  # supported. The placeholder <value> is replaced by the provided value.
  # Eg: "CURLOPT_POSTREDIR => CURL_REDIR_POST_ALL" will produce: --post301 --post302 --post303
  #     "CURLOPT_SSL_VERIFYPEER => 0" will produce: --insecure
  #     "CURLOPT_AWS_SIGV4 => 'osc'" will produce: --aws-sigv4 osc
  our %curlopt_to_parameter = (
     'CURLOPT_POSTREDIR' => { 'CURL_REDIR_POST_ALL' => [ '--post301', '--post302', '--post303', ],
                              'CURL_REDIR_POST_301' => [ '--post301' ],
                              'CURL_REDIR_POST_302' => [ '--post302' ],
                              'CURL_REDIR_POST_303' => [ '--post303' ],
                            },
     'CURLOPT_SSLVERSION' => { 'CURL_SSLVERSION_TLSv1_0' => [ '--tlsv1.0' ],
                               'CURL_SSLVERSION_TLSv1_1' => [ '--tlsv1.1' ],
                               'CURL_SSLVERSION_TLSv1_2' => [ '--tlsv1.2' ],
                               'CURL_SSLVERSION_TLSv1_3' => [ '--tlsv1.3' ],
                             },
     'CURLOPT_SSL_VERIFYPEER' => { '0' => [ '--insecure' ] },
     'CURLOPT_SSL_VERIFYHOST' => { '0' => [ '--insecure' ] },
  
     'CURLOPT_AWS_SIGV4' => [ '--aws-sigv4', '<value>' ],
  );
  
  sub convert_curlopt_to_cups_parameter {
      my ($self, %options) = @_;
  
      my $key = $options{key};
  
      return unless exists $curlopt_to_parameter{$key};
  
      # we want an array of parameters
      my $parameters = ref $options{parameter} eq 'ARRAY' ? $options{parameter} : [ $options{parameter} ] ;
  
      my @cups_parameters ;
      if (ref $curlopt_to_parameter{$key} eq 'ARRAY') {
          @cups_parameters = map { s/<value>/$parameters->[0]/; $_ } @{$curlopt_to_parameter{$key}};
      } else {
          foreach my $parameter (@$parameters) {
              if (exists $curlopt_to_parameter{$key}->{$parameter}) {
                  push @cups_parameters, @{$curlopt_to_parameter{$key}->{$parameter}};
              } elsif ($parameter =~ /^-/) {
                  push @cups_parameters, $parameter;
              }
          }
      }
      $self->log($_) for @cups_parameters;
  }
  
  1;
  
CENTREON_PLUGINS_CURLLOGGER

$fatpacked{"centreon/plugins/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_HTTP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::http;
  
  use strict;
  use warnings;
  
  use centreon::plugins::curllogger;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{noptions}) || $options{noptions} != 1) {
          $options{options}->add_options(arguments => {
              'http-peer-addr:s'  => { name => 'http_peer_addr' },
              'proxyurl:s'        => { name => 'proxyurl' },
              'proxypac:s'        => { name => 'proxypac' },
              'insecure'          => { name => 'insecure' },
              'http-backend:s'    => { name => 'http_backend' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'HTTP GLOBAL OPTIONS');
      }
  
      my $curllogger = centreon::plugins::curllogger->new();
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output},
          module => 'centreon::plugins::backend::http::lwp',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::lwp'."
      );
      $self->{backend_lwp} = centreon::plugins::backend::http::lwp->new(%options);
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output},
          module => 'centreon::plugins::backend::http::curl',
          error_msg => "Cannot load module 'centreon::plugins::backend::http::curl'."
      );
      $self->{backend_curl} = centreon::plugins::backend::http::curl->new(%options, curl_logger => $curllogger);
  
      $self->{default_backend} = defined($options{default_backend}) && $options{default_backend} ne '' ?
          $options{default_backend} : 'lwp';
      $self->{output} = $options{output};
      $self->{options} = {
          proto => 'http',
          url_path => '/',
          timeout => 5,
          method => 'GET',
          unknown_status => '%{http_code} < 200 or %{http_code} >= 300',
          warning_status => undef,
          critical_status => undef,
      };
  
      $self->{add_headers} = {};
      return $self;
  }
  
  sub set_options {
      my ($self, %options) = @_;
  
      $self->{options} = { %{$self->{options}} };
      foreach (keys %options) {
          $self->{options}->{$_} = $options{$_} if (defined($options{$_}));
      }
  }
  
  sub add_header {
      my ($self, %options) = @_;
  
      $self->{add_headers}->{$options{key}} = $options{value};
  }
  
  sub remove_header {
      my ($self, %options) = @_;
  
      delete $self->{add_headers}->{$options{key}} if (defined($self->{add_headers}->{$options{key}}));
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      $options{request}->{http_backend} = $self->{default_backend}
          if (!defined($options{request}->{http_backend}) || $options{request}->{http_backend} eq '');
      $self->{http_backend} = $options{request}->{http_backend};
      if ($self->{http_backend} !~ /^\s*lwp|curl\s*$/i) {
          $self->{output}->add_option_msg(short_msg => "Unsupported http backend specified '" . $self->{http_backend} . "'.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{request}->{$self->{http_backend} . '_backend_options'})) {
          foreach (keys %{$options{request}->{$self->{http_backend} . '_backend_options'}}) {
              $options{request}->{$_} = $options{request}->{$self->{http_backend} . '_backend_options'}->{$_};
          }
      }
  
      if (($options{request}->{proto} ne 'http') && ($options{request}->{proto} ne 'https')) {
          $self->{output}->add_option_msg(short_msg => "Unsupported protocol specified: '(" . $options{request}->{proto} . ")'. . Use either https or http.");
          $self->{output}->option_exit();
      }
      if (!defined($options{request}->{hostname})) {
          $self->{output}->add_option_msg(short_msg => "Please set the hostname option");
          $self->{output}->option_exit();
      }
      if ((defined($options{request}->{credentials})) && (!defined($options{request}->{username}) || !defined($options{request}->{password}))) {
          $self->{output}->add_option_msg(short_msg => "You need to set --username= and --password= options when --credentials is used");
          $self->{output}->option_exit();
      }
      if ((defined($options{request}->{cert_pkcs12})) && (!defined($options{request}->{cert_file}) && !defined($options{request}->{cert_pwd}))) {
          $self->{output}->add_option_msg(short_msg => "You need to set --cert-file= and --cert-pwd= options when --pkcs12 is used");
          $self->{output}->option_exit();
      }
  
      $options{request}->{port_force} = $self->get_port();
  
      $options{request}->{headers} = {};
      if (defined($options{request}->{header})) {
          foreach (@{$options{request}->{header}}) {
              if (/^(:.+?|.+?):\s*(.*)/) {
                  $options{request}->{headers}->{$1} = $2;
              }
          }
      }
      foreach (keys %{$self->{add_headers}}) {
          $options{request}->{headers}->{$_} = $self->{add_headers}->{$_};
      }
  
      foreach my $method (('get', 'post')) {
          if (defined($options{request}->{$method . '_param'})) {
              $options{request}->{$method . '_params'} = {};
              foreach (@{$options{request}->{$method . '_param'}}) {
                  if (/^([^=]+)={0,1}(.*)$/s) {
                      my $key = $1;
                      my $value = defined($2) ? $2 : 1;
                      if (defined($options{request}->{$method . '_params'}->{$key})) {
                          if (ref($options{request}->{$method . '_params'}->{$key}) ne 'ARRAY') {
                              $options{request}->{$method . '_params'}->{$key} = [ $options{request}->{$method . '_params'}->{$key} ];
                          }
                          push @{$options{request}->{$method . '_params'}->{$key}}, $value;
                      } else {
                          $options{request}->{$method . '_params'}->{$key} = $value;
                      }
                  }
              }
          }
      }
  
      $self->{'backend_' . $self->{http_backend}}->check_options(%options);
  }
  
  sub get_port {
      my ($self, %options) = @_;
  
      my $port = '';
      if (defined($self->{options}->{port}) && $self->{options}->{port} ne '') {
          $port = $self->{options}->{port};
      } else {
          $port = 80 if ($self->{options}->{proto} eq 'http');
          $port = 443 if ($self->{options}->{proto} eq 'https');
      }
  
      return $port;
  }
  
  sub get_port_request {
      my ($self, %options) = @_;
  
      my $port = '';
      if (defined($self->{options}->{port}) && $self->{options}->{port} ne '') {
          $port = $self->{options}->{port};
      }
      return $port;
  }
  
  sub request {
      my ($self, %options) = @_;
  
      my $request_options = { %{$self->{options}} };
      foreach (keys %options) {
          $request_options->{$_} = $options{$_} if (defined($options{$_}));
      }
      $self->check_options(request => $request_options);
  
      return $self->{'backend_' . $self->{http_backend}}->request(request => $request_options);
  }
  
  sub get_first_header {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_first_header(%options);
  }
  
  sub get_header {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_header(%options);
  }
  
  sub get_code {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_code();
  }
  
  sub get_message {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_message();
  }
  
  sub get_certificate {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_certificate();
  }
  
  sub get_times {
      my ($self, %options) = @_;
  
      return $self->{'backend_' . $self->{http_backend}}->get_times();
  }
  
  1;
  
  
  =head1 NAME
  
  HTTP abstraction layer.
  
  =head1 SYNOPSIS
  
  HTTP abstraction layer for lwp and curl backends
  
  =head1 HTTP GLOBAL OPTIONS
  
  =over 8
  
  =item B<--http-peer-addr>
  
  Set the address you want to connect to. Useful if hostname is only a vhost, to avoid IP resolution.
  
  =item B<--proxyurl>
  
  Proxy URL. Example: http://my.proxy:3128
  
  =item B<--proxypac>
  
  Proxy PAC file (can be a URL or a local file).
  
  =item B<--insecure>
  
  Accept insecure SSL connections.
  
  =item B<--http-backend>
  
  Perl library to use for HTTP transactions.
  Possible values are: lwp (default) and curl.
  
  =back
  
  =head1 DESCRIPTION
  
  B<http>.
  
  =cut
CENTREON_PLUGINS_HTTP

$fatpacked{"centreon/plugins/misc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MISC';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::misc;
  
  use strict;
  use warnings;
  use utf8;
  use JSON::XS;
  use Safe;
  use Encode;
  
  use Exporter 'import';
  use feature 'state';
  
  our @EXPORT_OK = qw/change_seconds
                      flatten_arrays
                      flatten_to_hash
                      graphql_escape
                      is_empty
                      json_encode
                      json_decode
                      slurp_file
                      value_of/;
  
  sub execute {
      my (%options) = @_;
      
      if ($^O eq 'MSWin32') {
          return windows_execute(%options, timeout => $options{options}->{timeout});
      } else {
          return unix_execute(%options);
      }
  }
  
  sub windows_execute {
      my (%options) = @_;
      my $result;
      my ($stdout, $pid, $ended) = ('');
      my ($exit_code, $cmd);
  
      $cmd = $options{command_path} . '/' if (defined($options{command_path}));
      $cmd .= $options{command} . ' ' if (defined($options{command}));
      $cmd .= $options{command_options} if (defined($options{command_options}));
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Win32::Job',
          error_msg => "Cannot load module 'Win32::Job'."
      );
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Time::HiRes',
          error_msg => "Cannot load module 'Time::HiRes'."
      );
  
      $| = 1;
      pipe FROM_CHILD, TO_PARENT or do {
          $options{output}->add_option_msg(short_msg => "Internal error: can't create pipe from child to parent: $!");
          $options{output}->option_exit();
      };
      my $job = Win32::Job->new;
      my $stderr = 'NUL';
      $stderr = \*TO_PARENT if ($options{output}->is_debug());
      if (!($pid = $job->spawn(undef, $cmd,
                         { stdin => 'NUL',
                           stdout => \*TO_PARENT,
                           stderr => $stderr }))) {
          $options{output}->add_option_msg(short_msg => "Internal error: execution issue: $^E");
          $options{output}->option_exit();
      }
      close TO_PARENT;
  
      my $ein = '';
      vec($ein, fileno(FROM_CHILD), 1) = 1;
      $job->watch(
          sub {            
              my ($buffer);
              my $time = $options{timeout};
              my $last_time = Time::HiRes::time();
              $ended = 0;
              while (select($ein, undef, undef, $options{timeout})) {
                  if (sysread(FROM_CHILD, $buffer, 16384)) {
                      $buffer =~ s/\r//g;
                      $stdout .= $buffer;
                  } else {
                      $ended = 1;
                      last;
                  }
                  $options{timeout} -= Time::HiRes::time() - $last_time;
                  last if ($options{timeout} <= 0);         
                  $last_time = Time::HiRes::time();
              }
              return 1 if ($ended == 0);
              return 0;
          },
          0.1
      );
  
      $result = $job->status;
      close FROM_CHILD;    
  
      if ($ended == 0) {
          $options{output}->add_option_msg(short_msg => 'Command too long to execute (timeout)...');
          $options{output}->option_exit();
      }
      chomp $stdout;
      
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $result->{$pid}->{exitcode});
      }
  
      if ($result->{$pid}->{exitcode} != 0) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
  
      return ($stdout, $result->{$pid}->{exitcode});
  }
  
  sub unix_execute {
      my (%options) = @_;
      my $cmd = '';
      my $args = [];
      my ($lerror, $stdout, $exit_code);
  
      my $redirect_stderr = 1;
      $redirect_stderr = $options{redirect_stderr} if (defined($options{redirect_stderr}));
      my $wait_exit = 1;
      $wait_exit = $options{wait_exit} if (defined($options{wait_exit}));
  
      # Build command line
      # Can choose which command is done remotely (can filter and use local file)
      if (defined($options{options}->{remote}) && 
          ($options{options}->{remote} eq '' || !defined($options{label}) || $options{label} =~ /$options{options}->{remote}/)) {
          my $sub_cmd;
  
          $cmd = $options{options}->{ssh_path} . '/' if (defined($options{options}->{ssh_path}));
          $cmd .= $options{options}->{ssh_command} if (defined($options{options}->{ssh_command}));
  
          foreach (@{$options{options}->{ssh_option}}) {
              if (/^(.*?)(?:=(.*))?$/) {
                  push @$args, $1 if (defined($1));
                  push @$args, $2 if (defined($2));
              }
          }
  
          if (defined($options{options}->{ssh_address}) && $options{options}->{ssh_address} ne '') {
              push @$args, $options{options}->{ssh_address};
          } else {
              push @$args, $options{options}->{hostname};
          }
  
          if (defined($options{options}->{ssh_option_eol})) {
              foreach (@{$options{options}->{ssh_option_eol}}) {
                  if (/^(.*?)(?:=(.*))?$/) {
                      push @$args, $1 if (defined($1));
                      push @$args, $2 if (defined($2));
                  }
              }
          }
  
          $sub_cmd = 'sudo ' if (defined($options{sudo}));
          $sub_cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $sub_cmd .= $options{command} . ' ' if (defined($options{command}));
          $sub_cmd .= $options{command_options} if (defined($options{command_options}));
          # On some equipment. Cannot get a pseudo terminal
          if (defined($options{ssh_pipe}) && $options{ssh_pipe} == 1) {
              $cmd = "echo '" . $sub_cmd . "' | " . $cmd . ' ' . join(' ', @$args);
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          } else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command => $cmd,
                  arguments => [@$args, $sub_cmd],
                  timeout => $options{options}->{timeout},
                  wait_exit => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      } else {
          $cmd = 'sudo ' if (defined($options{sudo}));
          $cmd .= $options{command_path} . '/' if (defined($options{command_path}));
          $cmd .= $options{command} if (defined($options{command}));
          $cmd .= ' ' . $options{command_options} if (defined($options{command_options}));
  
          if (defined($options{no_shell_interpretation}) and $options{no_shell_interpretation} ne '') {
              my @args = split(' ',$cmd);
              ($lerror, $stdout, $exit_code) = backtick(
                  command         => $args[0],
                  arguments       => [@args[1.. $#args]],
                  timeout         => $options{options}->{timeout},
                  wait_exit       => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
          else {
              ($lerror, $stdout, $exit_code) = backtick(
                  command         => $cmd,
                  timeout         => $options{options}->{timeout},
                  wait_exit       => $wait_exit,
                  redirect_stderr => $redirect_stderr
              );
          }
      }
  
      if (defined($options{options}->{show_output}) && 
          ($options{options}->{show_output} eq '' || (defined($options{label}) && $options{label} eq $options{options}->{show_output}))) {
          print $stdout;
          exit $exit_code;
      }
  
      $stdout =~ s/\r//g;
      if ($lerror <= -1000) {
          $options{output}->add_option_msg(short_msg => $stdout);
          $options{output}->option_exit();
      }
  
      if (defined($options{no_quit}) && $options{no_quit} == 1) {
          return ($stdout, $exit_code);
      }
  
      if ($exit_code != 0 && (!defined($options{no_errors}) || !defined($options{no_errors}->{$exit_code}))) {
          $stdout =~ s/\n/ - /g;
          $options{output}->add_option_msg(short_msg => "Command error: $stdout");
          $options{output}->option_exit();
      }
  
      return $stdout;
  }
  
  sub mymodule_load {
      my (%options) = @_;
      my $file;
      ($file = ($options{module} =~ /\.pm$/ ? $options{module} : $options{module} . '.pm')) =~ s{::}{/}g;
  
      eval {
          local $SIG{__DIE__} = 'IGNORE';
          require $file;
          $file =~ s{/}{::}g;
          $file =~ s/\.pm$//;
      };
      if ($@) {
          return 1 if (defined($options{no_quit}) && $options{no_quit} == 1);
          $options{output}->add_option_msg(long_msg => $@);
          $options{output}->add_option_msg(short_msg => $options{error_msg});
          $options{output}->option_exit();
      }
      return wantarray ? (0, $file) : 0;
  }
  
  sub backtick {
      my %arg = (
          command => undef,
          arguments => [],
          timeout => 30,
          wait_exit => 0,
          redirect_stderr => 0,
          @_,
      );
      my @output;
      my $pid;
      my $return_code;
  
      my $sig_do;
      if ($arg{wait_exit} == 0) {
          $sig_do = 'IGNORE';
          $return_code = undef;
      } else {
          $sig_do = 'DEFAULT';
      }
      local $SIG{CHLD} = $sig_do;
      $SIG{TTOU} = 'IGNORE';
      $| = 1;
  
      if (!defined($pid = open( KID, "-|" ))) {
          return (-1001, "Cant fork: $!", -1);
      }
  
      if ($pid) {
          
          eval {
             local $SIG{ALRM} = sub { die "Timeout by signal ALARM\n"; };
             alarm( $arg{timeout} );
             while (<KID>) {
                 chomp;
                 push @output, $_;
             }
  
             alarm(0);
          };
  
          if ($@) {
              if ($pid != -1) {
                  kill -9, $pid;
              }
  
              alarm(0);
              return (-1000, 'Command too long to execute (timeout)...', -1);
          } else {
              if ($arg{wait_exit} == 1) {
                  # We're waiting the exit code                
                  waitpid($pid, 0);
                  $return_code = ($? >> 8);
              }
              close KID;
          }
      } else {
          # child
          # set the child process to be a group leader, so that
          # kill -9 will kill it and all its descendents
          # We have ignore SIGTTOU to let write background processes
          setpgrp( 0, 0 );
  
          if ($arg{redirect_stderr} == 1) {
              open STDERR, '>&STDOUT';
          }
          if (scalar(@{$arg{arguments}}) <= 0) {
              exec($arg{command});
          } else {
              exec($arg{command}, @{$arg{arguments}});
          }
          # Exec is in error. No such command maybe.
          exit(127);
      }
  
      return (0, join("\n", @output), $return_code);
  }
  
  sub is_empty {
      my $value = shift;
      if (!defined($value) or $value eq '') {
          return 1;
      }
      return 0;
  }
  
  # Return the value of a complex perl variable (hash, array...) or a default value if it not defined.
  # The returned value will never be undef.
  # I.g:  value_of($hash, '->{key}->{subkey}', 'default')
  #       value_of($array, '->[0]', 'default')
  #       value_of($complex, '->{key}->[0]->{subkey}', 'default')
  sub value_of($$;$) {
      my ($variable, $expression, $default) = @_;
      $default //= '';
  
      return $default unless defined $variable;
  
      state $safe = do { my $s = Safe->new();
                         $s->share('$v');
                         $s;
                       };
      our $v = $variable;
      my $value = $safe->reval("\$v$expression", 1);
  
      return defined $value ? $value : $default;
  }
  
  sub trim {
      my ($value) = $_[0];
      
      # Sometimes there is a null character
      $value =~ s/\x00$//;
      $value =~ s/^[ \t\n]+//;
      $value =~ s/[ \t\n]+$//;
      return $value;
  }
  
  sub powershell_encoded {
      require Encode;
      require MIME::Base64;
      my $bytes = Encode::encode('utf16LE', $_[0]);
      return MIME::Base64::encode_base64($bytes, '');
  }
  
  sub powershell_escape {
      my ($value) = $_[0];
      $value =~ s/`/``/g;
      $value =~ s/#/`#/g;
      $value =~ s/'/`'/g;
      $value =~ s/"/`"/g;
      return $value;
  }
  
  sub graphql_escape($) {
      my ($value) = $_[0];
      $value =~ s/"/\\"/g;
      return $value;
  }
  
  # Returns an array from arrays containing values separated by $separator
  sub flatten_arrays($;$) {
      my ($array_of_values, $separator) = @_;
      $separator //= ',';
  
      return [ ] unless ref $array_of_values eq 'ARRAY';
  
      return [ map { split $separator } @{$array_of_values} ];
  }
  
  # Returns an hash from arrays containing values separated by $separator
  # Values are set to $default (1 if not defined)
  sub flatten_to_hash($;$;$) {
      my ($array_of_values, $separator, $default) = @_;
      $separator //= ',';
      $default //= 1;
  
      return { } unless ref $array_of_values eq 'ARRAY';
  
      return { map { $_ => $default } map { split $separator } @{$array_of_values} };
  }
  
  sub minimal_version {
      my ($version_src, $version_dst) = @_;
          
      # No Version. We skip   
      if (!defined($version_src) || !defined($version_dst) || 
          $version_src !~ /^[0-9]+(?:\.[0-9\.]+)*$/ || $version_dst !~ /^[0-9x]+(?:\.[0-9x]+)*$/) {
          return 1;
      }
    
      my @version_src = split /\./, $version_src;
      my @versions = split /\./, $version_dst;
      for (my $i = 0; $i < scalar(@versions); $i++) {
          return 1 if ($versions[$i] eq 'x');
          return 1 if (!defined($version_src[$i]));
          $version_src[$i] =~ /^([0-9]*)/;
          next if ($versions[$i] == int($1));
          return 0 if ($versions[$i] > int($1));
          return 1 if ($versions[$i] < int($1));
      }
      
      return 1;
  }
  
  sub change_seconds {
      my %options = @_;
      my ($str, $str_append) = ('', '');
      my $periods = [
          { unit => 'y', value => 31556926 },
          { unit => 'M', value => 2629743 },
          { unit => 'w', value => 604800 },
          { unit => 'd', value => 86400 },
          { unit => 'h', value => 3600 },
          { unit => 'm', value => 60 },
          { unit => 's', value => 1 },
      ];
      my %values = ('y' => 1, 'M' => 2, 'w' => 3, 'd' => 4, 'h' => 5, 'm' => 6, 's' => 7);
      my $sign = '';
      if ($options{value} < 0) {
          $sign = '-';
          $options{value} = abs($options{value});
      }
      
      foreach (@$periods) {
          next if (defined($options{start}) && $values{$_->{unit}} < $values{$options{start}});
          my $count = int($options{value} / $_->{value});
  
          next if ($count == 0);
          $str .= $str_append . $count . $_->{unit};
          $options{value} = $options{value} % $_->{value};
          $str_append = ' ';
      }
  
      if ($str eq '') {
          $str = $options{value};
          $str .= $options{start} if (defined($options{start}));
      }
      return $sign . $str;
  }
  
  sub scale_bytesbit {
      my (%options) = @_;
      
      my $base = 1024;
      if (defined($options{dst_unit}) && defined($options{src_unit})) {
          $options{value} *= 8 if ($options{dst_unit} =~ /b/ && $options{src_unit} =~ /B/);
          $options{value} /= 8 if ($options{dst_unit} =~ /B/ && $options{src_unit} =~ /b/);
          if ($options{dst_unit} =~ /b/) {
              $base = 1000;
          }
      }
          
      my %expo = ('' => 0, k => 1, m => 2, g => 3, t => 4, p => 5, e => 6);
      my ($src_expo, $dst_expo) = (0, 0);
      $src_expo = $expo{lc($options{src_quantity})} if (defined($options{src_quantity}) && $options{src_quantity} =~ /[kmgtpe]/i);
      if ($options{dst_unit} eq 'auto') {
          my @auto = ('', 'k', 'm', 'g', 't', 'p', 'e');
          my $i = defined($options{src_quantity}) ? $expo{$options{src_quantity}} : 0;
          for (; $i < scalar(@auto); $i++) {
              last if ($options{value} < $base);
              $options{value} = $options{value} / $base;
          }
  
          return ($options{value}, $auto[$i], $options{src_unit});
      } elsif (defined($options{dst_quantity}) && ($options{dst_quantity} eq '' || $options{dst_quantity} =~ /[kmgtpe]/i )) {
          my $dst_expo = $expo{lc($options{dst_quantity})};
          if ($dst_expo - $src_expo > 0) {
              $options{value} = $options{value} / ($base ** ($dst_expo - $src_expo));
          } elsif ($dst_expo - $src_expo < 0) {
              $options{value} = $options{value} * ($base ** (($dst_expo - $src_expo) * -1));
          }
      }
      
      return $options{value};
  }
  
  sub convert_bytes {
      my (%options) = @_;
  
      my %expo = (k => 1, m => 2, g => 3, t => 4, p => 5);
      my ($value, $unit) = ($options{value}, $options{unit});
      if (defined($options{pattern})) {
          return undef if ($value !~ /$options{pattern}/);
          $value = $1;
          $unit = $2;
      }
      
      my $base = defined($options{network}) ? 1000 : 1024;    
      if ($unit =~ /([kmgtp])i?b/i) {
          $value = $value * ($base ** $expo{lc($1)});
      }
  
      return $value;
  }
  
  sub convert_fahrenheit {
      my (%options) = @_;
  
      return ($options{value} - 32) / 1.8;
  }
  
  sub expand_exponential {
      my (%options) = @_;
  
      return $options{value} unless ($options{value} =~ /^(.*)e([-+]?)(.*)$/);
      my ($num, $sign, $exp) = ($1, $2, $3);
      my $sig = $sign eq '-' ? "." . ($exp - 1 + length $num) : '';
      return sprintf("%${sig}f", $options{value});
  }
  
  sub alert_triggered {
      my (%options) = @_;
  
      my ($rv_warn, $warning) = parse_threshold(threshold => $options{warning});
      my ($rv_crit, $critical) = parse_threshold(threshold => $options{critical});
  
      foreach ([$rv_warn, $warning], [$rv_crit, $critical]) {
          next if ($_->[0] == 0);
  
          if ($_->[1]->{arobase} == 0 && ($options{value} < $_->[1]->{start} || $options{value} > $_->[1]->{end})) {
              return 1;
          } elsif ($_->[1]->{arobase}  == 1 && ($options{value} >= $_->[1]->{start} && $options{value} <= $_->[1]->{end})) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub parse_threshold {
      my (%options) = @_;
  
      my $perf = trim($options{threshold});
      my $perf_result = { arobase => 0, infinite_neg => 0, infinite_pos => 0, start => '', end => '' };
  
      my $global_status = 1;    
      if ($perf =~ /^(\@?)((?:~|(?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?|):)?((?:\+|-)?\d+(?:[\.,]\d+)?(?:[KMGTPE][bB])?)?$/) {
          $perf_result->{start} = $2 if (defined($2));
          $perf_result->{end} = $3 if (defined($3));
          $perf_result->{arobase} = 1 if (defined($1) && $1 eq '@');
          $perf_result->{start} =~ s/[\+:]//g;
          $perf_result->{end} =~ s/\+//;
          if ($perf_result->{start} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{start} = scale_bytesbit(
                  value => $perf_result->{start},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} =~ s/([KMGTPE])([bB])//) {
              $perf_result->{end} = scale_bytesbit(
                  value => $perf_result->{end},
                  src_unit => $2, dst_unit => $2,
                  src_quantity => $1, dst_quantity => '',
              );
          }
          if ($perf_result->{end} eq '') {
              $perf_result->{end} = 1e500;
              $perf_result->{infinite_pos} = 1;
          }
          $perf_result->{start} = 0 if ($perf_result->{start} eq '');      
          $perf_result->{start} =~ s/,/\./;
          $perf_result->{end} =~ s/,/\./;
          
          if ($perf_result->{start} eq '~') {
              $perf_result->{start} = -1e500;
              $perf_result->{infinite_neg} = 1;
          }
      } else {
          $global_status = 0;
      }
  
      return ($global_status, $perf_result);
  }
  
  sub get_threshold_litteral {
      my (%options) = @_;
  
      my $perf_output = ($options{arobase} == 1 ? '@' : '') . 
          (($options{infinite_neg} == 0) ? $options{start} : '~') . 
          ':' . 
          (($options{infinite_pos} == 0) ? $options{end} : '');
      return $perf_output;
  }
  
  sub set_timezone {
      my (%options) = @_;
  
      return {} if (!defined($options{name}) || $options{name} eq '');
  
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'DateTime::TimeZone',
          error_msg => "Cannot load module 'DateTime::TimeZone'."
      );
      if (DateTime::TimeZone->is_valid_name($options{name})) {
          return { time_zone => DateTime::TimeZone->new(name => $options{name}) };
      }
  
      # try to manage syntax (:Pacific/Noumea for example)
      if ($options{name} =~ /^:(.*)$/ && DateTime::TimeZone->is_valid_name($1)) {
          return { time_zone => DateTime::TimeZone->new(name => $1) };
      }
  
      return {};
  }
  
  sub uniq {
      my %seen;
  
      return grep { !$seen{$_}++ } @_;
  }
  
  sub eval_ssl_options {
      my (%options) = @_;
  
      my $ssl_context = {};
      return $ssl_context if (!defined($options{ssl_opt}));
      
      my ($rv) = centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'Safe',
          no_quit => 1
      );
      centreon::plugins::misc::mymodule_load(
          output => $options{output}, module => 'IO::Socket::SSL',
          no_quit => 1
      );
  
      my $safe;
      if ($rv == 0) {
          $safe = Safe->new();
          $safe->permit_only(':base_core', 'rv2gv', 'padany');
          $safe->share('$values');
          $safe->share('$assign_var');
          $safe->share_from('IO::Socket::SSL', [
              'SSL_VERIFY_NONE', 'SSL_VERIFY_PEER', 'SSL_VERIFY_FAIL_IF_NO_PEER_CERT', 'SSL_VERIFY_CLIENT_ONCE',
              'SSL_RECEIVED_SHUTDOWN', 'SSL_SENT_SHUTDOWN',
              'SSL_OCSP_NO_STAPLE', 'SSL_OCSP_MUST_STAPLE', 'SSL_OCSP_FAIL_HARD', 'SSL_OCSP_FULL_CHAIN', 'SSL_OCSP_TRY_STAPLE'
          ]);
      }
      
      foreach (@{$options{ssl_opt}}) {
          if (/(SSL_[A-Za-z_]+)\s+=>\s*(\S+)/) {
              my ($label, $eval) = ($1, $2);
  
              our $assign_var;
              if (defined($safe)) {
                  $safe->reval("\$assign_var = $eval", 1);
                  if ($@) {
                      die 'Unsafe code evaluation: ' . $@;
                  }
              } else {
                  eval "\$assign_var = $eval";
              }
  
              $ssl_context->{$label} = $assign_var;
          }
      }
  
      return $ssl_context;
  }
  
  sub slurp_file {
      my (%options) = @_;
  
      my $content = do {
          local $/ = undef;
          if (!open my $fh, '<', $options{file}) {
              $options{output}->add_option_msg(short_msg => "Could not open file $options{file}: $!");
              $options{output}->option_exit();
          }
          <$fh>;
      };
  
      return $content;
  }
  
  sub sanitize_command_param {
      my (%options) = @_;
  
      return if (!defined($options{value}));
  
      $options{value} =~ s/[`;!&|]//g;
      return $options{value};
  }
  
  my $security_file = '/etc/centreon-plugins/security.json';
  my $whitelist_file = '/etc/centreon-plugins/whitelist.json';
  if ($^O eq 'MSWin32') {
      $security_file = 'C:/Program Files/centreon-plugins/security.json';
      $whitelist_file = 'C:/Program Files/centreon-plugins/whitelist.json';
  }
  
  sub check_security_command {
      my (%options) = @_;
  
      return 0 if (!(
          (defined($options{command}) && $options{command} ne '') ||
          (defined($options{command_options}) && $options{command_options} ne '') ||
          (defined($options{command_path}) && $options{command_path} ne ''))
      );
  
      return 0 if (! -r "$security_file" || -z "$security_file");
  
      my $content = slurp_file(output => $options{output}, file => $security_file);
  
      my $security;
      eval {
          $security = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode security file content');
          $options{output}->option_exit();
      }
  
      if (defined($security->{block_command_overload}) && $security->{block_command_overload} == 1) {
          $options{output}->add_option_msg(short_msg => 'Cannot overload command (security)');
          $options{output}->option_exit();
      }
  
      return 0;
  }
  
  sub check_security_whitelist {
      my (%options) = @_;
  
      my $command = $options{command};
      $command = $options{command_path} . '/' . $options{command} if (defined($options{command_path}) && $options{command_path} ne '');
      $command .= ' ' . $options{command_options} if (defined($options{command_options}) && $options{command_options} ne '');
  
      return 0 if (! -r "$security_file" || -z "$security_file");
  
      my $content = slurp_file(output => $options{output}, file => $security_file);
  
      my $security;
      eval {
          $security = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode security file content');
          $options{output}->option_exit();
      }
  
      return 0 if (!defined($security->{whitelist_enabled}) || $security->{whitelist_enabled} !~ /^(?:1|true)$/i);
  
      if (! -r "$whitelist_file") {
          $options{output}->add_option_msg(short_msg => 'Cannot read whitelist security file content');
          $options{output}->option_exit();
      }
  
      if (-z "$whitelist_file") {
          $options{output}->add_option_msg(short_msg => 'Cannot execute command (security)');
          $options{output}->option_exit();
      }
  
      $content = slurp_file(output => $options{output}, file => $whitelist_file);
  
      my $whitelist;
      eval {
          $whitelist = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $options{output}->add_option_msg(short_msg => 'Cannot decode whitelist security file content');
          $options{output}->option_exit();
      }
  
      my $matched = 0;
      foreach (@$whitelist) {
          if ($command =~ /$_/) {
              $matched = 1;
              last;
          }
      }
  
      if ($matched == 0) {
          $options{output}->add_option_msg(short_msg => 'Cannot execute command (security)');
          $options{output}->option_exit();
      }
  
      return 0;
  }
  
  sub json_decode {
      my ($content, %options) = @_;
  
      $content =~ s/\r//mg;
  
      $content = decode('UTF-8', $content, Encode::FB_DEFAULT);
  
      my $decoder = JSON::XS->new;
  
      # this option
      if ($options{booleans_as_strings}) {
          # boolean_values() is not available on old versions of JSON::XS (Alma 8 still provides v3.04)
          if (JSON::XS->can('boolean_values')) {
              $decoder = $decoder->boolean_values("false", "true");
          } else {
              # if boolean_values is not available, perform a dirty substitution of booleans
              $content =~ s/"(\w+)"\s*:\s*(true|false)(\s*,?)/"$1": "$2"$3/gm;
          }
      }
  
      my $object = eval { $decoder->decode($content) };
  
      if ($@) {
          # To keep compatibilty with old json_decode:
          # If 'output' not set, print error on STDERR unless 'silence' is set
          # Otherwise print error on 'output' and exit unless 'no_exit' is set
          my $msg = $options{errstr} // "Cannot decode JSON string: $@";
  
          if ($options{output}) {
              $options{output}->option_exit(short_msg => $msg)
                  unless $options{no_exit};
  
              $options{output}->output_add(long_msg => $msg, debug => 1);
          } else {
              warn "$msg\n" unless $options{silence};
          }
  
          return undef;
      }
  
      return $object;
  }
  
  sub json_encode {
      my ($object) = @_;
  
      $object =~ s/\r//mg;
      my $encoded;
      eval {
          $encoded = encode_json($object);
      };
      if ($@) {
          print STDERR 'Cannot encode object to JSON. Error message: ' . $@;
          return undef;
      }
  
      return $encoded;
  }
  
  sub is_local_ip($) {
      my ($ip) = @_;
  
      return 0 unless $ip;
  
      return 1 if $ip =~ /^127\./;
      return 1 if $ip =~ /^10\./;
      return 1 if $ip =~ /^192\.168\./;
      return 1 if $ip =~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./;
      return 1 if $ip =~ /^169\.254\./;
      return 1 if $ip eq '0.0.0.0';
  
      return 0;
  }
  
  # This function is used with "sort", it sorts an array of IP addresses.
  # $_[0] and $_[1] correspond to Perl's special variables $a and $b used by sort.
  # I can't use $a and $b directly here, otherwise Perl generates a warning: "uninitialized value".
  sub sort_ips($$) {
      my @a = split /\./, $_[0];
      my @b = split /\./, $_[1];
      return $a[0] <=> $b[0] || $a[1] <=> $b[1] || $a[2] <=> $b[2] || $a[3] <=> $b[3]
  }
  
  # function to assess if a string has to be excluded given an include regexp and an exclude regexp
  sub is_excluded {
      my ($string, $include_regexp, $exclude_regexp) = @_;
      return 1 unless defined($string);
      return 1 if (defined($exclude_regexp) && $exclude_regexp ne '' && $string =~ /$exclude_regexp/);
      return 0 if (!defined($include_regexp) || $include_regexp eq '' || $string =~ /$include_regexp/);
  
      return 1;
  }
  
  1;
  
  
  =head1 NAME
  
  centreon::plugins::misc - A collection of miscellaneous utility functions for Centreon plugins.
  
  =head1 SYNOPSIS
  
      use centreon::plugins::misc;
  
      my $result = centreon::plugins::misc::execute(
          command => 'ls',
          command_options => '-l'
      );
  
  =head1 DESCRIPTION
  
  The `centreon::plugins::misc` module provides a variety of utility functions that can be used in Centreon plugins. These functions include command execution, string manipulation, file handling, and more.
  
  =head1 METHODS
  
  =head2 execute
  
      my $result = centreon::plugins::misc::execute(%options);
  
  Executes a command and returns the result.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 windows_execute
  
      my ($stdout, $exit_code) = centreon::plugins::misc::windows_execute(%options);
  
  Executes a command on Windows and returns the output and exit code.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 unix_execute
  
      my $stdout = centreon::plugins::misc::unix_execute(%options);
  
  Executes a command on Unix and returns the output.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<command_options> - Options for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =item * C<wait_exit> - bool.
  
  =item * C<redirect_stderr> - bool.
  
  =item * C<sudo> - bool prepend sudo to the command executed.
  
  =item * C<no_shell_interpretation> - bool don't use sh interpolation on command executed
  
  
  =back
  
  =back
  
  =head2 mymodule_load
  
      my $result = centreon::plugins::misc::mymodule_load(%options);
  
  Loads a Perl module dynamically.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<module> - The module to load.
  
  =item * C<error_msg> - Error message to display if the module cannot be loaded.
  
  =back
  
  =back
  
  =head2 backtick
  
      my ($status, $output, $exit_code) = centreon::plugins::misc::backtick(%options);
  
  Executes a command using backticks and returns the status, output, and exit code.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to execute.
  
  =item * C<arguments> - Arguments for the command.
  
  =item * C<timeout> - Timeout for the command execution.
  
  =back
  
  =back
  
  =head2 is_empty
  
      my $is_empty = centreon::plugins::misc::is_empty($value);
  
  Checks if a value is empty.
  
  =over 4
  
  =item * C<$value> - The value to check.
  
  =back
  
  =head2 value_of
  
      my $value = centreon::plugins::misc::value_of($variable, $expression, $default);
  
  Return the value of a complex perl variable (hash, array...) or a default value if it not defined.
  
  =over 4
  
  =item * C<$value> - The return value.
  
  =item * C<$expression> - The expression to test.
  
  =item * C<$default> - The default value to return if expression is not defined (optional).
  
  =back
  
  =head2 trim
  
      my $trimmed_value = centreon::plugins::misc::trim($value);
  
  Trims whitespace from a string.
  
  =over 4
  
  =item * C<$value> - The string to trim.
  
  =back
  
  =head2 powershell_encoded
  
      my $encoded = centreon::plugins::misc::powershell_encoded($value);
  
  Encodes a string for use in PowerShell.
  
  =over 4
  
  =item * C<$value> - The string to encode.
  
  =back
  
  =head2 powershell_escape
  
      my $escaped = centreon::plugins::misc::powershell_escape($value);
  
  Escapes special characters in a string for use in PowerShell.
  
  =over 4
  
  =item * C<$value> - The string to escape.
  
  =back
  
  =head2 graphql_escape
  
      my $escaped = centreon::plugins::misc::graphql_escape($value);
  
  Escapes special characters in a string for use in GraphQL query.
  
  =over 4
  
  =item * C<$value> - The string to escape.
  
  =back
  
  =head2 flatten_arrays
  
      my $array = centreon::plugins::misc::flatten_arrays($arrays, $separator);
  
  Returns an array from arrays containing values separated by a separator ( default comma ).
  
  =over 4
  
  =item * C<$arrays> - Arrays to expand.
  
  =item * C<$separator> - Separator ( comma if undef ).
  
  =back
  
  =head2 flatten_to_hash
  
      my $hash = centreon::plugins::misc::flatten_to_hash($arrays, $separator, $default);
  
  Returns a hash from arrays containing values separated by a separator ( default comma ). Values are set to optional parameter $default ( 1 if undef ).
  
  =over 4
  
  =item * C<$arrays> - Arrays to expand.
  
  =item * C<$separator> - Separator ( comma if undef ).
  
  =item * C<$default> - Default value ( 1 if undef ).
  
  =back
  
  =head2 minimal_version
  
      my $is_minimal = centreon::plugins::misc::minimal_version($version_src, $version_dst);
  
  Checks if a version is at least a specified version.
  
  =over 4
  
  =item * C<$version_src> - The source version.
  
  =item * C<$version_dst> - The destination version.
  
  =back
  
  =head2 change_seconds
  
      my $formatted_time = centreon::plugins::misc::change_seconds(%options);
  
  Converts seconds into a human-readable format.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The number of seconds.
  
  =item * C<start> - The starting unit.
  
  =back
  
  =back
  
  =head2 scale_bytesbit
  
      my $scaled_value = centreon::plugins::misc::scale_bytesbit(%options);
  
  Scales a value between bytes and bits.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to scale.
  
  =item * C<src_unit> - The source unit.
  
  =item * C<dst_unit> - The destination unit.
  
  =back
  
  =back
  
  =head2 convert_bytes
  
      my $bytes = centreon::plugins::misc::convert_bytes(%options);
  
  Converts a value to bytes.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to convert.
  
  =item * C<unit> - The unit of the value.
  
  =back
  
  =back
  
  =head2 convert_fahrenheit
  
      my $celsius = centreon::plugins::misc::convert_fahrenheit(%options);
  
  Converts a temperature from Fahrenheit to Celsius.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The temperature in Fahrenheit.
  
  =back
  
  =back
  
  =head2 expand_exponential
  
      my $expanded = centreon::plugins::misc::expand_exponential(%options);
  
  Expands an exponential value to its full form.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The exponential value.
  
  =back
  
  =back
  
  =head2 alert_triggered
  
      my $is_triggered = centreon::plugins::misc::alert_triggered(%options);
  
  Checks if an alert is triggered based on thresholds.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to check.
  
  =item * C<warning> - The warning threshold.
  
  =item * C<critical> - The critical threshold.
  
  =back
  
  =back
  
  =head2 parse_threshold
  
      my ($status, $threshold) = centreon::plugins::misc::parse_threshold(%options);
  
  Parses a threshold string.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<threshold> - The threshold string.
  
  =back
  
  =back
  
  =head2 get_threshold_litteral
  
      my $threshold_str = centreon::plugins::misc::get_threshold_litteral(%options);
  
  Returns the literal representation of a threshold.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<arobase> - Indicates if the threshold is inclusive.
  
  =item * C<start> - The start of the threshold.
  
  =item * C<end> - The end of the threshold.
  
  =back
  
  =back
  
  =head2 set_timezone
  
      my $timezone = centreon::plugins::misc::set_timezone(%options);
  
  Sets the timezone.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<name> - The name of the timezone.
  
  =back
  
  =back
  
  =head2 uniq
  
      my @unique = centreon::plugins::misc::uniq(@values);
  
  Returns a list of unique values.
  
  =over 4
  
  =item * C<@values> - The list of values.
  
  =back
  
  =head2 eval_ssl_options
  
      my $ssl_context = centreon::plugins::misc::eval_ssl_options(%options);
  
  Evaluates SSL options.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<ssl_opt> - The SSL options.
  
  =back
  
  =back
  
  =head2 slurp_file
  
      my $content = centreon::plugins::misc::slurp_file(%options);
  
  Reads the content of a file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<file> - The file to read.
  
  =back
  
  =back
  
  =head2 sanitize_command_param
  
      my $sanitized = centreon::plugins::misc::sanitize_command_param(%options);
  
  Sanitizes a command parameter.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<value> - The value to sanitize.
  
  =back
  
  =back
  
  =head2 check_security_command
  
      my $status = centreon::plugins::misc::check_security_command(%options);
  
  Checks the security of a command.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to check.
  
  =item * C<command_options> - Options for the command.
  
  =back
  
  =back
  
  =head2 check_security_whitelist
  
      my $status = centreon::plugins::misc::check_security_whitelist(%options);
  
  Checks if a command is in the security whitelist.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<command> - The command to check.
  
  =item * C<command_options> - Options for the command.
  
  =back
  
  =back
  
  =head2 json_decode
  
      my $decoded = centreon::plugins::misc::json_decode($content, %options);
  
  Decodes a JSON string.
  
  =over 4
  
  =item * C<$content> - The JSON string to decode and transform into an object.
  
  =item * C<%options> - Options passed to the function.
  
  =over 4
  
  =item * C<booleans_as_strings> - Defines whether booleans must be converted to C<true>/C<false> strings instead of
  JSON:::PP::Boolean values. C<1> => strings, C<0> => booleans.
  
  =item * C<errstr> - Custom error message to display if JSON string cannot be decoded.
  
  =item * C<output> - Output object to use for displaying errors.
  
  =item * C<no_exit> - Do not exit if there is an error and C<output> is defined.
  
  =item * C<silence> - Do not print error on STDERR if C<output> is not defined.
  
  =back
  
  =back
  
  =head2 json_encode
  
      my $encoded = centreon::plugins::misc::json_encode($object);
  
  Encodes an object to a JSON string.
  
  =over 4
  
  =item * C<$object> - The object to encode.
  
  =back
  
  =head2 is_local_ip
  
      my $is_local = centreon::plugins::misc::is_local_ip($ip);
  
  Returns 1 if an IPv4 IP is within a local address range.
  
  =over 4
  
  =item * C<$ip> - IP to test.
  
  =back
  
  =head2 sort_ips
  
      my @array = ( '192.168.0.3', '127.0.0.1' );
      @array = sort centreon::plugins::misc::sort_ips @array;
  
  Returns a sorted array.
  
  =over 4
  
  =item * C<@array> - An array containing IPs to be sorted.
  
  =back
  
  =head2 is_excluded
  
      my $excluded = is_excluded($string, $include_regexp, $exclude_regexp);
  
  Determines whether a string should be excluded based on include and exclude regular expressions.
  
  =over 4
  
  =item * C<$string> - The string to evaluate. If undefined, the function returns 1 (excluded).
  
  =item * C<$include_regexp> - A regular expression to include the string.
  
  =item * C<$exclude_regexp> - A regular expression to exclude the string. If defined and matches the string, the function returns 1 (excluded).
  
  =back
  
  Returns 1 if the string is excluded, 0 if it is included.
  The string is excluded if $exclude_regexp is defined and matches the string, or if $include_regexp is defined and does
  not match the string. The string will also be excluded if it is undefined.
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
CENTREON_PLUGINS_MISC

$fatpacked{"centreon/plugins/mode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MODE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::mode;
  
  use strict;
  use warnings;
  use centreon::plugins::perfdata;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      $self->{perfdata} = centreon::plugins::perfdata->new(output => $options{output});
      
      %{$self->{option_results}} = ();
      @{$self->{option_extras}} = @{$options{options}->{extra_arguments}};
      $self->{output} = $options{output};
      $self->{output}->use_new_perfdata(value => 1)
          if (defined($options{force_new_perfdata}) && $options{force_new_perfdata} == 1);
      $self->{mode} = $options{mode};
      $self->{version} = '1.0';
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      # options{default} = { mode_xxx => { option_name => option_value }, }
      %{$self->{option_results}} = %{$options{option_results}};
      # Manage default value
      return if (!defined($options{default}));
      foreach (keys %{$options{default}}) {
          if ($_ eq $self->{mode}) {
              foreach my $value (keys %{$options{default}->{$_}}) {
                  if (!defined($self->{option_results}->{$value})) {
                      $self->{option_results}->{$value} = $options{default}->{$_}->{$value};
                  }
              }
          }
      }
  }
  
  sub version {
      my ($self, %options) = @_;
      
      $self->{output}->add_option_msg(short_msg => "Mode Version: " . $self->{version});
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
  }
  
  1;
  
  
CENTREON_PLUGINS_MODE

$fatpacked{"centreon/plugins/multi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_MULTI';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::multi;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'modes-exec:s'   => { name => 'modes_exec' },
          'option-mode:s@' => { name => 'option_mode' }
      });
      $self->{options} = $options{options};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (!defined($self->{option_results}->{modes_exec})) {
          $self->{output}->add_option_msg(short_msg => "Need to specify --modes-exec option.");
          $self->{output}->option_exit(); 
      }
      $self->{options_mode_extra} = {};
      if (defined($self->{option_results}->{option_mode})) {
          foreach (@{$self->{option_results}->{option_mode}}) {
              next if (! /^(.+?),(.*)$/);
              $self->{options_mode_extra}->{$1} = [] if (!defined($self->{options_mode_extra}->{$1}));
              push @{$self->{options_mode_extra}->{$1}}, $2;
          }
      }
  
      $self->{modes} = $options{modes};
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{output}->parameter(attr => 'nodisplay', value => 1);
      $self->{output}->parameter(attr => 'noexit_die', value => 1);
      $self->{output}->use_new_perfdata(value => 1);
  
      my @modes = split /,/, $self->{option_results}->{modes_exec};
      foreach (@modes) {
          next if (!defined($self->{modes}->{$_}));
          eval {
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output},
                  module => $self->{modes}->{$_}, 
                  error_msg => "Cannot load module --mode $_"
              );
              @ARGV = (@{$self->{options_mode_extra}->{$_}}) if (defined($self->{options_mode_extra}->{$_}));
              $self->{output}->mode(name => $_);
  
              my $mode = $self->{modes}->{$_}->new(options => $self->{options}, output => $self->{output}, mode => $_);
              $self->{options}->parse_options();
              my $option_results = $self->{options}->get_options();
              $mode->check_options(option_results => $option_results, %options);
              $mode->run(%options);
          };
          if ($@) {
              $self->{output}->output_add(long_msg => 'eval result mode ' . $_ . ': ' . $@, debug => 1);
          }
      }
  
      $self->{output}->mode(name => 'multi');
      $self->{output}->parameter(attr => 'nodisplay', value => 0);
      $self->{output}->parameter(attr => 'noexit_die', value => 0);
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check multiple modes at once.
  
  =over 8
  
  =item B<--modes-exec>
  
  Modes to use, separated by commas.
  Example for linux: --modes-exec=cpu,memory,storage,interfaces
  
  =item B<--option-mode>
  
  Define options for the modes selected in --modes-exec.
  The option can be used several times.
  E.g.: to define two options for the interfaces mode and one for the storage mode:
  --option-mode='interfaces,--statefile-dir=/tmp' --option-mode='interfaces,--add-traffic' --option-mode='storage,--statefile-dir=/tmp'
  
  =back
  
  =cut
CENTREON_PLUGINS_MULTI

$fatpacked{"centreon/plugins/options.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OPTIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::options;
  
  use Pod::Usage;
  use strict;
  use warnings;
  
  my $alternative = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{pod_where_loaded} = 0;
      $self->{sanity} = 0;
      $self->{options_stored} = {};
      $self->{options} = {};
      @{$self->{pod_package}} = ();
      $self->{pod_packages_once} = {};
      $self->{extra_arguments} = [];
  
      if ($alternative == 0) {
          require Getopt::Long;
          Getopt::Long->import();
          Getopt::Long::Configure("pass_through");
          Getopt::Long::Configure('bundling');
          Getopt::Long::Configure('no_auto_abbrev');
      } else {
          require centreon::plugins::alternative::Getopt;
          $centreon::plugins::alternative::Getopt::warn_message = 0;
          centreon::plugins::alternative::Getopt->import();
      }
  
      return $self;
  }
  
  sub set_sanity {
      my ($self, %options) = @_;
  
      if ($alternative == 0) {
          Getopt::Long::Configure('no_pass_through');
      } else {
          $centreon::plugins::alternative::Getopt::warn_message = 1;
      }
  
      $self->{sanity} = 1;
  }
  
  sub set_output {
      my ($self, %options) = @_;
  
      $self->{output} = $options{output};
  }
  
  sub display_help {
      my ($self, %options) = @_;
  
      my $stdout;
      foreach (@{$self->{pod_package}}) {
          my $where = $self->pod_where(package => $_->{package});
  
          {
              local *STDOUT;
              open STDOUT, '>', \$stdout;
              pod2usage(
                  -exitval => 'NOEXIT', -input => $where,
                  -verbose => 99, 
                  -sections => $_->{sections}
              ) if (defined($where));
          }
  
          $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
      }
  }
  
  sub add_help {
      my ($self, %options) = @_;
      # $options{package} = string package
      # $options{sections} = string sections
      # $options{help_first} = put at the beginning
      # $options{once} = put help only one time for a package
  
      if (defined($options{once}) && defined($self->{pod_packages_once}->{$options{package}})) {
          return ;
      }
  
      if (defined($options{help_first})) {
          unshift @{$self->{pod_package}}, {package => $options{package}, sections => $options{sections}};
      } else {
          push @{$self->{pod_package}}, { package => $options{package}, sections => $options{sections} };
      }
  
      $self->{pod_packages_once}->{$options{package}} = 1;
  }
  
  sub add_options {
      my ($self, %options) = @_;
      # $options{arguments} = ref to hash table with string and name to store (example: { 'mode:s' => { name => 'mode', default => 'defaultvalue' )
  
      foreach (keys %{$options{arguments}}) {
          if (defined($options{arguments}->{$_}->{redirect})) {
              $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{redirect}};
              next;
          }
  
          if (defined($options{arguments}->{$_}->{default})) {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = $options{arguments}->{$_}->{default};
          } else {
              $self->{options_stored}->{$options{arguments}->{$_}->{name}} = undef;
          }
          
          $self->{options}->{$_} = \$self->{options_stored}->{$options{arguments}->{$_}->{name}};
      }
  }
  
  sub parse_options {
      my $self = shift;
      #%{$self->{options_stored}} = ();
  
      my $save_warn_handler;
      if ($self->{sanity} == 1) {
          $save_warn_handler = $SIG{__WARN__};
          $SIG{__WARN__} = sub {
              $self->{output}->add_option_msg(short_msg => $_[0]);
              $self->{output}->option_exit(nolabel => 1);
          };
      }
  
      # Store all arguments placed after the special argument "--" in the 'extra_arguments' list
      $self->{options}->{'_double_dash_'} = \$self->{extra_arguments};
  
      GetOptions(
         %{$self->{options}}
      );
      %{$self->{options}} = ();
  
      $SIG{__WARN__} = $save_warn_handler if ($self->{sanity} == 1);
  }
  
  sub pod_where {
      my ($self, %options) = @_;
  
      if ($self->{pod_where_loaded} == 0) {
          $self->{pod_where_loaded} = 1;
          my ($code) = centreon::plugins::misc::mymodule_load(
              module => 'Pod::Find',
              no_quit => 1
          );
          if ($code) {
              $code = centreon::plugins::misc::mymodule_load(
                  module => 'Pod::Simple::Search',
                  no_quit => 1
              );
              die "Cannot load module 'Pod::Simple::Search'" if ($code);
              $self->{pod_where_loaded} = 2;
              $self->{pod_simple_search} = Pod::Simple::Search->new();
              $self->{pod_simple_search}->inc(1);
          }
      }
  
      if ($self->{pod_where_loaded} == 1) {
          return Pod::Find::pod_where({-inc => 1}, $options{package});
      }
      
      return $self->{pod_simple_search}->find($options{package});
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{options_stored}->{$options{argument}};
  }
  
  sub get_options {
      my $self = shift;
  
      return $self->{options_stored};
  }
  
  sub clean {
      my $self = shift;
  
      $self->{options_stored} = {};
  }
  
  1;
  
CENTREON_PLUGINS_OPTIONS

$fatpacked{"centreon/plugins/output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_OUTPUT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::output;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{options})) {
          print "Class Output: Need to specify 'options' argument to load.\n";
          exit 3;
      }
  
      $options{options}->add_options(arguments => {
          'explode-perfdata-max:s@' => { name => 'explode_perfdata_max' },
          'range-perfdata:s'        => { name => 'range_perfdata' },
          'filter-perfdata:s'       => { name => 'filter_perfdata' },
          'filter-perfdata-adv:s'   => { name => 'filter_perfdata_adv' },
          'change-perfdata:s@'      => { name => 'change_perfdata' },
          'extend-perfdata:s@'      => { name => 'extend_perfdata' },
          'extend-perfdata-group:s@'=> { name => 'extend_perfdata_group' },
          'change-exit:s@'          => { name => 'change_exit' },
          'change-short-output:s@'  => { name => 'change_short_output' },
          'change-long-output:s@'   => { name => 'change_long_output' },
          'change-output-adv:s@'    => { name => 'change_output_adv' },
          'use-new-perfdata'        => { name => 'use_new_perfdata' },
          'filter-uom:s'            => { name => 'filter_uom' },
          'verbose'                 => { name => 'verbose' },
          'debug'                   => { name => 'debug' },
          'debug-stream'            => { name => 'debug_stream' },
          'opt-exit:s'              => { name => 'opt_exit', default => 'unknown' },
          'output-xml'              => { name => 'output_xml' },
          'output-json'             => { name => 'output_json' },
          'output-ignore-perfdata'  => { name => 'output_ignore_perfdata' },
          'output-ignore-label'     => { name => 'output_ignore_label' },
          'output-openmetrics'      => { name => 'output_openmetrics' },
          'output-file:s'           => { name => 'output_file' },
          'disco-format'            => { name => 'disco_format' },
          'disco-show'              => { name => 'disco_show' },
          'float-precision:s'       => { name => 'float_precision', default => 8 },
          'source-encoding:s'       => { name => 'source_encoding' , default => 'UTF-8' }
      });
  
      $self->{option_results} = {};
      $self->{option_msg} = [];
  
      $self->{nodisplay} = 0;
      $self->{noexit_die} = 0;
  
      $self->{is_output_xml} = 0;
      $self->{is_output_json} = 0;
      $self->{errors} = {OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, PENDING => 4};
      $self->{errors_num} = {0 => 'OK', 1 => 'WARNING', 2 => 'CRITICAL', 3 => 'UNKNOWN', 4 => 'PENDING'};
      $self->{myerrors} = {0 => "OK", 1 => "WARNING", 3 => "UNKNOWN", 7 => "CRITICAL"};
      $self->{myerrors_mask} = {CRITICAL => 7, WARNING => 1, UNKNOWN => 3, OK => 0};
      $self->{global_short_concat_outputs} = {OK => undef, WARNING => undef, CRITICAL => undef, UNKNOWN => undef, UNQUALIFIED_YET => undef};
      $self->{global_short_outputs} = {OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [], UNQUALIFIED_YET => []};
      $self->{global_long_output} = [];
      $self->{perfdatas} = [];
      $self->{explode_perfdatas} = {};
      $self->{change_perfdata} = {};
      $self->{explode_perfdata_total} = 0;
      $self->{range_perfdata} = 0;
      $self->{global_status} = 0;
      $self->{encode_import} = 0;
      $self->{perlqq} = 0;
      $self->{safe_test} = 0;
  
      $self->{disco_elements} = [];
      $self->{disco_entries} = [];
  
      $self->{plugin} = '';
      $self->{mode} = '';
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      # $options{option_results} = ref to options result
  
      %{$self->{option_results}} = %{$options{option_results}};
      $self->{option_results}->{opt_exit} = lc($self->{option_results}->{opt_exit});
      if (!$self->is_litteral_status(status => $self->{option_results}->{opt_exit})) {
          $self->add_option_msg(short_msg => "Unknown value '" . $self->{option_results}->{opt_exit}  . "' for --opt-exit.");
          $self->option_exit(exit_litteral => 'unknown');
      }
      # Go in XML Mode
      if ($self->is_disco_show() || $self->is_disco_format()) {
          # By Default XML
          if (!defined($self->{option_results}->{output_json})) {
              $self->{option_results}->{output_xml} = 1;
          }
      }
  
      if (defined($self->{option_results}->{range_perfdata})) {
          $self->{range_perfdata} = $self->{option_results}->{range_perfdata};
          $self->{range_perfdata} = 1 if ($self->{range_perfdata} eq '');
          if ($self->{range_perfdata} !~ /^[012]$/) {
              $self->add_option_msg(short_msg => "Wrong range-perfdata option '" . $self->{range_perfdata} . "'");
              $self->option_exit();
          }
      }
  
      if (defined($self->{option_results}->{change_output_adv})) {
          foreach (@{$self->{option_results}->{change_output_adv}}) {
              my ($expr, $short_output, $exit_code) = split /,/;
              next if (!defined($expr) || $expr eq '');
  
              $expr =~ s/%\{(.*?)\}/\$values->{$1}/g;
              $expr =~ s/%\((.*?)\)/\$values->{$1}/g;
  
              if ( defined($exit_code) && $exit_code ne '' && defined( $self->{errors}->{uc($exit_code)} ) ) {
                  $exit_code = uc($exit_code);
              } else {
                  $exit_code = undef;
              }
  
              $self->{change_output_adv} = [] if (!defined($self->{change_output_adv}));
              push @{$self->{change_output_adv}}, {
                  expr => $expr,
                  short_output => $short_output,
                  exit_code => $exit_code
              };
          }
      }
  
      if (defined($self->{option_results}->{change_exit})) {
          $self->{change_exit} = {};
          foreach (@{$self->{option_results}->{change_exit}}) {
              my ($src, $dst) = split(/=/);
              next if (!defined($src) || !defined($self->{errors}->{ uc($src) }));
              next if (!defined($dst) || !defined($self->{errors}->{ uc($dst) }));
              $self->{change_exit}->{uc($src)} = uc($dst);
          }
      }
  
      if (defined($self->{option_results}->{explode_perfdata_max})) {
          if (${$self->{option_results}->{explode_perfdata_max}}[0] eq '') {
              $self->{explode_perfdata_total} = 2;
          } else {
              $self->{explode_perfdata_total} = 1;
              foreach (@{$self->{option_results}->{explode_perfdata_max}}) {
                  my ($perf_match, $perf_result) = split /,/;
                  if (!defined($perf_result)) {
                      $self->add_option_msg(short_msg => "Wrong explode-perfdata-max option '" . $_ . "' (syntax: match,value)");
                      $self->option_exit();
                  }
                  $self->{explode_perfdatas}->{$perf_match} = $perf_result;
              }
          }
      }
  
      if (defined($self->{option_results}->{filter_perfdata_adv}) && $self->{option_results}->{filter_perfdata_adv} ne '') {
          $self->{option_results}->{filter_perfdata_adv} =~ s/%\{(.*?)\}/\$values->{$1}/g;
          $self->{option_results}->{filter_perfdata_adv} =~ s/%\((.*?)\)/\$values->{$1}/g;
          $self->{option_results}->{filter_perfdata_adv} =~ s/alert_triggered\(\)/alert_triggered\(%\$values\)/g;
      }
  
      $self->load_perfdata_extend_args();
      $self->{option_results}->{use_new_perfdata} = 1 if (defined($self->{option_results}->{output_openmetrics}));
  
      $self->{source_encoding} = (!defined($self->{option_results}->{source_encoding}) || $self->{option_results}->{source_encoding} eq '') ?
          'UTF-8' : $self->{option_results}->{source_encoding};
  }
  
  sub add_option_msg {
      my ($self, %options) = @_;
      # $options{short_msg} = string msg
      # $options{long_msg} = string msg
      $options{severity} = 'UNQUALIFIED_YET';
  
      $self->output_add(%options);
  }
  
  sub set_ignore_label {
      my ($self, %options) = @_;
  
      $self->{option_results}->{output_ignore_label} = 1;
  }
  
  sub set_status {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
  
      # Nothing to do for 'UNQUALIFIED_YET'
      if (!$self->{myerrors_mask}->{uc($options{exit_litteral})}) {
          return ;
      }
      $self->{global_status} |= $self->{myerrors_mask}->{uc($options{exit_litteral})};
  }
  
  sub output_add {
      my ($self, %params) = @_;
      my %args = (
          severity => 'OK',
          separator => ' - ',
          debug => 0,
          short_msg => undef,
          long_msg => undef,
      );
      my $options = { %args, %params };
  
      if (defined($options->{short_msg})) {
          chomp $options->{short_msg};
          if (defined($self->{global_short_concat_outputs}->{uc($options->{severity})})) {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} .= $options->{separator} . $options->{short_msg};
          } else {
              $self->{global_short_concat_outputs}->{uc($options->{severity})} = $options->{short_msg};
          }
  
          push @{$self->{global_short_outputs}->{uc($options->{severity})}}, $options->{short_msg};
          $self->set_status(exit_litteral => $options->{severity});
      }
  
      if (defined($options->{long_msg})) {
          chomp $options->{long_msg};
  
          push @{$self->{global_long_output}}, $options->{long_msg} if ($options->{debug} == 0 || defined($self->{option_results}->{debug}));
          print $options->{long_msg} . "\n" if (defined($self->{option_results}->{debug_stream}));
      }
  }
  
  sub perfdata_add {
      my ($self, %options) = @_;
  
      my $perfdata = {
          label => '', value => '', unit => '', warning => '', critical => '', min => '', max => '', mode => $self->{mode}
      };
      foreach (keys %options) {
          next if (!defined($options{$_}));
          $perfdata->{$_} = $options{$_};
      }
  
      if ((defined($self->{option_results}->{use_new_perfdata}) || defined($options{force_new_perfdata})) &&
          defined($options{nlabel})) {
          $perfdata->{label} = $options{nlabel};
      }
      if (defined($options{instances})) {
          $options{instances} = [$options{instances}] if (!ref($options{instances}));
          my ($external_instance_separator, $internal_instance_separator) = ('#', '~');
          if (defined($self->{option_results}->{use_new_perfdata}) || defined($options{force_new_perfdata})) {
              $perfdata->{label} = join('~', @{$options{instances}}) . '#' . $perfdata->{label};
          } else {
              $perfdata->{label} .= '_' . join('_', @{$options{instances}});
          }
      }
  
      $perfdata->{label} =~ s/'/''/g;
      push @{$self->{perfdatas}}, $perfdata;
  }
  
  sub filter_perfdata {
      my ($self, %options) = @_;
  
      return 1 if (
          defined($self->{option_results}->{filter_perfdata}) &&
          $options{perf}->{label} !~ /$self->{option_results}->{filter_perfdata}/
      );
  
      return 1 if (
          defined($self->{option_results}->{filter_perfdata_adv}) &&
          $self->{option_results}->{filter_perfdata_adv} ne '' &&
          !$self->test_eval(test => $self->{option_results}->{filter_perfdata_adv}, values => $options{perf})
      );
  
      return 0;
  }
  
  sub range_perfdata {
      my ($self, %options) = @_;
  
      return if ($self->{range_perfdata} == 0);
      if ($self->{range_perfdata} == 1) {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} =~ s/^(@?)-?[0\.]+:/$1/;
          }
      } else {
          for (my $i = 0; $i < scalar(@{$options{ranges}}); $i++) {
              ${${$options{ranges}}[$i]} = '';
          }
      }
  }
  
  sub output_json {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my $json_content = {
          plugin => {
              name => $self->{plugin},
              mode => $self->{mode},
              exit => $options{exit_litteral},
              outputs => [],
              perfdatas => []
          }
      };
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 1,
                  msg => ($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_,
                  exit => $lcode_litteral
              };
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              push @{$json_content->{plugin}->{outputs}}, {
                  type => 2,
                  msg => $_
              };
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
  
              my %values = ();
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  $values{$key} = $perf->{$key};
              }
  
              push @{$json_content->{plugin}->{perfdatas}}, {
                  %values
              };
          }
      }
  
      print $self->{json_output}->encode($json_content);
  }
  
  sub output_xml {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      my ($child_plugin_name, $child_plugin_mode, $child_plugin_exit, $child_plugin_output, $child_plugin_perfdata);
  
      my $root = $self->{xml_output}->createElement('plugin');
      $self->{xml_output}->setDocumentElement($root);
  
      $child_plugin_name = $self->{xml_output}->createElement('name');
      $child_plugin_name->appendText($self->{plugin});
  
      $child_plugin_mode = $self->{xml_output}->createElement('mode');
      $child_plugin_mode->appendText($self->{mode});
  
      $child_plugin_exit = $self->{xml_output}->createElement('exit');
      $child_plugin_exit->appendText($options{exit_litteral});
  
      $child_plugin_output = $self->{xml_output}->createElement('outputs');
      $child_plugin_perfdata = $self->{xml_output}->createElement('perfdatas');
  
      $root->addChild($child_plugin_name);
      $root->addChild($child_plugin_mode);
      $root->addChild($child_plugin_exit);
      $root->addChild($child_plugin_output);
      $root->addChild($child_plugin_perfdata);
  
      foreach my $code_litteral (keys %{$self->{global_short_outputs}}) {
          foreach (@{$self->{global_short_outputs}->{$code_litteral}}) {
              my ($child_output, $child_type, $child_msg, $child_exit);
              my $lcode_litteral = ($code_litteral eq 'UNQUALIFIED_YET' ? uc($options{exit_litteral}) : $code_litteral);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(1); # short
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText(($options{nolabel} == 0 ? ($lcode_litteral . ': ') : '') . $_);
              $child_exit = $self->{xml_output}->createElement('exit');
              $child_exit->appendText($lcode_litteral);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_exit);
              $child_output->addChild($child_msg);
          }
      }
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          foreach (@{$self->{global_long_output}}) {
              my ($child_output, $child_type, $child_msg);
  
              $child_output = $self->{xml_output}->createElement('output');
              $child_plugin_output->addChild($child_output);
  
              $child_type = $self->{xml_output}->createElement('type');
              $child_type->appendText(2); # long
  
              $child_msg = $self->{xml_output}->createElement('msg');
              $child_msg->appendText($_);
  
              $child_output->addChild($child_type);
              $child_output->addChild($child_msg);
          }
      }
  
      if ($options{force_ignore_perfdata} == 0) {
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
  
              my ($child_perfdata);
              $child_perfdata = $self->{xml_output}->createElement('perfdata');
              $child_plugin_perfdata->addChild($child_perfdata);
              foreach my $key (keys %$perf) {
                  $perf->{$key} = '' if (defined($self->{option_results}->{filter_uom}) && $key eq 'unit' &&
                      $perf->{$key} !~ /$self->{option_results}->{filter_uom}/);
                  my $child = $self->{xml_output}->createElement($key);
                  $child->appendText($perf->{$key});
                  $child_perfdata->addChild($child);
              }
          }
      }
  
      print $self->{xml_output}->toString(1);
  }
  
  sub output_openmetrics {
      my ($self, %options) = @_;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'Time::HiRes',
          error_msg => "Cannot load module 'Time::HiRes'."
      );
  
      my $time_ms = int(Time::HiRes::time() * 1000);
      $self->change_perfdata();
  
      foreach my $perf (@{$self->{perfdatas}}) {
          next if ($self->filter_perfdata(perf => $perf));
  
          $perf->{unit} = '' if (
              defined($self->{option_results}->{filter_uom}) &&
              $perf->{unit} !~ /$self->{option_results}->{filter_uom}/
          );
          $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
          my $label = $perf->{label};
          my $instance;
          if ($label =~ /^(.*?)#(.*)$/) {
              ($perf->{instance}, $label) = ($1, $2);
          }
          my ($bucket, $append) = ('{plugin="' . $self->{plugin} . '",mode="' . $perf->{mode} . '"', '');
          foreach ('unit', 'warning', 'critical', 'min', 'max', 'instance') {
              if (defined($perf->{$_}) && $perf->{$_} ne '') {
                  $bucket .= ',' . $_ . '="' . $perf->{$_} . '"';
              }
          }
          $bucket .= '}';
  
          print $label . $bucket . ' ' . $perf->{value} . ' ' . $time_ms . "\n";
      }
  }
  
  sub output_txt_short_display {
      my ($self, %options) = @_;
  
      if (defined($self->{global_short_concat_outputs}->{CRITICAL})) {
          print (($options{nolabel} == 0 ? 'CRITICAL: ' : '') . $self->{global_short_concat_outputs}->{CRITICAL} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{WARNING})) {
          print (($options{nolabel} == 0 ? 'WARNING: ' : '') . $self->{global_short_concat_outputs}->{WARNING} . " ");
      }
      if (defined($self->{global_short_concat_outputs}->{UNKNOWN})) {
          print (($options{nolabel} == 0 ? 'UNKNOWN: ' : '') . $self->{global_short_concat_outputs}->{UNKNOWN} . " ");
      }
      if (uc($options{exit_litteral}) eq 'OK') {
          print (($options{nolabel} == 0 ? 'OK: ' : '') . (defined($self->{global_short_concat_outputs}->{OK}) ? $self->{global_short_concat_outputs}->{OK} : '') . " ");
      }
  }
  
  sub output_txt_short {
      my ($self, %options) = @_;
  
      if (!defined($self->{option_results}->{change_short_output}) && 
          !defined($self->{change_output_adv})) {
          $self->output_txt_short_display(%options);
          return ;
      }
  
      my $stdout = '';
      {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
          $self->output_txt_short_display(%options);
      }
  
      foreach (@{$self->{option_results}->{change_short_output}}) {
           my ($pattern, $replace, $modifier) = split /~/;
           next if (!defined($pattern));
           $replace = '' if (!defined($replace));
           $modifier = '' if (!defined($modifier));
           eval "\$stdout =~ s{$pattern}{$replace}$modifier";
      }
  
      my $exit = defined($options{exit_litteral}) ? uc($options{exit_litteral}) : uc($self->{myerrors}->{ $self->{global_status} });
      foreach (@{$self->{change_output_adv}}) {
          if ($self->test_eval(test => $_->{expr}, values => { short_output => $stdout, exit_code => $self->{errors}->{$exit} })) {
              if (defined($_->{short_output}) && $_->{short_output} ne '') {
                  $stdout = $_->{short_output};
              }
              if (defined($_->{exit_code}) && $_->{exit_code} ne '') {
                  $self->{coa_save_exit_code} = $_->{exit_code};
              }
          }
      }
  
      print $stdout;
  }
  
  sub output_txt {
      my ($self, %options) = @_;
      my $force_ignore_perfdata = (defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
  
      return if ($self->{nodisplay} == 1);
  
      if (defined($self->{global_short_concat_outputs}->{UNQUALIFIED_YET})) {
          $self->output_add(severity => uc($options{exit_litteral}), short_msg => $self->{global_short_concat_outputs}->{UNQUALIFIED_YET});
      }
  
      $self->output_txt_short(%options);
  
      if ($force_ignore_perfdata == 0) {
          my $pipe = 0;
          $self->change_perfdata();
          foreach my $perf (@{$self->{perfdatas}}) {
              next if ($self->filter_perfdata(perf => $perf));
              $perf->{unit} = '' if (defined($self->{option_results}->{filter_uom}) &&
                  $perf->{unit} !~ /$self->{option_results}->{filter_uom}/);
              $self->range_perfdata(ranges => [\$perf->{warning}, \$perf->{critical}]);
              if ($pipe == 0) {
                  print '|';
                  $pipe = 1;
              }
              print " '" . $perf->{label} . "'=" . $perf->{value} . $perf->{unit} . ';' . $perf->{warning} . ';' . $perf->{critical} . ';' . $perf->{min} . ';' . $perf->{max};
          }
      }
  
      print "\n";
  
      if (defined($self->{option_results}->{verbose}) || $force_long_output == 1) {
          if (scalar(@{$self->{global_long_output}})) {
              print join("\n", @{$self->{global_long_output}});
              print "\n";
          }
      }
  }
  
  sub change_long_output {
      my ($self, %options) = @_;
  
      return if (!(defined($self->{option_results}->{verbose}) || $options{force_long_output} == 1));
      return if (!defined($self->{option_results}->{change_long_output}));
  
      my $long_output = join("\n", @{$self->{global_long_output}});
  
      foreach (@{$self->{option_results}->{change_long_output}}) {
          my ($pattern, $replace, $modifier) = split /~/;
          next if (!defined($pattern));
          $replace = '' if (!defined($replace));
          $modifier = '' if (!defined($modifier));
          eval "\$long_output =~ s{$pattern}{$replace}$modifier";
      }
  
      $self->{global_long_output} = [split(/\n/, $long_output)];
  }
  
  sub display {
      my ($self, %options) = @_;
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
      my $force_ignore_perfdata = ((defined($options{force_ignore_perfdata}) && $options{force_ignore_perfdata} == 1) || $self->{option_results}->{output_ignore_perfdata}) ? 1 : 0;
      my $force_long_output = (defined($options{force_long_output}) && $options{force_long_output} == 1) ? 1 : 0;
      $force_long_output = 1 if (defined($self->{option_results}->{debug}));
  
      if (defined($self->{option_results}->{output_openmetrics})) {
          $self->perfdata_add(nlabel => 'plugin.mode.status', value => $self->{errors}->{$self->{myerrors}->{$self->{global_status}}});
      }
  
      if (defined($self->{option_results}->{change_long_output})) {
          $self->change_long_output(force_long_output => $force_long_output);
      }
  
      return if ($self->{nodisplay} == 1);
  
      if (defined($self->{option_results}->{output_file})) {
          if (!open (STDOUT, '>', $self->{option_results}->{output_file})) {
              $self->output_add(
                  severity => 'UNKNOWN',
                  short_msg => "cannot open file  '" . $self->{option_results}->{output_file} . "': $!"
              );
          }
      }
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(
                  exit_litteral => $self->get_litteral_status(),
                  nolabel => $nolabel,
                  force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
              );
              return ;
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(
                  exit_litteral => $self->get_litteral_status(),
                  nolabel => $nolabel,
                  force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
              );
              return ;
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->output_openmetrics();
          return ;
      }
  
      $self->output_txt(
          exit_litteral => $self->get_litteral_status(),
          nolabel => $nolabel,
          force_ignore_perfdata => $force_ignore_perfdata, force_long_output => $force_long_output
      );
  }
  
  sub die_exit {
      my ($self, %options) = @_;
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
      # ignore long output in the following case
      $self->{option_results}->{verbose} = undef;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub option_exit {
      my ($self, %options) = @_;
  
      $self->add_option_msg(short_msg => $options{short_msg}) if defined $options{short_msg};
  
      # $options{exit_litteral} = string litteral exit
      # $options{nolabel} = interger label display
      my $exit_litteral = defined($options{exit_litteral}) ? $options{exit_litteral} : $self->{option_results}->{opt_exit};
      my $nolabel = (defined($options{nolabel}) || defined($self->{option_results}->{output_ignore_label})) ? 1 : 0;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
          if ($self->{is_output_xml}) {
              $self->output_xml(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          if ($self->{is_output_json}) {
              $self->output_json(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
              $self->exit(exit_litteral => $exit_litteral);
          }
      } elsif (defined($self->{option_results}->{output_openmetrics})) {
          $self->set_status(exit_litteral => $exit_litteral);
          $self->output_openmetrics();
          $self->exit(exit_litteral => $exit_litteral);
      }
  
      $self->output_txt(exit_litteral => $exit_litteral, nolabel => $nolabel, force_ignore_perfdata => 1, force_long_output => 1);
      $self->exit(exit_litteral => $exit_litteral);
  }
  
  sub exit {
      my ($self, %options) = @_;
  
      if ($self->{noexit_die} == 1) {
          die 'exit';
      }
  
      my $exit;
      if (defined($options{exit_litteral})) {
          $exit = uc($options{exit_litteral});
      } else {
          $exit = $self->{myerrors}->{ $self->{global_status} };
      }
   
      if (defined($self->{coa_save_exit_code})) {
          $exit = $self->{coa_save_exit_code};
      }
      if (defined($self->{change_exit}) && defined($self->{change_exit}->{$exit})) {
          $exit = $self->{change_exit}->{$exit};
      }
      exit $self->{errors}->{$exit};
  }
  
  sub get_option {
      my ($self, %options) = @_;
  
      return $self->{option_results}->{$options{option}};
  }
  
  sub get_most_critical {
      my ($self, %options) = @_;
      my $current_status = 0; # For 'OK'
  
      foreach (@{$options{status}}) {
          if ($self->{myerrors_mask}->{uc($_)} > $current_status) {
              $current_status = $self->{myerrors_mask}->{uc($_)};
          }
      }
      return $self->{myerrors}->{$current_status};
  }
  
  sub get_litteral_status {
      my ($self, %options) = @_;
  
      if (defined($options{status})) {
          if (defined($self->{errors_num}->{$options{status}})) {
              return $self->{errors_num}->{$options{status}};
          }
          return $options{status};
      } else {
          return $self->{myerrors}->{$self->{global_status}};
      }
  }
  
  sub is_status {
      my ($self, %options) = @_;
      # $options{value} = string status
      # $options{litteral} = value is litteral
      # $options{compare} = string status
  
      if (defined($options{litteral})) {
          my $value = defined($options{value}) ? $options{value} : $self->get_litteral_status();
  
          if (uc($value) eq uc($options{compare})) {
              return 1;
          }
          return 0;
      }
  
      my $value = defined($options{value}) ? $options{value} : $self->{global_status};
      my $dec_val = $self->{myerrors_mask}->{$value};
      my $lresult = $value & $dec_val;
      # Need to manage 0
      if ($lresult > 0 || ($dec_val == 0 && $value == 0)) {
          return 1;
      }
      return 0;
  }
  
  sub is_litteral_status {
      my ($self, %options) = @_;
      # $options{status} = string status
  
      if (defined($self->{errors}->{uc($options{status})})) {
          return 1;
      }
  
      return 0;
  }
  
  sub create_json_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(
          no_quit => 1, module => 'JSON',
          error_msg => "Cannot load module 'JSON'.")
          ) {
          print "Cannot load module 'JSON'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_json} = 1;
      $self->{json_output} = JSON->new->utf8();
  }
  
  sub create_xml_document {
      my ($self) = @_;
  
      if (centreon::plugins::misc::mymodule_load(
          no_quit => 1, module => 'XML::LibXML',
          error_msg => "Cannot load module 'XML::LibXML'.")
          ) {
          print "Cannot load module 'XML::LibXML'\n";
          $self->exit(exit_litteral => 'unknown');
      }
      $self->{is_output_xml} = 1;
      $self->{xml_output} = XML::LibXML::Document->new('1.0', 'utf-8');
  }
  
  sub plugin {
      my ($self, %options) = @_;
      # $options{name} = string name
  
      if (defined($options{name})) {
          $self->{plugin} = $options{name};
      }
      return $self->{plugin};
  }
  
  sub mode {
      my ($self, %options) = @_;
  
      if (defined($options{name})) {
          $self->{mode} = $options{name};
      }
      return $self->{mode};
  }
  
  sub add_disco_format {
      my ($self, %options) = @_;
  
      push @{$self->{disco_elements}}, @{$options{elements}};
  }
  
  sub display_disco_format {
      my ($self, %options) = @_;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
  
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_elements}}) {
              my $child = $self->{xml_output}->createElement("element");
              $child->appendText($_);
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_elements}}) {
              push @{$json_content->{data}}, $_;
          }
  
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub display_disco_show {
      my ($self, %options) = @_;
  
      if (defined($self->{option_results}->{output_xml})) {
          $self->create_xml_document();
  
          my $root = $self->{xml_output}->createElement('data');
          $self->{xml_output}->setDocumentElement($root);
  
          foreach (@{$self->{disco_entries}}) {
              my $child = $self->{xml_output}->createElement('label');
              foreach my $key (keys %$_) {
                  # Encode all non printable chars as hexadecimal entities to produce valid XML
                  # I.e. "test ^H" becomes "test &#x8;"
                  my $val = $_->{$key};
                  $val=~s{([[:cntrl:]])}{"&#x".sprintf("%X",ord($1)).";"}ge;
                  $child->setAttribute($key, $val);
              }
              $root->addChild($child);
          }
  
          print $self->{xml_output}->toString(1);
      } elsif (defined($self->{option_results}->{output_json})) {
          $self->create_json_document();
          my $json_content = {data => [] };
          foreach (@{$self->{disco_entries}}) {
              my %values = ();
              foreach my $key (keys %$_) {
                  $values{$key} = $_->{$key};
              }
              push @{$json_content->{data}}, {%values};
          }
  
          print $self->{json_output}->encode($json_content);
      }
  }
  
  sub decode {
      my ($self, $value) = @_;
  
      if ($self->{encode_import} == 0) {
          # Some Perl version dont have the following module (like Perl 5.6.x)
          my $rv = centreon::plugins::misc::mymodule_load(
              no_quit => 1,
              module => 'Encode',
              error_msg => "Cannot load module 'Encode'."
          );
          return $value if ($rv);
  
          $self->{encode_import} = 1;
          eval '$self->{perlqq} = Encode::PERLQQ';
      }
  
      return centreon::plugins::misc::trim(Encode::decode($self->{source_encoding}, $value, $self->{perlqq}));
  }
  
  sub parameter {
      my ($self, %options) = @_;
  
      if (defined($options{attr})) {
          $self->{$options{attr}} = $options{value};
      }
      return $self->{$options{attr}};
  }
  
  sub add_disco_entry {
      my ($self, %options) = @_;
  
      push @{$self->{disco_entries}}, {%options};
  }
  
  sub is_disco_format {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_format})) {
          return 1;
      }
      return 0;
  }
  
  sub is_disco_show {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{disco_show})) {
          return 1;
      }
      return 0;
  }
  
  sub is_verbose {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{verbose})) {
          return 1;
      }
      return 0;
  }
  
  sub is_debug {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{debug}) || defined($self->{option_results}->{debug_stream})) {
          return 1;
      }
      return 0;
  }
  
  sub load_eval {
      my ($self) = @_;
  
      my ($code) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'Safe',
          no_quit => 1
      );
      if ($code == 0) {
          $self->{safe} = Safe->new();
          $self->{safe}->share('$values');
          $self->{safe}->share('$assign_var');
          $self->{safe}->share_from('centreon::plugins::misc', ['alert_triggered']);
      }
  
      $self->{safe_test} = 1;
  }
  
  sub test_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
  
      my $result;
      if (defined($self->{safe})) {
          our $values = $options{values};
          $result = $self->{safe}->reval($options{test}, 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } elsif (defined($options{values})) {
          my $values = $options{values};
          {
              local $SIG{__WARN__} = sub {}; # ignore
  
              $result = eval "$options{test}";
              if ($@) {
                  die 'Code evaluation error: ' . $@;
              }
          }
      }
  
      return $result;
  }
  
  sub open_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
      our $values = $options{values};
      $self->{safe}->reval("$options{eval}", 1);
  
      return $values;
  }
  
  sub assign_eval {
      my ($self, %options) = @_;
  
      $self->load_eval() if ($self->{safe_test} == 0);
  
      our $assign_var;
      if (defined($self->{safe})) {
          our $values = $options{values};
          $self->{safe}->reval("\$assign_var = $options{eval}", 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } else {
          my $values = $options{values};
          eval "\$assign_var = $options{eval}";
      }
  
      return $assign_var;
  }
  
  sub use_new_perfdata {
      my ($self, %options) = @_;
  
      $self->{option_results}->{use_new_perfdata} = $options{value}
          if (defined($options{value}));
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return 1;
      }
      return 0;
  }
  
  sub get_instance_perfdata_separator {
      my ($self) = @_;
  
      if (defined($self->{option_results}->{use_new_perfdata})) {
          return '~';
      }
      return '_';
  }
  
  sub parse_pfdata_scale {
      my ($self, %options) = @_;
  
      # --extend-perfdata=traffic_in,,scale(Mbps),mbps
      my $args = { unit => 'auto' };
      if ($options{args} =~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s|auto)$/) {
          $args->{quantity} = defined($1) ? $1 : '';
          $args->{unit} = $2;
      } elsif ($options{args} ne '') {
          return 1;
      }
  
      return (0, $args);
  }
  
  sub parse_pfdata_math {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,math(current + 10 - 100, 1)
      my $args = { math => undef, apply_threshold => 0 };
      my ($math, $apply_threshold) = split /\|/, $options{args};
      if ($math =~ /^((?:[\s\.\-\+\*\/0-9\(\)]|current)+)$/) {
          $args->{math} = $1;
      } elsif ($options{args} ne '') {
          return 1;
      }
  
      if (defined($apply_threshold) && $apply_threshold =~ /^\s*(0|1)\s*$/ ) {
          $args->{apply_threshold} = $1;
      }
  
      return (0, $args);
  }
  
  sub parse_pfdata_eval {
      my ($self, %options) = @_;
  
      # --extend-perfdata=perfx,,eval(%(label) =~ s/a/A/g)
      my $args = { expr => $options{args} };
      $args->{expr} =~ s/%\{(.*?)\}/\$values->{$1}/g;
      $args->{expr} =~ s/%\((.*?)\)/\$values->{$1}/g;
      return (0, $args);
  }
  
  sub parse_group_pfdata {
      my ($self, %options) = @_;
  
      $options{args} =~ s/^\s+//;
      $options{args} =~ s/\s+$//;
      my $args = { pattern_pf => $options{args} };
      return $args;
  }
  
  sub parse_pfdata_min {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_max {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_average {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub parse_pfdata_sum {
      my ($self, %options) = @_;
  
      my $args = $self->parse_group_pfdata(%options);
      return (0, $args);
  }
  
  sub apply_pfdata_scale {
      my ($self, %options) = @_;
  
      return if (${$options{perf}}->{unit} !~ /^([KMGTPEkmgtpe])?(B|b|bps|Bps|b\/s)$/);
  
      my ($src_quantity, $src_unit) = ($1, $2);
      my ($value, $dst_quantity, $dst_unit) = centreon::plugins::misc::scale_bytesbit(
          value => ${$options{perf}}->{value},
          src_quantity => $src_quantity, src_unit => $src_unit, dst_quantity => $options{args}->{quantity}, dst_unit => $options{args}->{unit}
      );
      ${$options{perf}}->{value} = sprintf('%.2f', $value);
      if (defined($dst_unit)) {
         ${$options{perf}}->{unit} = $dst_quantity . $dst_unit;
      } else {
          ${$options{perf}}->{unit} = $options{args}->{quantity} . $options{args}->{unit};
      }
  
      if (defined(${$options{perf}}->{max}) && ${$options{perf}}->{max} ne '') {
          ($value) = centreon::plugins::misc::scale_bytesbit(value => ${$options{perf}}->{max},
              src_quantity => $src_quantity, src_unit => $src_unit,
              dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
              dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          ${$options{perf}}->{max} = sprintf('%.2f', $value);
      }
  
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              ($result->{start}) = centreon::plugins::misc::scale_bytesbit(value => $result->{start},
                  src_quantity => $src_quantity, src_unit => $src_unit,
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              ($result->{end}) = centreon::plugins::misc::scale_bytesbit(value => $result->{end},
                  src_quantity => $src_quantity, src_unit => $src_unit,
                  dst_quantity => defined($dst_unit) ? $dst_quantity : $options{args}->{quantity},
                  dst_unit => defined($dst_unit) ? $dst_unit : $options{args}->{unit});
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  }
  
  sub apply_pfdata_invert {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
  
      ${$options{perf}}->{value} = ${$options{perf}}->{max} - ${$options{perf}}->{value};
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
          $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
          $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $tmp->{end} = ${$options{perf}}->{max} - $result->{start};
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $tmp->{start} = ${$options{perf}}->{max} - $result->{end};
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
      }
  }
  
  sub apply_pfdata_percent {
      my ($self, %options) = @_;
  
      return if (!defined(${$options{perf}}->{max}) || ${$options{perf}}->{max} eq '');
  
      ${$options{perf}}->{value} = sprintf('%.2f', ${$options{perf}}->{value} * 100 / ${$options{perf}}->{max});
      ${$options{perf}}->{unit} = '%';
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $result->{start} = sprintf('%.2f', $result->{start} * 100 / ${$options{perf}}->{max});
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $result->{end} = sprintf('%.2f', $result->{end} * 100 / ${$options{perf}}->{max});
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_eval {
      my ($self, %options) = @_;
  
      ${$options{perf}} = $self->open_eval(eval => $options{args}->{expr}, values => ${$options{perf}});
  }
  
  sub apply_pfdata_math {
      my ($self, %options) = @_;
  
      my $math = $options{args}->{math};
      $math =~ s/current/\$value/g;
  
      my $value = ${$options{perf}}->{value};
      eval "\${\$options{perf}}->{value} = $math";
  
      return if ($options{args}->{apply_threshold} == 0);
  
      foreach my $threshold ('warning', 'critical') {
          next if (${$options{perf}}->{$threshold} eq '');
          my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => ${$options{perf}}->{$threshold});
          next if ($status == 0);
  
          if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
              $value = $result->{start};
              eval "\$result->{start} = $math";
          }
          if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
              $value = $result->{end};
              eval "\$result->{end} = $math";
          }
  
          ${$options{perf}}->{$threshold} = centreon::plugins::misc::get_threshold_litteral(%$result);
      }
  
      ${$options{perf}}->{max} = 100;
  }
  
  sub apply_pfdata_min {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my $min;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $min = $self->{perfdatas}->[$i]->{value}
              if (!defined($min) || $min > $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $min
          if (defined($min));
  }
  
  sub apply_pfdata_max {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my $max;
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $max = $self->{perfdatas}->[$i]->{value}
              if (!defined($max) || $max < $self->{perfdatas}->[$i]->{value});
      }
  
      ${$options{perf}}->{value} = $max
          if (defined($max));
  }
  
  sub apply_pfdata_sum {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = $sum
          if ($num > 0);
  }
  
  sub apply_pfdata_average {
      my ($self, %options) = @_;
  
      my $pattern_pf = $self->assign_eval(eval => "\"$options{args}->{pattern_pf}\"");
      my ($sum, $num) = (0, 0);
      for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
          next if ($self->{perfdatas}->[$i]->{label} !~ /$pattern_pf/);
          next if ($self->{perfdatas}->[$i]->{value} !~ /\d+/);
          $sum += $self->{perfdatas}->[$i]->{value};
          $num++;
      }
  
      ${$options{perf}}->{value} = sprintf("%.2f", ($sum / $num))
          if ($num > 0);
  }
  
  sub apply_perfdata_thresholds {
      my ($self, %options) = @_;
  
      foreach (('warning', 'critical')) {
          next if (!defined($options{$_}));
  
          my @thresholds = split(':', $options{$_}, -1);
          for (my $i = 0; $i < scalar(@thresholds); $i++) {
              if ($thresholds[$i] =~ /(\d+(?:\.\d+)?)\s*%/) {
                  if (!defined($options{max}) || $options{max} eq '') {
                      $thresholds[$i] = '';
                      next;
                  }
                  $thresholds[$i] = $1 * $options{max} / 100;
              } elsif ($thresholds[$i] =~ /(\d+(?:\.\d+)?)/) {
                  $thresholds[$i] = $1;
              } else {
                  $thresholds[$i] = '';
              }
          }
  
          ${$options{perf}}->{$_} = join(':', @thresholds);
      }
  }
  
  sub load_perfdata_extend_args {
      my ($self, %options) = @_;
  
      foreach (
          [$self->{option_results}->{change_perfdata}, 1],
          [$self->{option_results}->{extend_perfdata}, 2],
          [$self->{option_results}->{extend_perfdata_group}, 3],
      ) {
          next if (!defined($_->[0]));
          foreach my $arg (@{$_->[0]}) {
              $self->parse_perfdata_extend_args(arg => $arg, type => $_->[1]);
          }
      }
  }
  
  sub parse_perfdata_extend_args {
      my ($self, %options) = @_;
  
      # --extend-perfdata=searchlabel,newlabel,method[,[newuom],[min],[max],[warning],[critical]]
      my ($pfdata_match, $pfdata_substitute, $method, $uom_sub, $min_sub, $max_sub, $warn_sub, $crit_sub) =
          split /,/, $options{arg};
      return if ((!defined($pfdata_match) || $pfdata_match eq '') && $options{type} != 3);
  
      $self->{pfdata_extends} = [] if (!defined($self->{pfdata_extends}));
      my $pfdata_extends = {
          pfdata_match => defined($pfdata_match) && $pfdata_match ne '' ? $pfdata_match : undef,
          pfdata_substitute => defined($pfdata_substitute) && $pfdata_substitute ne '' ? $pfdata_substitute : undef,
          uom_sub => defined($uom_sub) && $uom_sub ne '' ? $uom_sub : undef,
          min_sub => defined($min_sub) && $min_sub ne '' ? $min_sub : undef,
          max_sub => defined($max_sub) && $max_sub ne '' ? $max_sub : undef,
          warn_sub => defined($warn_sub) && $warn_sub ne '' ? $warn_sub : undef,
          crit_sub => defined($crit_sub) && $crit_sub ne '' ? $crit_sub : undef,
          type => $options{type}
      };
  
      if (defined($method) && $method ne '') {
          if ($method !~ /^\s*(invert|percent|scale|math|min|max|average|sum|eval)\s*\(\s*(.*?)\s*\)\s*$/) {
              $self->output_add(long_msg => "method in argument '$options{arg}' is unknown", debug => 1);
              return ;
          }
  
          $pfdata_extends->{method_name} = $1;
          my $args = $2;
          if (my $func = $self->can('parse_pfdata_' . $pfdata_extends->{method_name})) {
              (my $status, $pfdata_extends->{method_args}) = $func->($self, args => $args);
              if ($status == 1) {
                  $self->output_add(long_msg => "argument in method '$options{arg}' is unknown", debug => 1);
                  return ;
              }
          }
      }
  
      push @{$self->{pfdata_extends}}, $pfdata_extends;
  }
  
  sub apply_perfdata_explode {
      my ($self, %options) = @_;
  
      return if ($self->{explode_perfdata_total} == 0);
      foreach (@{$self->{perfdatas}}) {
          next if ($_->{max} eq '');
          if ($self->{explode_perfdata_total} == 2) {
              $self->perfdata_add(label => $_->{label} . '_max', value => $_->{max}, unit => $_->{unit});
              next;
          }
          foreach my $regexp (keys %{$self->{explode_perfdatas}}) {
              if ($_->{label} =~ /$regexp/) {
                  $self->perfdata_add(label => $self->{explode_perfdatas}->{$regexp}, value => $_->{max}, unit => $_->{unit});
                  last;
              }
          }
      }
  }
  
  sub apply_perfdata_extend {
      my ($self, %options) = @_;
  
      foreach my $extend (@{$self->{pfdata_extends}}) {
          my $new_pfdata = [];
  
          # Manage special case when type group and pfdata_match empty
          if ($extend->{type} == 3 && (!defined($extend->{pfdata_match}) || $extend->{pfdata_match} eq '')) {
              next if (!defined($extend->{pfdata_substitute}) || $extend->{pfdata_substitute} eq '');
              my $new_perf = {
                  label => $extend->{pfdata_substitute}, value => '',
                  unit => defined($extend->{uom_sub}) ? $extend->{uom_sub} : '',
                  warning => '', critical => '',
                  min => defined($extend->{min_sub}) ? $extend->{min_sub} : '',
                  max => defined($extend->{max_sub}) ? $extend->{max_sub} : ''
              };
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              $self->apply_perfdata_thresholds(
                  perf => \$new_perf,
                  warning => $extend->{warn_sub},
                  critical => $extend->{crit_sub},
                  max => $new_perf->{max}
              );
              if (length($new_perf->{value})) {
                  push @{$self->{perfdatas}}, $new_perf;
              }
              next;
          }
  
          for (my $i = 0; $i < scalar(@{$self->{perfdatas}}); $i++) {
              next if ($self->{perfdatas}->[$i]->{label} !~ /$extend->{pfdata_match}/);
  
              my $new_perf = { %{$self->{perfdatas}->[$i]} };
              if ($extend->{type} == 3) {
                  $new_perf = { label => $self->{perfdatas}->[$i]->{label}, value => '', unit => '', warning => '', critical => '', min => '', max => '' };
              }
  
              if (defined($extend->{pfdata_substitute})) {
                  eval "\$new_perf->{label} =~ s{$extend->{pfdata_match}}{$extend->{pfdata_substitute}}";
              }
  
              if (defined($extend->{method_name})) {
                  my $func = $self->can('apply_pfdata_' . $extend->{method_name});
                  $func->($self, perf => \$new_perf, args => $extend->{method_args});
              }
  
              $new_perf->{unit} = $extend->{uom_sub} if (defined($extend->{uom_sub}));
              $new_perf->{min} = $extend->{min_sub} if (defined($extend->{min_sub}));
              $new_perf->{max} = $extend->{max_sub} if (defined($extend->{max_sub}));
              $self->apply_perfdata_thresholds(
                  perf => \$new_perf,
                  warning => $extend->{warn_sub},
                  critical => $extend->{crit_sub},
                  max => $new_perf->{max}
              );
  
              if ($extend->{type} == 1) {
                  $self->{perfdatas}->[$i] = $new_perf;
              } else {
                  push @$new_pfdata, $new_perf if (length($new_perf->{value}));
              }
          }
  
          push @{$self->{perfdatas}}, @$new_pfdata;
      }
  }
  
  sub change_perfdata {
      my ($self, %options) = @_;
  
      $self->apply_perfdata_extend();
      $self->apply_perfdata_explode();
  }
  
  1;
  
  
  =head1 NAME
  
  Output class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 OUTPUT OPTIONS
  
  =over 8
  
  =item B<--verbose>
  
  Display extended status information (long output).
  
  =item B<--debug>
  
  Display debug messages.
  
  =item B<--filter-perfdata>
  
  Filter perfdata that match the regexp.
  Example: adding --filter-perfdata='avg' will remove all metrics that do not contain
  'avg' from performance data.
  
  =item B<--filter-perfdata-adv>
  
  Filter perfdata based on a "if" condition using the following variables:
  label, value, unit, warning, critical, min, max.
  Variables must be written either %{variable} or %(variable).
  Example: adding --filter-perfdata-adv='not (%(value) == 0 and %(max) eq "")' will
  remove all metrics whose value equals 0 and that don't have a maximum value.
  
  =item B<--explode-perfdata-max>
  
  Create a new metric for each metric that comes with a maximum limit. The new
  metric will be named identically with a '_max' suffix.
  Example: it will split 'used_prct'=26.93%;0:80;0:90;0;100
  into 'used_prct'=26.93%;0:80;0:90;0;100 'used_prct_max'=100%;;;;
  
  =item B<--change-perfdata> B<--extend-perfdata>
  
  Change or extend perfdata.
  Syntax: --extend-perfdata=searchlabel,newlabel,target[,[<new-unit-of-mesure>],[min],[max]]
  
  Common examples:
  
  =over 4
  
  Convert storage free perfdata into used: --change-perfdata='free,used,invert()'
  
  Convert storage free perfdata into used: --change-perfdata='used,free,invert()'
  
  Scale traffic values automatically: --change-perfdata='traffic,,scale(auto)'
  
  Scale traffic values in Mbps: --change-perfdata='traffic_in,,scale(Mbps),mbps'
  
  Change traffic values in percent: --change-perfdata='traffic_in,,percent()'
  
  =back
  
  =item B<--extend-perfdata-group>
  
  Add new aggregated metrics (min, max, average or sum) for groups of metrics defined by a regex match on the metrics' names.
  Syntax: --extend-perfdata-group=regex,<names-of-new-metrics>,calculation[,[<new-unit-of-mesure>],[min],[max]]
  regex: regular expression
  <names-of-new-metrics>: how the new metrics' names are composed (can use $1, $2... for groups defined by () in regex).
  calculation: how the values of the new metrics should be calculated
  <new-unit-of-mesure> (optional): unit of measure for the new metrics
  min (optional): lowest value the metrics can reach
  max (optional): highest value the metrics can reach
  
  Common examples:
  
  =over 4
  
  Sum wrong packets from all interfaces (with interface need  --units-errors=absolute): --extend-perfdata-group=',packets_wrong,sum(packets_(discard|error)_(in|out))'
  
  Sum traffic by interface: --extend-perfdata-group='traffic_in_(.*),traffic_$1,sum(traffic_(in|out)_$1)'
  
  =back
  
  =item B<--change-short-output> B<--change-long-output>
  
  Modify the short/long output that is returned by the plugin.
  Syntax: --change-short-output=pattern~replacement~modifier
  Most commonly used modifiers are i (case insensitive) and g (replace all occurrences).
  Example: adding --change-short-output='OK~Up~gi' will replace all occurrences of 'OK', 'ok', 'Ok' or 'oK' with 'Up'
  
  =item B<--change-exit>
  
  Replace an exit code with one of your choice.
  Example: adding --change-exit=unknown=critical will result in a CRITICAL state
  instead of an UNKNOWN state.
  
  =item B<--change-output-adv>
  
  Replace short output and exit code based on a "if" condition using the following variables:
  short_output, exit_code.
  Variables must be written either %{variable} or %(variable).
  Example: adding --change-output-adv='%(short_ouput) =~ /UNKNOWN: No daemon/,OK: No daemon,OK' will 
  change the following specific UNKNOWN result to an OK result.
  
  =item B<--range-perfdata>
  
  Rewrite the ranges displayed in the perfdata. Accepted values:
  0: nothing is changed.
  1: if the lower value of the range is equal to 0, it is removed.
  2: remove the thresholds from the perfdata.
  
  =item B<--filter-uom>
  
  Mask the units when they don't match the given regular expression.
  
  =item B<--opt-exit>
  
  Replace the exit code in case of an execution error (i.e. wrong option provided,
  SSH connection refused, timeout, etc). Default: unknown.
  
  =item B<--output-ignore-perfdata>
  
  Remove all the metrics from the service. The service will still have a status
  and an output.
  
  =item B<--output-ignore-label>
  
  Remove the status label ("OK:", "WARNING:", "UNKNOWN:", CRITICAL:") from the
  beginning of the output.
  Example: 'OK: Ram Total:...' will become 'Ram Total:...'
  
  =item B<--output-xml>
  
  Return the output in XML format (to send to an XML API).
  
  =item B<--output-json>
  
  Return the output in JSON format (to send to a JSON API).
  
  =item B<--output-openmetrics>
  
  Return the output in OpenMetrics format (to send to a tool expecting this
  format).
  
  =item B<--output-file>
  
  Write output in file (can be combined with JSON, XML and OpenMetrics options).
  Example: --output-file=/tmp/output.txt will write the output in /tmp/output.txt.
  
  =item B<--disco-format>
  
  Applies only to modes beginning with 'list-'.
  Returns the list of available macros to configure a service discovery rule
  (formatted in XML).
  
  =item B<--disco-show>
  
  Applies only to modes beginning with 'list-'.
  Returns the list of discovered objects (formatted in XML) for service discovery.
  
  =item B<--float-precision>
  
  Define the float precision for thresholds (default: 8).
  
  =item B<--source-encoding>
  
  Define the character encoding of the response sent by the monitored resource
  Default: 'UTF-8'.
  
  =head1 DESCRIPTION
  
  B<output>.
  
  =cut
CENTREON_PLUGINS_OUTPUT

$fatpacked{"centreon/plugins/passwordmgr/centreonvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_CENTREONVAULT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::centreonvault;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::http;
  use JSON::XS;
  use MIME::Base64;
  use Crypt::OpenSSL::AES;
  use centreon::plugins::statefile;
  
  my $VAULT_PATH_REGEX = qr/^secret::hashicorp_vault::([^:]+)::(.+)$/;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr needs an 'output' argument that must be of type centreon::plugins::output.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          print "Class PasswordMgr needs an 'options' argument that must be of type centreon::plugins::options.\n";
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'vault-config:s'    => { name => 'vault_config',    default => '/etc/centreon-engine/centreonvault.json'},
          'vault-cache:s'     => { name => 'vault_cache',     default => '/var/lib/centreon/centplugins/centreonvault_session'},
          'vault-env-file:s'  => { name => 'vault_env_file',  default => '/usr/share/centreon/.env'},
      });
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'VAULT OPTIONS');
  
      $self->{output} = $options{output};
  
      # to access the vault, http protocol management is needed
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl', insecure => 1);
  
      # to store the token and its expiration date, a statefile is needed
      $self->{cache} = centreon::plugins::statefile->new();
  
      return $self;
  }
  
  sub extract_map_options {
      my ($self, %options) = @_;
  
      $self->{map_option} = [];
  
      # Parse all options to find '/# .*\:\:secret\:\:(.*)/' pattern in the options values and add entries in map_option
      foreach my $option (keys %{$options{option_results}}) {
          if (defined($options{option_results}{$option})) {
              next if ($option eq 'map_option');
              if (ref($options{option_results}{$option}) eq 'ARRAY') {
                  foreach (@{$options{option_results}{$option}}) {
                      if ($_ =~ $VAULT_PATH_REGEX) {
                          push (@{$self->{request_endpoint}}, "/v1/$1::$2");
                          push (@{$self->{map_option}}, $option."=%".$_);
                      }
                  }
              } else {
  
                  if (my ($path, $secret) = $options{option_results}{$option} =~ $VAULT_PATH_REGEX) {
                      push (@{$self->{request_endpoint}}, "/v1/" . $path . "::" . $secret);
                      push (@{$self->{map_option}}, $option."=%".$options{option_results}{$option});
                  }
              }
          }
      }
  }
  
  sub vault_settings {
      my ($self, %options) = @_;
  
      if (centreon::plugins::misc::is_empty($options{option_results}->{vault_config})) {
          $self->{output}->add_option_msg(short_msg => "Please provide a Centreon Vault configuration file path with --vault-config option");
          $self->{output}->option_exit();
      }
      if (! -f $options{option_results}->{vault_config}) {
          $self->{output}->add_option_msg(short_msg => "File '$options{option_results}->{vault_config}' could not be found.");
          $self->{output}->option_exit();
      }
      $self->{vault_cache}    = $options{option_results}->{vault_cache};
      $self->{vault_env_file} = $options{option_results}->{vault_env_file};
      $self->{vault_config}   = $options{option_results}->{vault_config};
  
  
      my $file_content = do {
          local $/ = undef;
          if (!open my $fh, "<", $options{option_results}->{vault_config}) {
              $self->{output}->add_option_msg(short_msg => "Could not read file $options{option_results}->{vault_config}: $!");
              $self->{output}->option_exit();
          }
          <$fh>;
      };
  
      # decode the JSON content of the file
      my $json = centreon::plugins::misc::json_decode($file_content);
      if (!defined($json)) {
          $self->{output}->add_option_msg(short_msg => "Cannot decode JSON : $file_content\n");
          $self->{output}->option_exit();
      }
  
      # set the default values
      $self->{vault}->{protocol} = 'https';
      $self->{vault}->{url} = '127.0.0.1';
      $self->{vault}->{port} = '8100';
  
      # define the list of expected attributes in the JSON file
      my @valid_json_options = (
          'protocol',
          'url',
          'port',
          'root_path',
          'token',
          'secret_id',
          'role_id'
      );
  
      # set the object fields when the json fields are not empty
      foreach my $valid_option (@valid_json_options) {
          $self->{vault}->{$valid_option} = $json->{$valid_option}
              if ( !centreon::plugins::misc::is_empty( $json->{ $valid_option } ) );
      }
  
      return 1;
  }
  
  sub get_decryption_key {
      my ($self, %options) = @_;
  
      # try getting APP_SECRET from the environment variables
      if ( !centreon::plugins::misc::is_empty($ENV{'APP_SECRET'}) ) {
          return $ENV{'APP_SECRET'};
      }
  
      # try getting APP_SECRET defined in the env file (default: /usr/share/centreon/.env) file
      my $fh;
      return undef if (!open $fh, "<", $self->{vault_env_file});
      for my $line (<$fh>) {
          if ($line =~ /^APP_SECRET=(.*)$/) {
              return $1;
          }
      }
  
      return undef;
  }
  
  sub extract_and_decrypt {
      my ($self, %options) = @_;
  
      my $input = decode_base64($options{data});
      my $key   = $options{key};
  
      # with AES-256, the IV length must 16 bytes
      my $iv_length = 16;
      # extract the IV, the hashed data, the encrypted data
      my $iv             = substr($input, 0, $iv_length);     # initialization vector
      my $hashed_data    = substr($input, $iv_length, 64);    # hmac of the original data, for integrity control
      my $encrypted_data = substr($input, $iv_length + 64);   # data to decrypt
  
      # Creating the AES decryption object
      my $cipher;
      eval {
          $cipher = Crypt::OpenSSL::AES->new(
              $key,
              {
                  'cipher'  => 'AES-256-CBC',
                  'iv'      => $iv
              }
          );
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "There was an error while creating the AES object: " . $@);
          $self->{output}->option_exit();
      }
  
      # Decrypting the data
      my $decrypted_data;
      eval {$decrypted_data = $cipher->decrypt($encrypted_data);};
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "There was an error while decrypting an AES-encrypted data: " . $@);
          $self->{output}->option_exit();
      }
  
      return $decrypted_data;
  }
  
  sub is_token_still_valid {
      my ($self) = @_;
      if (
              !defined($self->{auth})
              || centreon::plugins::misc::is_empty($self->{auth}->{token})
              || centreon::plugins::misc::is_empty($self->{auth}->{expiration_epoch})
              || $self->{auth}->{expiration_epoch} !~ /\d+/
              || $self->{auth}->{expiration_epoch} <= time()
      ) {
          $self->{output}->output_add(long_msg => "The token is missing or has expired or is invalid.", debug => 1);
          return undef;
      }
      $self->{output}->output_add(long_msg => "The cached token is still valid.", debug => 1);
      # Possible enhancement: check the token validity by calling this endpoint: /v1/auth/token/lookup-self
      # {"request_id":"XXXXX","lease_id":"","renewable":false,"lease_duration":0,"data":{"accessor":"XXXXXXX","creation_time":1732294406,"creation_ttl":2764800,"display_name":"approle","entity_id":"XXX","expire_time":"2024-12-24T16:53:26.932122122Z","explicit_max_ttl":0,"id":"hvs.secretToken","issue_time":"2024-11-22T16:53:26.932129132Z","meta":{"role_name":"myvault"},"num_uses":0,"orphan":true,"path":"auth/approle/login","policies":["default","myvault"],"renewable":true,"ttl":2764724,"type":"service"},"wrap_info":null,"warnings":null,"auth":null,"mount_type":"token"}
  
      return 1;
  }
  
  sub check_authentication {
      my ($self, %options) = @_;
  
      # prepare the cache (aka statefile)
      $self->{cache}->check_options(option_results => $options{option_results});
      my ($dir, $file, $suffix) = $options{option_results}->{vault_cache} =~ /^(.*\/)([^\/]+)(_.*)?$/;
  
      # Try reading the cache file
      if ($self->{cache}->read(
          statefile        => $file,
          statefile_suffix => defined($suffix) ? $suffix : '',
          statefile_dir    => $dir,
          statefile_format => 'json'
      )) {
          # if the cache file could be read, get the token and its expiration date
          $self->{auth} = {
              token            => $self->{cache}->get(name => 'token'),
              expiration_epoch => $self->{cache}->get(name => 'expiration_epoch')
          };
      }
  
      # if it is not valid, authenticate to get a new token
      if ( !$self->is_token_still_valid() ) {
          return $self->authenticate();
      }
  
      return 1;
  }
  
  sub authenticate {
      my ($self) = @_;
  
      # initial value: assuming the role and secret id might not be encrypted
      my $role_id   = $self->{vault}->{role_id};
      my $secret_id = $self->{vault}->{secret_id};
      if (centreon::plugins::misc::is_empty($role_id) || centreon::plugins::misc::is_empty($secret_id)) {
          $self->{output}->add_option_msg(short_msg => "Unable to authenticate to the vault: role_id or secret_id is empty.");
          $self->{output}->option_exit();
      }
      my $decryption_key = $self->get_decryption_key();
  
      # Decrypt the role_id and the secret_id if we have a decryption key
      if ( !centreon::plugins::misc::is_empty($decryption_key) ) {
          $role_id = $self->extract_and_decrypt(
              data => $role_id,
              key  => $decryption_key
          );
          $secret_id = $self->extract_and_decrypt(
              data => $secret_id,
              key  => $decryption_key
          );
      }
  
      # Authenticate to get the token
      my ($auth_result_json) = $self->{http}->request(
          hostname        => $self->{vault}->{url},
          port            => $self->{vault}->{port},
          proto           => $self->{vault}->{protocol},
          method          => 'POST',
          url_path        => "/v1/auth/approle/login",
          query_form_post => "role_id=$role_id&secret_id=$secret_id",
          header          => [
              'Content-Type: application/x-www-form-urlencoded',
              'Accept: */*',
              'X-Vault-Request: true',
              'User-Agent: Centreon-Plugins'
          ]
      );
  
      # Convert the response into a JSON object
      my $auth_result_obj = centreon::plugins::misc::json_decode($auth_result_json);
      if (!defined($auth_result_obj)) {
          # exit with UNKNOWN status
          $self->{output}->add_option_msg(short_msg => "Cannot decode JSON response from the vault server: $auth_result_json.");
          $self->{output}->option_exit();
      }
      # Authentication to the vault has passed
      # store the token (.auth.client_token) and its expiration date (current date + .lease_duration)
      my $expiration_epoch = -1;
      my $lease_duration = $auth_result_obj->{auth}->{lease_duration};
      if ( defined($lease_duration)
              && $lease_duration =~ /\d+/
              && $lease_duration > 0 ) {
          $expiration_epoch = time() + $lease_duration;
      }
      $self->{auth} = {
          'token'            => $auth_result_obj->{auth}->{client_token},
          'expiration_epoch' => $expiration_epoch
      };
      $self->{cache}->write(data => $self->{auth}, name => 'auth');
  
      $self->{output}->output_add(long_msg => "Authenticating worked. Token valid until "
              . localtime($self->{auth}->{expiration_epoch}), debug => 1);
  
      return 1;
  }
  
  
  
  sub request_api {
      my ($self, %options) = @_;
  
      $self->vault_settings(%options);
  
      # check the authentication
      if (!$self->check_authentication(%options)) {
          $self->{output}->add_option_msg(short_msg => "Unable to authenticate to the vault.");
          $self->{output}->option_exit();
      }
  
      $self->{lookup_values} = {};
  
      foreach my $item (@{$self->{request_endpoint}}) {
          # Extract vault name configuration from endpoint
          # 'vault::/v1/<root_path>/monitoring/hosts/7ad55afc-fa9e-4851-85b7-e26f47e421d7'
          my ($endpoint, $secret) = $item =~ /^(.*)\:\:(.*)$/;
  
  
          my ($response) = $self->{http}->request(
              hostname => $self->{vault}->{url},
              port => $self->{vault}->{port},
              proto => $self->{vault}->{protocol},
              method => 'GET',
              url_path => $endpoint,
              header => [
                  'Accept: application/json',
                  'User-Agent: Centreon-Plugins',
                  'X-Vault-Request: true',
                  'X-Vault-Token: ' . $self->{auth}->{token}
              ]
          );
  
          my $json = centreon::plugins::misc::json_decode($response);
          if (!defined($json->{data})) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode Vault JSON response: $response");
              $self->{output}->option_exit();
          };
  
          foreach my $secret_name (keys %{$json->{data}->{data}}) {
              # e.g. secret::hashicorp_vault::myspace/data/snmp::PubCommunity
              $self->{lookup_values}->{'secret::hashicorp_vault::' .  substr($endpoint, index($endpoint, '/', 1) + 1) . '::' . $secret_name} = $json->{data}->{data}->{$secret_name};
          }
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
  
      foreach my $mapping (@{$self->{map_option}}) {
          my ($opt_name, $opt_value) = $mapping =~ /^(.+?)=%(.+)$/ or next;
          $opt_name =~ s/-/_/g;
          $options{option_results}->{$opt_name} = defined($self->{lookup_values}->{$opt_value}) ? $self->{lookup_values}->{$opt_value} : $opt_value;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      $self->extract_map_options(%options);
  
      return if (scalar(@{$self->{map_option}}) <= 0);
  
      $self->request_api(%options);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Centreon Vault password manager
  
  =head1 SYNOPSIS
  
  Centreon Vault password manager
  
  To be used with an array containing keys/values saved in a secret path by resource
  
  =head1 VAULT OPTIONS
  
  =over 8
  
  =item B<--vault-config>
  
  Path to the file defining access to the Centreon vault (default: C</etc/centreon-engine/centreonvault.json>).
  
  =item B<--vault-cache>
  
  Path to the file where the token to access the Centreon vault will be stored (default: C</var/lib/centreon/centplugins/centreonvault_session>).
  
  =item B<--vault-env-file>
  
  Path to the file containing the APP_SECRET variable (default: C</usr/share/centreon/.env>).
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreonvault>.
  
  =cut
  
  =head1 NAME
  
  centreon::plugins::passwordmgr::centreonvault - Module for getting secrets from Centreon Vault.
  
  =head1 SYNOPSIS
  
    use centreon::plugins::passwordmgr::centreonvault;
  
    my $vault = centreon::plugins::passwordmgr::centreonvault->new(output => $output, options => $options);
    $vault->manage_options(option_results => \%option_results);
  
  =head1 DESCRIPTION
  
  This module provides methods to retrieve secrets (passwords, SNMP communities, ...) from Centreon Vault (adequately
  configured HashiCorp Vault).
  It extracts and decrypt the information required to login to the vault from the vault configuration file, authenticates
  to the vault, retrieves secrets, and maps them to the corresponding options for the centreon-plugins to work with.
  
  =head1 METHODS
  
  =head2 new
  
    my $vault = centreon::plugins::passwordmgr::centreonvault->new(%options);
  
  Creates a new `centreon::plugins::passwordmgr::centreonvault` object. The `%options` hash can include:
  
  =over 4
  
  =item * output
  
  The output object for displaying debug and error messages.
  
  =item * options
  
  The options object for handling command-line options.
  
  =back
  
  =head2 extract_map_options
  
    $vault->extract_map_options(option_results => \%option_results);
  
  Extracts and maps options that match the Vault path regex pattern (C</^secret::hashicorp_vault::([^:]+)::(.+)$/>). The
  `%option_results` hash should include the command-line options.
  
  =head2 vault_settings
  
    $vault->vault_settings(option_results => \%option_results);
  
  Loads and validates the Vault configuration from the specified file.
  The `%option_results` hash should include the command-line options.
  
  =head2 get_decryption_key
  
    my $key = $vault->get_decryption_key();
  
  Retrieves the decryption key from C<APP_SECRET> environment variable. It will look for it in the the specified
  environment file if it is not available in the environment variables.
  
  =head2 extract_and_decrypt
  
    my $decrypted_data = $vault->extract_and_decrypt(data => $data, key => $key);
  
  Decrypts the given data using the specified key. The options must include:
  
  =over 4
  
  =item * data
  
  The base64-encoded data to decrypt.
  
  =item * key
  
  The base64-encoded decryption key.
  
  =back
  
  =head2 is_token_still_valid
  
    my $is_valid = $vault->is_token_still_valid();
  
  Checks if there is a token in the cache and if it is still valid based on its expiration date. Returns 1 if valid, otherwise undef.
  
  =head2 check_authentication
  
    $vault->check_authentication(option_results => \%option_results);
  
  Checks the authentication status and retrieves a new token if necessary. The `%option_results` hash should include the command-line options.
  
  =head2 authenticate
  
    $vault->authenticate();
  
  Authenticates to the Vault, retrieves a new token and stores it in the dedicated cache file.
  
  =head2 request_api
  
    $vault->request_api(option_results => \%option_results);
  
  Sends requests to the Vault API to retrieve secrets. The `%option_results` hash should include the command-line options.
  
  =head2 do_map
  
    $vault->do_map(option_results => \%option_results);
  
  Maps the retrieved secrets to the corresponding options. The `%option_results` hash should include the command-line options.
  Calling this method will update the `%option_results` hash replacing vault paths with the retrieved secrets.
  
  =head2 manage_options
  
    $vault->manage_options(option_results => \%option_results);
  
  Manages the options by extracting, requesting, and mapping secrets. The `%option_results` hash should include the command-line options.
  
  NB: This is the main method to be called from outside the module. All other methods are intended to be used internally.
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_CENTREONVAULT

$fatpacked{"centreon/plugins/passwordmgr/environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_ENVIRONMENT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::environment;
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'environment-map-option:s@' => { name => 'environment_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'ENVIRONMENT OPTIONS');
  
      $self->{output} = $options{output};    
  
      return $self;
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      return if (!defined($options{option_results}->{environment_map_option}));
  
      foreach (@{$options{option_results}->{environment_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = defined($ENV{$map}) ? $ENV{$map} : '';
      }
  }
  
  1;
  
  
  =head1 NAME
  
  Environment global
  
  =head1 SYNOPSIS
  
  environment class
  
  =head1 ENVIRONMENT OPTIONS
  
  =over 8
  
  =item B<--environment-map-option>
  
  Overload plugin option.
  Example:
  --environment-map-option="snmp-community=SNMPCOMMUNITY"
  
  =back
  
  =head1 DESCRIPTION
  
  B<environment>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_ENVIRONMENT

$fatpacked{"centreon/plugins/passwordmgr/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_FILE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::file;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use JSON::Path;
  use JSON::XS;
  use Data::Dumper;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'secret-file:s'          => { name => 'secret_file' },
          'secret-search-value:s@' => { name => 'secret_search_value' },
          'secret-map-option:s@'   => { name => 'secret_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'SECRET FILE OPTIONS');
  
      $self->{output} = $options{output};    
      $JSON::Path::Safe = 0;
  
      return $self;
  }
  
  sub load {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}->{secret_file}) && $options{option_results}->{secret_file} ne '') {
          if (! -f $options{option_results}->{secret_file} or ! -r $options{option_results}->{secret_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read secret file '$options{option_results}->{secret_file}': $!");
              $self->{output}->option_exit();
          }
  
          my $content = centreon::plugins::misc::slurp_file(output => $self->{output}, file => $options{option_results}->{secret_file});
  
          my $decoded;
          eval {
              $decoded = JSON::XS->new->utf8->decode($content);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode secret file");
              $self->{output}->option_exit();
          }
  
          return $decoded;
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{secret_search_value}));
      
      foreach (@{$options{option_results}->{secret_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
  
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{secret_map_option}));
      foreach (@{$options{option_results}->{secret_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      my $secrets = $self->load(%options);
      return if (!defined($secrets));
  
      $self->do_lookup(%options, json => $secrets);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Secret file global
  
  =head1 SYNOPSIS
  
  secret file class
  
  =head1 SECRET FILE OPTIONS
  
  =over 8
  
  =item B<--secret-file>
  
  Secret file.
  
  =item B<--secret-search-value>
  
  Looking for a value in the JSON. Can use JSON Path and other option values.
  Example: 
  --secret-search-value='password=$..entries.[?($_->{title} =~ /server/i)].password'
  --secret-search-value='username=$..entries.[?($_->{title} =~ /server/i)].username'
  --secret-search-value='password=$..entries.[?($_->{title} =~ /%{hostname}/i)].password'
  
  =item B<--secret-map-option>
  
  Overload plugin option.
  Example:
  --secret-map-option="password=%{password}"
  --secret-map-option="username=%{username}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<secret file>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_FILE

$fatpacked{"centreon/plugins/passwordmgr/hashicorpvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_HASHICORPVAULT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::hashicorpvault;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::http;
  use Digest::MD5 qw(md5_hex);
  use JSON::XS;
  
  use vars qw($vault_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'auth-method:s'    => { name => 'auth_method', default => 'token' },
          'auth-path:s'      => { name => 'auth_path' },
          'auth-settings:s%' => { name => 'auth_settings' },
          'map-option:s@'    => { name => 'map_option' },
          'secret-path:s@'   => { name => 'secret_path' },
          'vault-address:s'  => { name => 'vault_address'},
          'vault-port:s'     => { name => 'vault_port', default => '8200' },
          'vault-protocol:s' => { name => 'vault_protocol', default => 'http'},
          'vault-token:s'    => { name => 'vault_token'}
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'VAULT OPTIONS');
  
      $self->{output} = $options{output};
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl');
      return $self;
  }
  
  sub get_access_token {
      my ($self, %options) = @_;
  
      my $decoded;
      my $login = $self->parse_auth_method(method => $self->{auth_method}, settings => $self->{auth_settings});
      my $post_json = JSON::XS->new->utf8->encode($login);
      if (!defined($self->{auth_path}) || $self->{auth_path} eq '') {
          $self->{auth_path} = $self->{auth_method};
      }
      my $url_path = '/v1/auth/'. $self->{auth_path} . '/login/';
      $url_path .= $self->{auth_settings}->{username} if (defined($self->{auth_settings}->{username}) && $self->{auth_method} =~ 'userpass|login') ;
  
      my $content = $self->{http}->request(
          hostname => $self->{vault_address},
          port => $self->{vault_port},
          proto => $self->{vault_protocol},
          method => 'POST',
          header => ['Content-type: application/json'],
          query_form_post => $post_json,
          url_path => $url_path
      );
  
      if (!defined($content) || $content eq '') {
          $self->{output}->add_option_msg(short_msg => "Authentication endpoint returns empty content [code: '" . $self->{http}->get_code() . "'] [message: '" . $self->{http}->get_message() . "']");
          $self->{output}->option_exit();
      }
  
      eval {
          $decoded = JSON::XS->new->utf8->decode($content);
      };
      if ($@) {
          $self->{output}->output_add(long_msg => $content, debug => 1);
          $self->{output}->add_option_msg(short_msg => "Cannot decode response (add --debug option to display returned content)");
          $self->{output}->option_exit();
      }
      if (defined($decoded->{errors}[0])) {
          $self->{output}->output_add(long_msg => "Error message : " . $decoded->{errors}[0], debug => 1);
          $self->{output}->add_option_msg(short_msg => "Authentication endpoint returns error code '" . $decoded->{errors}[0] . "' (add --debug option for detailed message)");
          $self->{output}->option_exit();
      }
  
      my $access_token = $decoded->{auth}->{client_token};
      return $access_token;
  }
  
  sub parse_auth_method {
      my ($self, %options) = @_;
  
      my $login_settings;
      my $settings_mapping = {
          azure    => [ 'role', 'jwt' ],
          cert     => [ 'name' ],
          github   => [ 'token' ],
          ldap     => [ 'username', 'password' ],
          okta     => [ 'username', 'password', 'totp' ],
          radius   => [ 'username', 'password' ],
          userpass => [ 'username', 'password' ]
      };
  
      foreach (@{$settings_mapping->{$options{method}}}) {
          if (!defined($options{settings}->{$_})) {
              $self->{output}->add_option_msg(short_msg => 'Missing authentication setting: ' . $_);
              $self->{output}->option_exit();
          }
          $login_settings->{$_} = $options{settings}->{$_};
      };
  
      return $login_settings;
  }
  
  sub settings {
      my ($self, %options) = @_;
  
      if (!defined($options{option_results}->{vault_address}) || $options{option_results}->{vault_address} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set the --vault-address option");
          $self->{output}->option_exit();
      }
  
      if ($options{option_results}->{auth_method} eq 'token' && (!defined($options{option_results}->{vault_token}) || $options{option_results}->{vault_token} eq '')) {
          $self->{output}->add_option_msg(short_msg => "Please set the --vault-token option");
          $self->{output}->option_exit();
      }
  
      if (!defined($options{option_results}->{secret_path}) || $options{option_results}->{secret_path} eq '') {
          $self->{output}->add_option_msg(short_msg => "Please set the --secret-path option");
          $self->{output}->option_exit();
      }
  
      if (defined($options{option_results}->{auth_path})) {		
          $self->{auth_path} = lc($options{option_results}->{auth_path});
      }
  
      $self->{auth_method} = lc($options{option_results}->{auth_method});
      $self->{auth_settings} = defined($options{option_results}->{auth_settings}) && $options{option_results}->{auth_settings} ne '' ? $options{option_results}->{auth_settings} : {};
      $self->{vault_address} = $options{option_results}->{vault_address};
      $self->{vault_port} = $options{option_results}->{vault_port};
      $self->{vault_protocol} = $options{option_results}->{vault_protocol};
      $self->{vault_token} = $options{option_results}->{vault_token};
  
      if (lc($self->{auth_method}) !~ m/azure|cert|github|ldap|okta|radius|userpass|token/ ) {
          $self->{output}->add_option_msg(short_msg => "Incorrect or unsupported authentication method set in --auth-method");
          $self->{output}->option_exit();
      }
      foreach (@{$options{option_results}->{secret_path}}) {
          $self->{request_endpoint}->{$_} = '/v1/' . $_;
      }
  
      if (defined($options{option_results}->{auth_method}) && $options{option_results}->{auth_method} ne 'token') {
          $self->{vault_token} = $self->get_access_token(%options);
      };
  
      $self->{http}->add_header(key => 'Accept', value => 'application/json');
      if (defined($self->{vault_token})) {
          $self->{http}->add_header(key => 'X-Vault-Token', value => $self->{vault_token});
      }
  }
  
  sub request_api {
      my ($self, %options) = @_;
  
      $self->settings(%options);
      my ($raw_data, $raw_response);
      foreach my $endpoint (keys %{$self->{request_endpoint}}) {
          my $json;
          my $response = $self->{http}->request(
              hostname => $self->{vault_address},
              port => $self->{vault_port},
              proto => $self->{vault_protocol},
              method => 'GET',
              url_path => $self->{request_endpoint}->{$endpoint}
          );
          $self->{output}->output_add(long_msg => $response, debug => 1);
  
          eval {
              $json = JSON::XS->new->utf8->decode($response);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode Vault JSON response: $@");
              $self->{output}->option_exit();
          }
  
          if ((defined($json->{data}->{metadata}->{deletion_time}) && $json->{data}->{metadata}->{deletion_time} ne '') || $json->{data}->{metadata}->{destroyed} eq 'true') {
              $self->{output}->add_option_msg(short_msg => "This secret is not valid anymore");
              $self->{output}->option_exit();
          }
  
          foreach (keys %{$json->{data}->{data}}) {
              $self->{lookup_values}->{'key_' . $endpoint} = $_;
              $self->{lookup_values}->{'value_' . $endpoint} = $json->{data}->{data}->{$_};
          }
          push(@{$raw_data}, $json);
          push(@{$raw_response}, $response);
      }
  
      return ($raw_data, $raw_response);
  }
  
  sub do_map {
      my ($self, %options) = @_;
  
      return if (!defined($options{option_results}->{map_option}));
      foreach (@{$options{option_results}->{map_option}}) {
          next if (! /^(.+?)=(.+)$/);
  
          my ($option, $map) = ($1, $2);
  
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g;
          }
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
  
      my ($content, $debug) = $self->request_api(%options);
      if (!defined($content)) {
          $self->{output}->add_option_msg(short_msg => "Cannot read Vault information");
          $self->{output}->option_exit();
      }
      $self->do_map(%options);
      $self->{output}->output_add(long_msg => Data::Dumper::Dumper($debug), debug => 1) if ($self->{output}->is_debug());
  }
  
  1;
  
  
  =head1 NAME
  
  HashiCorp Vault global
  
  =head1 SYNOPSIS
  
  HashiCorp Vault class
  To be used with K/V engines
  
  =head1 VAULT OPTIONS
  
  =over 8
  
  =item B<--vault-address>
  
  IP address of the HashiCorp Vault server (mandatory).
  
  =item B<--vault-port>
  
  Port of the HashiCorp Vault server (default: '8200').
  
  =item B<--vault-protocol>
  
  HTTP of the HashiCorp Vault server.
  Can be: 'http', 'https' (default: http).
  
  =item B<--auth-method>
  
  Authentication method to log in against the Vault server.
  Can be: 'azure', 'cert', 'github', 'ldap', 'okta', 'radius', 'userpass' (default: 'token');
  
  =item B<--auth-path>
  
  Authentication path for 'userpass'. Is an optional setting.
  
  More information here: https://developer.hashicorp.com/vault/docs/auth/userpass#configuration
  
  =item B<--vault-token>
  
  Directly specify a valid token to log in (only for --auth-method='token').
  
  =item B<--auth-settings>
  
  Required information to log in according to the selected method.
  Examples:
  for 'userpass': --auth-settings='username=user1' --auth-settings='password=my_password'
  for 'azure': --auth-settings='role=my_azure_role' --auth-settings='jwt=my_azure_token'
  
  More information here: https://www.vaultproject.io/api-docs/auth
  
  =item B<--secret-path>
  
  Location of the secret in the Vault K/V engine (mandatory - Can be multiple).
  Examples:
  for v1 engine: --secret-path='mysecrets/servicecredentials'
  for v2 engine: --secret-path='mysecrets/data/servicecredentials?version=12'
  
  More information here: https://www.vaultproject.io/api-docs/secret/kv
  
  =item B<--map-option>
  
  Overload Plugin option with K/V values.
  Use the following syntax:
  the_option_to_overload='%{key_$secret_path$}' or
  the_option_to_overload='%{value_$secret_path$}'
  Example:
  --map-option='username=%{key_mysecrets/servicecredentials}'
  --map-option='password=%{value_mysecrets/servicecredentials}'
  
  =back
  
  =head1 DESCRIPTION
  
  B<hashicorpvault>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_HASHICORPVAULT

$fatpacked{"centreon/plugins/passwordmgr/keepass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_KEEPASS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::keepass;
  
  use strict;
  use warnings;
  use JSON::Path;
  use Data::Dumper;
  use KeePass::Reader;
  
  use vars qw($keepass_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          'keepass-endpoint:s'        => { name => 'keepass_endpoint' },
          'keepass-endpoint-file:s'   => { name => 'keepass_endpoint_file' },
          'keepass-file:s'            => { name => 'keepass_file' },
          'keepass-password:s'        => { name => 'keepass_password' },
          'keepass-search-value:s@'   => { name => 'keepass_search_value' },
          'keepass-map-option:s@'     => { name => 'keepass_map_option' }
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'KEEPASS OPTIONS');
  
      $self->{output} = $options{output};    
      $JSON::Path::Safe = 0;
  
      return $self;
  }
  
  sub build_api_args {
      my ($self, %options) = @_;
      
      $self->{connection_info} = { file => undef, password => undef };
      if (defined($options{option_results}->{keepass_endpoint_file}) && $options{option_results}->{keepass_endpoint_file} ne '') {
          if (! -f $options{option_results}->{keepass_endpoint_file} or ! -r $options{option_results}->{keepass_endpoint_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read keepass endpoint file: $!");
              $self->{output}->option_exit();
          }
          
          require $options{option_results}->{keepass_endpoint_file};
          if (defined($keepass_connections) && defined($options{option_results}->{keepass_endpoint}) && $options{option_results}->{keepass_endpoint} ne '') {
              if (!defined($keepass_connections->{$options{option_results}->{keepass_endpoint}})) {
                  $self->{output}->add_option_msg(short_msg => "Endpoint $options{option_results}->{keepass_endpoint} doesn't exist in keepass endpoint file");
                  $self->{output}->option_exit();
              }
              
              $self->{connection_info} = $keepass_connections->{$options{option_results}->{keepass_endpoint}};
          }
      }
      
      foreach (['keepass_file', 'file'], ['keepass_password', 'password']) {
          if (defined($options{option_results}->{$_->[0]}) && $options{option_results}->{$_->[0]} ne '') {
              $self->{connection_info}->{$_->[1]} = $options{option_results}->{$_->[0]};
          }
      }
      
      if (defined($self->{connection_info}->{file}) && $self->{connection_info}->{file} ne '') {
          if (!defined($self->{connection_info}->{password}) || $self->{connection_info}->{password} eq '') {
              $self->{output}->add_option_msg(short_msg => "Please set keepass-password option");
              $self->{output}->option_exit();
          }
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{keepass_search_value}));
      
      foreach (@{$options{option_results}->{keepass_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
                  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
          
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{keepass_map_option}));
      foreach (@{$options{option_results}->{keepass_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      $self->build_api_args(%options);
      return if (!defined($self->{connection_info}->{file}));
      
      my $keepass = KeePass::Reader->new();
      my $content = $keepass->load_db(file => $self->{connection_info}->{file}, password => $self->{connection_info}->{password});
      if (!defined($content)) {
          $self->{output}->add_option_msg(short_msg => "Cannot read keepass file: " . $keepass->error());
          $self->{output}->option_exit();
      }
      $self->{output}->output_add(long_msg => Data::Dumper::Dumper($content), debug => 1) if ($self->{output}->is_debug());
  
      $self->do_lookup(%options, json => $content);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Keepass global
  
  =head1 SYNOPSIS
  
  keepass class
  
  =head1 KEEPASS OPTIONS
  
  =over 8
  
  =item B<--keepass-endpoint>
  
  Connection information to be used in keepass file.
  
  =item B<--keepass-endpoint-file>
  
  File with keepass connection informations.
  
  =item B<--keepass-file>
  
  Keepass file.
  
  =item B<--keepass-password>
  
  Keepass master password.
  
  =item B<--keepass-search-value>
  
  Looking for a value in the JSON keepass. Can use JSON Path and other option values.
  Example: 
  --keepass-search-value='password=$..entries.[?($_->{title} =~ /serveurx/i)].password'
  --keepass-search-value='username=$..entries.[?($_->{title} =~ /serveurx/i)].username'
  --keepass-search-value='password=$..entries.[?($_->{title} =~ /%{hostname}/i)].password'
  
  =item B<--keepass-map-option>
  
  Overload plugin option.
  Example:
  --keepass-map-option="password=%{password}"
  --keepass-map-option="username=%{username}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<keepass>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_KEEPASS

$fatpacked{"centreon/plugins/passwordmgr/teampass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PASSWORDMGR_TEAMPASS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::passwordmgr::teampass;
  
  use strict;
  use warnings;
  use JSON::Path;
  use JSON::XS;
  use Data::Dumper;
  use centreon::plugins::http;
  
  use vars qw($teampass_connections);
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (!defined($options{output})) {
          print "Class PasswordMgr: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class PasswordMgr: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      $options{options}->add_options(arguments => {
          "teampass-endpoint:s"       => { name => 'teampass_endpoint' },
          "teampass-endpoint-file:s"  => { name => 'teampass_endpoint_file' },
          "teampass-api-key:s"        => { name => 'teampass_api_key' },
          "teampass-api-address:s"    => { name => 'teampass_api_address' },
          "teampass-api-request:s"    => { name => 'teampass_api_request' },
          "teampass-search-value:s@"  => { name => 'teampass_search_value' },
          "teampass-map-option:s@"    => { name => 'teampass_map_option' },
          "teampass-timeout:s"        => { name => 'teampass_timeout' },
      });
      $options{options}->add_help(package => __PACKAGE__, sections => 'TEAMPASS OPTIONS');
  
      $self->{output} = $options{output};    
      $self->{http} = centreon::plugins::http->new(%options, noptions => 1, default_backend => 'curl');
      $JSON::Path::Safe = 0;
      
      return $self;
  }
  
  sub build_api_args {
      my ($self, %options) = @_;
      
      $self->{connection_info} = { address => undef, key => undef, request => undef };
      if (defined($options{option_results}->{teampass_endpoint_file}) && $options{option_results}->{teampass_endpoint_file} ne '') {
          if (! -f $options{option_results}->{teampass_endpoint_file} or ! -r $options{option_results}->{teampass_endpoint_file}) {
              $self->{output}->add_option_msg(short_msg => "Cannot read teampass file: $!");
              $self->{output}->option_exit();
          }
          
          require $options{option_results}->{teampass_endpoint_file};
          if (defined($teampass_connections) && defined($options{option_results}->{teampass_endpoint}) && $options{option_results}->{teampass_endpoint} ne '') {
              if (!defined($teampass_connections->{$options{option_results}->{teampass_endpoint}})) {
                  $self->{output}->add_option_msg(short_msg => "Endpoint $options{option_results}->{teampass_endpoint} doesn't exist in teampass file");
                  $self->{output}->option_exit();
              }
              
              $self->{connection_info} = $teampass_connections->{$options{option_results}->{teampass_endpoint}};
          }
      }
      
      foreach (['teampass_api_address', 'address'], ['teampass_api_key', 'key'], ['teampass_api_request', 'request']) {
          if (defined($options{option_results}->{$_->[0]}) && $options{option_results}->{$_->[0]} ne '') {
              $self->{connection_info}->{$_->[1]} = $options{option_results}->{$_->[0]};
          }
      }
      
      if (defined($self->{connection_info}->{address}) && $self->{connection_info}->{address} ne '') {
          foreach ('key', 'request') {
              if (!defined($self->{connection_info}->{$_}) || $self->{connection_info}->{$_} eq '') {
                  $self->{output}->add_option_msg(short_msg => "Please set teampass-api-$_ option");
                  $self->{output}->option_exit();
              }
          }
      }
  }
  
  sub do_lookup {
      my ($self, %options) = @_;
      
      $self->{lookup_values} = {};
      return if (!defined($options{option_results}->{teampass_search_value}));
      
      foreach (@{$options{option_results}->{teampass_search_value}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($map, $lookup) = ($1, $2);
                  
          # Change %{xxx} options usage
          while ($lookup =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $options{option_results}->{$1} if (defined($options{option_results}->{$1}));
              $lookup =~ s/\%\{$1\}/$sub/g
          }
          
          my $jpath = JSON::Path->new($lookup);
          my $result = $jpath->value($options{json});
          $self->{output}->output_add(long_msg => 'lookup = ' . $lookup. ' - response = ' . Data::Dumper::Dumper($result), debug => 1);
          $self->{lookup_values}->{$map} = $result;
      }
  }
  
  sub do_map {
      my ($self, %options) = @_;
      
      return if (!defined($options{option_results}->{teampass_map_option}));
      foreach (@{$options{option_results}->{teampass_map_option}}) {
          next if (! /^(.+?)=(.+)$/);
          my ($option, $map) = ($1, $2);
          
          # Change %{xxx} options usage
          while ($map =~ /\%\{(.*?)\}/g) {
              my $sub = '';
              $sub = $self->{lookup_values}->{$1} if (defined($self->{lookup_values}->{$1}));
              $map =~ s/\%\{$1\}/$sub/g
          }
  
          $option =~ s/-/_/g;
          $options{option_results}->{$option} = $map;
      }
  }
  
  sub manage_options {
      my ($self, %options) = @_;
      
      $self->build_api_args(%options);
      return if (!defined($self->{connection_info}->{address}));
      
      $self->{http}->set_options(
          timeout => $options{option_results}->{teampass_timeout},
          unknown_status => '%{http_code} < 200 or %{http_code} >= 300',
      );
      my $response = $self->{http}->request(method => 'GET', 
          full_url => $self->{connection_info}->{address} . $self->{connection_info}->{request}, 
          hostname => '',
          get_param => ['apikey=' . $self->{connection_info}->{key}],
      );
      $self->{output}->output_add(long_msg => $response, debug => 1);
      
      my $json;
      eval {
          $json = JSON::XS->new->utf8->decode($response);
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "Cannot decode teampass json response: $@");
          $self->{output}->option_exit();
      }
      
      $self->do_lookup(%options, json => $json);
      $self->do_map(%options);
  }
  
  1;
  
  
  =head1 NAME
  
  Teampass global
  
  =head1 SYNOPSIS
  
  teampass class
  
  =head1 TEAMPASS OPTIONS
  
  =over 8
  
  =item B<--teampass-endpoint>
  
  Connection information to be used in teampass file.
  
  =item B<--teampass-endpoint-file>
  
  File with teampass connection informations.
  
  =item B<--teampass-timeout>
  
  Set HTTP Rest API timeout (default: 5).
  
  =item B<--teampass-api-key>
  
  Teampass API Key.
  
  =item B<--teampass-api-address>
  
  Teampass URL (example: http://10.0.0.1/teampass).
  
  =item B<--teampass-api-request>
  
  Teampass request (example: /api/index.php/folder/3).
  
  =item B<--teampass-search-value>
  
  Looking for a value in the JSON teampass response. Can use JSON Path and other option values.
  Example: 
  --teampass-search-value='password=$.[?($_->{label} =~ /serveur1/i)].pw'
  --teampass-search-value='login=$.[?($_->{label} =~ /serveur1/i)].login'
  --teampass-search-value='password=$.[?($_->{label} =~ /%{hostname}/i)].pw'
  
  =item B<--teampass-map-option>
  
  Overload plugin option.
  Example:
  --teampass-map-option="password=%{password}"
  --teampass-map-option="username=%{login}"
  
  =back
  
  =head1 DESCRIPTION
  
  B<teampass>.
  
  =cut
CENTREON_PLUGINS_PASSWORDMGR_TEAMPASS

$fatpacked{"centreon/plugins/perfdata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_PERFDATA';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::perfdata;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{output} = $options{output};
      # Typical Nagios Perfdata 'with ~ @ ..'
      $self->{threshold_label} = {};
      $self->{float_precision} = defined($self->{output}->{option_results}->{float_precision}) && $self->{output}->{option_results}->{float_precision} =~ /\d+/ ?  
          int($self->{output}->{option_results}->{float_precision}) : 8;
  
      return $self;
  }
  
  sub get_perfdata_for_output {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{total} : percent threshold to transform in global
      # $options{cast_int} : cast absolute to int
      # $options{op} : operator to apply to start/end value (uses with 'value'})
      # $options{value} : value to apply with 'op' option
      
      if (!defined($self->{threshold_label}->{$options{label}}->{value}) || $self->{threshold_label}->{$options{label}}->{value} eq '') {
          return '';
      }
      
      my %perf_value = %{$self->{threshold_label}->{$options{label}}};
      
      if (defined($options{op}) && defined($options{value})) {
          eval "\$perf_value{start} = \$perf_value{start} $options{op} \$options{value}" if ($perf_value{infinite_neg} == 0);
          eval "\$perf_value{end} = \$perf_value{end} $options{op} \$options{value}" if ($perf_value{infinite_pos} == 0);
      }
      if (defined($options{total})) {
          $perf_value{start} = $perf_value{start} * $options{total} / 100 if ($perf_value{infinite_neg} == 0);
          $perf_value{end} = $perf_value{end} * $options{total} / 100 if ($perf_value{infinite_pos} == 0);
          $perf_value{start} = sprintf("%.2f", $perf_value{start}) if ($perf_value{infinite_neg} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
          $perf_value{end} = sprintf("%.2f", $perf_value{end}) if ($perf_value{infinite_pos} == 0 && (!defined($options{cast_int}) || $options{cast_int} != 1));
      }
      
      $perf_value{start} = int($perf_value{start}) if ($perf_value{infinite_neg} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      $perf_value{end} = int($perf_value{end}) if ($perf_value{infinite_pos} == 0 && defined($options{cast_int}) && $options{cast_int} == 1);
      
      my $perf_output = ($perf_value{arobase} == 1 ? '@' : '') . 
                        (($perf_value{infinite_neg} == 0) ? $perf_value{start} : '~') . 
                        ':' . 
                        (($perf_value{infinite_pos} == 0) ? $perf_value{end} : '');
  
      return $perf_output;
  }
  
  sub threshold_validate {
      my ($self, %options) = @_;
      # $options{label} : threshold label
      # $options{value} : threshold value
  
      my $status = 1;
      $self->{threshold_label}->{$options{label}} = { value => $options{value}, start => undef, end => undef, arobase => undef, infinite_neg => undef, infinite_pos => undef };
      if (!defined($options{value}) || $options{value} eq '') {
          return $status;
      }
  
      ($status, my $result_perf) = 
          centreon::plugins::misc::parse_threshold(threshold => $options{value});
      $self->{threshold_label}->{$options{label}} = { %{$self->{threshold_label}->{$options{label}}}, %$result_perf };
      
      $self->{threshold_label}->{$options{label}}->{start_precision} = $self->{threshold_label}->{$options{label}}->{start};
      if ($self->{threshold_label}->{$options{label}}->{start} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{start_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{start});
      }
      
      $self->{threshold_label}->{$options{label}}->{end_precision} = $self->{threshold_label}->{$options{label}}->{end};
      if ($self->{threshold_label}->{$options{label}}->{end} =~ /[.,]/) {
          $self->{threshold_label}->{$options{label}}->{end_precision} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $self->{threshold_label}->{$options{label}}->{end});
      }
      
      return $status;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      # Can check multiple threshold. First match: out. Order is important
      # options{value}: value to compare
      # options{threshold}: ref to an array (example: [ {label => 'warning', exit_litteral => 'warning' }, {label => 'critical', exit_litteral => 'critical'} ]
      if ($options{value} =~ /[.,]/) {
          $options{value} = sprintf("%.$self->{output}->{option_results}->{float_precision}f", $options{value});
      }
  
      foreach (@{$options{threshold}}) {
          next if (!defined($self->{threshold_label}->{$_->{label}}));
          next if (!defined($self->{threshold_label}->{$_->{label}}->{value}) || $self->{threshold_label}->{$_->{label}}->{value} eq '');
          if ($self->{threshold_label}->{$_->{label}}->{arobase} == 0 && ($options{value} < $self->{threshold_label}->{$_->{label}}->{start_precision} || $options{value} > $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          } elsif ($self->{threshold_label}->{$_->{label}}->{arobase}  == 1 && ($options{value} >= $self->{threshold_label}->{$_->{label}}->{start_precision} && $options{value} <= $self->{threshold_label}->{$_->{label}}->{end_precision})) {
              return $_->{exit_litteral};
          }
      }
  
      return 'ok';
  }
  
  sub trim {
      my ($self, $value) = @_;
      
      $value =~ s/^[ \t]+//;
      $value =~ s/[ \t]+$//;
      return $value;
  }
  
  sub change_bytes {
      my ($self, %options) = @_;
  
      my $value = $options{value};
      my $divide = defined($options{network}) ? 1000 : 1024;
      my @units = ('K', 'M', 'G', 'T');
      my $unit = '';
      my $sign = '';
  
      $sign = '-' if ($value != abs($value));
      $value = abs($value);
      
      for (my $i = 0; $i < scalar(@units); $i++) {
          last if (($value / $divide) < 1);
          $unit = $units[$i];
          $value = $value / $divide;
      }
  
      return (sprintf('%.2f', $sign . $value), $unit . (defined($options{network}) ? 'b' : 'B'));
  }
  
  1;
  
  
  =head1 NAME
  
  Perfdata class
  
  =head1 SYNOPSIS
  
  -
  
  =head1 DESCRIPTION
  
  B<perfdata>.
  
  =cut
CENTREON_PLUGINS_PERFDATA

$fatpacked{"centreon/plugins/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script;
  
  use strict;
  use warnings;
  use centreon::plugins::output;
  use centreon::plugins::misc;
  use Pod::Usage;
  
  my %handlers = (DIE => {}, ALRM => {});
  
  my $global_version = '20251000 (1b86ebfb1)';
  my $alternative_fatpacker = 1;
  
  sub new {
      my ($class) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{options} = undef;
      $self->{plugin} = undef;
      $self->{help} = undef;
  
      # Avoid to destroy because it keeps a ref on the object. 
      # A problem if we execute it multiple times in the same perl execution
      # Use prepare_destroy
      $self->set_signal_handlers();
      return $self;
  }
  
  sub prepare_destroy {
      my ($self) = @_;
  
      %handlers = ();
  }
  
  sub set_signal_handlers {
      my ($self) = @_;
  
      $SIG{__DIE__} = \&class_handle_DIE;
      $handlers{DIE}->{$self} = sub { $self->handle_DIE($_[0]) };
  }
  
  sub class_handle_DIE {
      my ($msg) = @_;
  
      foreach (keys %{$handlers{DIE}}) {
          &{$handlers{DIE}->{$_}}($msg);
      }
  }
  
  sub class_handle_ALRM {
      foreach (keys %{$handlers{ALRM}}) {
          &{$handlers{ALRM}->{$_}}();
      }
  }
  
  sub handle_DIE {
      my ($self, $msg) = @_;
  
      return unless defined $^S and $^S == 0; # Ignore errors in eval
      $self->{output}->add_option_msg(short_msg => $msg);
      $self->{output}->die_exit();
  }
  
  sub handle_ALRM {
      my ($self) = @_;
  
      $self->{output}->add_option_msg(short_msg => 'script global timeout');
      $self->{output}->option_exit();
  }
  
  sub get_global_version {
      return $global_version;
  }
  
  sub get_plugin {
      my ($self) = @_;
  
      # Need to load global 'Output' and 'Options'
      if ($alternative_fatpacker == 0) {
          require centreon::plugins::options;
          $self->{options} = centreon::plugins::options->new();
      } else {
          require centreon::plugins::alternative::FatPackerOptions;
          $self->{options} = centreon::plugins::alternative::FatPackerOptions->new();
      }
      $self->{output} = centreon::plugins::output->new(options => $self->{options});
      $self->{options}->set_output(output => $self->{output});
  
      $self->{options}->add_options(arguments => {
          'plugin:s'          => { name => 'plugin' },
          'list-plugin'       => { name => 'list_plugin' }, 
          'help'              => { name => 'help' },
          'ignore-warn-msg'   => { name => 'ignore_warn_msg' },
          'version'           => { name => 'version' },
          'runas:s'           => { name => 'runas' },
          'global-timeout:s'  => { name => 'global_timeout' },
          'environment:s%'    => { name => 'environment' },
          'convert-args:s'    => { name => 'convert_args' },
      });
  
      $self->{options}->parse_options();
  
      $self->{plugin} = $self->{options}->get_option(argument => 'plugin');
      $self->{list_plugin} = $self->{options}->get_option(argument => 'list_plugin');
      $self->{help} = $self->{options}->get_option(argument => 'help');
      $self->{version} = $self->{options}->get_option(argument => 'version');
      $self->{runas} = $self->{options}->get_option(argument => 'runas');
      $self->{environment} = $self->{options}->get_option(argument => 'environment');
      $self->{ignore_warn_msg} = $self->{options}->get_option(argument => 'ignore_warn_msg');
      $self->{convert_args} = $self->{options}->get_option(argument => 'convert_args');
  
      my $global_timeout = $self->{options}->get_option(argument => 'global_timeout');
      if (defined($global_timeout) && $global_timeout =~ /(\d+)/) {
          $SIG{ALRM} = \&class_handle_ALRM;
          $handlers{ALRM}->{$self} = sub { $self->handle_ALRM() };
          alarm($1);
      }
  
      $self->{output}->plugin(name => $self->{plugin});
      $self->{output}->check_options(option_results => $self->{options}->get_options());
  
      $self->{options}->clean();
  }
  
  sub convert_args {
      my ($self) = @_;
  
      if ($self->{convert_args} =~ /^(.+?),(.*)/) {
          my ($search, $replace) = ($1, $2);
          for (my $i = 0; $i <= $#ARGV; $i++) {
              eval "\$ARGV[\$i] =~ s/$search/$replace/g";
          }
      }
  }
  
  sub display_local_help {
      my ($self) = @_;
  
      my $stdout;
      if ($self->{help}) {
          local *STDOUT;
          open STDOUT, '>', \$stdout;
  
          if ($alternative_fatpacker == 0) {
              pod2usage(-exitval => 'NOEXIT', -input => $self->{options}->pod_where(package => __PACKAGE__));
          } else {
              my $pp = __PACKAGE__ . '.pm';
              $pp =~ s{::}{/}g;
              my $content_class = $INC{$pp}->{$pp};
              open my $str_fh, '<', \$content_class;
              pod2usage(-exitval => 'NOEXIT', -input => $str_fh);
              close $str_fh;
          }
      }
  
      $self->{output}->add_option_msg(long_msg => $stdout) if (defined($stdout));
  }
  
  sub check_directory {
      my ($self, $directory) = @_;
  
      opendir(my $dh, $directory) || return ;
      while (my $filename = readdir $dh) {
          $self->check_directory($directory . '/' . $filename) if ($filename !~ /^\./ && -d $directory . '/' . $filename);
          if ($filename eq 'plugin.pm') {
              my $stdout = '';
  
              {
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  pod2usage(
                      -exitval => 'NOEXIT',
                      -input => $directory . "/" . $filename,
                      -verbose => 99, 
                      -sections => 'PLUGIN DESCRIPTION'
                  );
              }
              $self->{plugins_result}->{$directory . '/' . $filename} = $stdout;
          }
      }
      closedir $dh;
  }
  
  sub fatpacker_find_plugin {
      my ($self) = @_;
      
      my $plugins = [];
      foreach (@INC) {
          next if (ref($_) !~ /FatPacked/);
          foreach my $name (keys %$_) {
              if ($name =~ /plugin.pm$/) {
                  push @$plugins, $name;
              }
          }
      }
  
      return $plugins;
  }
  
  sub check_plugin_option {
      my ($self) = @_;
  
      if (defined($self->{version})) {
          $self->{output}->add_option_msg(short_msg => 'Global Version: ' . $global_version);
          $self->{output}->option_exit(nolabel => 1);
      }
  
      my $no_plugin = 1;
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
          if (scalar(@$integrated_plugins) == 1) {
              $self->{plugin} = $integrated_plugins->[0];
              $no_plugin = 0;
          }
      }
  
      if ($no_plugin == 1) {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--plugin' option.");
          $self->{output}->option_exit();
      }
  }
  
  sub display_list_plugin {
      my ($self) = @_;
      $self->{plugins_result} = {};
  
      if ($alternative_fatpacker == 1) {
          my $integrated_plugins = $self->fatpacker_find_plugin();
  
          foreach my $key (sort @$integrated_plugins) {
              # Need to load it to get the description
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output}, module => $key, 
                  error_msg => 'Cannot load module --plugin.'
              );
  
              my $name = $key;
              $name =~ s/\.pm//g;
              $name =~ s/\//::/g;
              $self->{output}->add_option_msg(long_msg => '-----------------');
              $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
              {
                  my $stdout = '';
                  local *STDOUT;
                  open STDOUT, '>', \$stdout;
                  my $content_class = $INC{$key}->{$key};
                  open my $str_fh, '<', \$content_class;
                  pod2usage(-exitval => 'NOEXIT', -input => $str_fh, -verbose => 99, -sections => 'PLUGIN DESCRIPTION');
                  close $str_fh;
                  $self->{output}->add_option_msg(long_msg => $stdout);
              }
          }
          return ;
      }
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'FindBin', 
          error_msg => "Cannot load module 'FindBin'."
      );
      my $directory = $FindBin::Bin;
      if (defined($ENV{PAR_TEMP})) {
          $directory = $ENV{PAR_TEMP} . '/inc/lib';
      }
      # Search file 'plugin.pm'
      $self->check_directory($directory);
      foreach my $key (sort keys %{$self->{plugins_result}}) {
          my $name = $key;
          $name =~ s/^\Q$directory\E\/(.*)\.pm/$1/;
          $name =~ s/\//::/g;
          $self->{plugins_result}->{$key} =~ s/^Plugin Description/DESCRIPTION/i;
  
          $self->{output}->add_option_msg(long_msg => '-----------------');
          $self->{output}->add_option_msg(long_msg => 'PLUGIN: ' . $name);
          $self->{output}->add_option_msg(long_msg => $self->{plugins_result}->{$key});
      }
  }
  
  sub check_relaunch_get_args {
      my ($self) = @_;
  
      my $args = ['--plugin=' . $self->{plugin}, @ARGV];
      push @$args, '--ignore-warn-msg' if (defined($self->{ignore_warn_msg}));
      push @$args, '--help' if (defined($self->{help}));
      push @$args, '--global-timeout', $self->{global_timeout} if (defined($self->{global_timeout}));
      foreach ((
          ['output_xml', 0], ['output_json', 0], ['output_openmetrics', 0], 
          ['disco_format', 0], ['disco_show', 0], ['use_new_perfdata', 0], ['debug', 0], ['verbose', 0],
          ['range_perfdata', 1], ['filter_uom', 1], ['opt_exit', 1], ['filter_perfdata', 1],
          ['output_file', 1], ['float_precision', 1]
      )) {
          my $option = $self->{output}->get_option(option => $_->[0]);
          if (defined($option)) {
              my $option_label = $_->[0];
              $option_label =~ s/_/-/g;
              push @$args, "--$option_label" if ($_->[1] == 0);
              push @$args, "--$option_label", $option if ($_->[1] == 1);
          }
      }
  
      return $args;
  }
  
  sub check_relaunch {
      my $self = shift;
  
      centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => 'FindBin', 
          error_msg => "Cannot load module 'FindBin'."
      );
  
      my $need_restart = 0;
      my $cmd = $FindBin::Bin . '/' . $FindBin::Script;
      my $args = [];
  
      if (defined($self->{environment})) {
          foreach (keys %{$self->{environment}}) {
              if ($_ ne '' && (!defined($ENV{$_}) || $ENV{$_} ne $self->{environment}->{$_})) {
                  $ENV{$_} = $self->{environment}->{$_};
                  $need_restart = 1;
              }
          }
      }
  
      my $rebuild_args = $self->check_relaunch_get_args();
  
      if (defined($self->{runas}) && $self->{runas} ne '') {
          # Check if it's already me and user exist ;)
          my ($name, $passwd, $uid) = getpwnam($self->{runas});
          if (!defined($uid)) {
              $self->{output}->add_option_msg(short_msg => "Runas user '" . $self->{runas} . "' not exist.");
              $self->{output}->option_exit();
          }
          if ($uid != $>) {
              if ($> == 0) {
                  unshift @$args, '-s', '/bin/bash', '-l', $self->{runas}, '-c', join(' ', $cmd, @$rebuild_args);
                  $cmd = 'su';
              } else {
                  unshift @$args, '-S', '-u', $self->{runas}, $cmd, @$rebuild_args;
                  $cmd = 'sudo';
              }
              $need_restart = 1;
          }
      }
  
      if ($need_restart == 1) {
          if (scalar(@$args) <= 0) {
              unshift @$args, @$rebuild_args;
          }
  
          my ($lerror, $stdout, $exit_code) = centreon::plugins::misc::backtick(
              command => $cmd,
              arguments => $args,
              timeout => 30,
              wait_exit => 1
          );
  
          if ($exit_code <= -1000) {
              if ($exit_code == -1000) {
                  $self->{output}->output_add(
                      severity => 'UNKNOWN', 
                      short_msg => $stdout
                  );
              }
              $self->{output}->display();
              $self->{output}->exit();
          }
          chomp $stdout;
          print $stdout . "\n";
          # We put unknown
          if (!($exit_code >= 0 && $exit_code <= 4)) {
              exit 3;
          }
          exit $exit_code;
      }
  }
  
  sub run {
      my ($self) = @_;
  
      $self->get_plugin();
  
      if (defined($self->{help}) && !defined($self->{plugin})) {
          $self->display_local_help();
          $self->{output}->option_exit();
      }
      if (defined($self->{list_plugin})) {
          $self->display_list_plugin();
          $self->{output}->option_exit();
      }
      $self->check_plugin_option() if (!defined($self->{plugin}) || $self->{plugin} eq '');
      if (defined($self->{ignore_warn_msg})) {
          $SIG{__WARN__} = sub {};
      }
      $self->convert_args() if (defined($self->{convert_args}));
  
      $self->check_relaunch();
  
      (undef, $self->{plugin}) = 
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => $self->{plugin}, 
              error_msg => 'Cannot load module --plugin.'
          );
      my $plugin = $self->{plugin}->new(options => $self->{options}, output => $self->{output});
      $plugin->init(
          help => $self->{help},
          version => $self->{version}
      );
      $plugin->run();
  }
  
  1;
  
  
  =head1 NAME
  
  centreon_plugins.pl - main program to call Centreon plugins.
  
  =head1 SYNOPSIS
  
  centreon_plugins.pl [options]
  
  =head1 OPTIONS
  
  =over 8
  
  =item B<--plugin>
  
  Specify the path to the plugin.
  
  =item B<--list-plugin>
  
  List all available plugins.
  
  =item B<--version>
  
  Return the version of the plugin.
  
  =item B<--help>
  
  Return the help message for the plugin and exit.
  
  =item B<--ignore-warn-msg>
  
  Ignore Perl warning messages (they will not be displayed).
  
  =item B<--runas>
  
  Run the script as a different user.
  
  =item B<--global-timeout>
  
  Define the script's timeout.
  
  =item B<--environment>
  
  Define environment variables for the script (set them in the execution environment
  before running it for better performance).
  
  =item B<--convert-args>
  
  Replace a pattern in the provided arguments. Useful to bypass forbidden characters.
  E.g.: when a password transmitted via the NRPE protocol contains '!' (which is
  interpreted as a separator), you can send '##' instead of the '!' and the plugin will replace '##' with '!', using the --convert-args='##,\x21' option.
  
  =back
  
  =head1 DESCRIPTION
  
  B<centreon_plugins.pl> .
  
  =cut
CENTREON_PLUGINS_SCRIPT

$fatpacked{"centreon/plugins/script_snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SCRIPT_SNMP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::script_snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::snmp;
  use centreon::plugins::misc;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      $self->{options} = $options{options};
      $self->{output} = $options{output};
      
      $self->{options}->add_options(
          arguments => {
              'mode:s'            => { name => 'mode_name' },
              'dyn-mode:s'        => { name => 'dynmode_name' },
              'list-mode'         => { name => 'list_mode' },
              'mode-version:s'    => { name => 'mode_version' },
              'no-sanity-options' => { name => 'no_sanity_options' },
              'pass-manager:s'    => { name => 'pass_manager' },
          }
      );
      $self->{version} = '1.0';
      $self->{modes} = {};
      $self->{default} = undef;
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      foreach (keys %{$self->{option_results}}) {
          $self->{$_} = $self->{option_results}->{$_};
      }
      $self->{options}->clean();
  
      $self->{options}->add_help(package => $options{package}, sections => 'PLUGIN DESCRIPTION');
      $self->{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL OPTIONS');
      $self->{output}->mode(name => $self->{mode_name});
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
  
      # add meta mode
      $self->{modes}->{multi} = 'centreon::plugins::multi';
      if (defined($options{help}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version}) && !defined($self->{mode_name}) && !defined($self->{dynmode_name})) {
          $self->version();
      }
      if (defined($self->{list_mode})) {
          $self->list_mode();
      }
      $self->{options}->set_sanity() if (!defined($self->{no_sanity_options}));
  
      # Output HELP
      $self->{options}->add_help(package => 'centreon::plugins::output', sections => 'OUTPUT OPTIONS');
  
      $self->load_password_mgr();
  
      # SNMP
      $self->{snmp} = centreon::plugins::snmp->new(options => $self->{options}, output => $self->{output});
  
      # Load mode
      if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
          $self->is_mode(mode => $self->{mode_name});
          centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{modes}{$self->{mode_name}}, 
                                                 error_msg => "Cannot load module --mode.");
          $self->{mode} = $self->{modes}{$self->{mode_name}}->new(options => $self->{options}, output => $self->{output}, mode => $self->{mode_name});
      } elsif (defined($self->{dynmode_name}) && $self->{dynmode_name} ne '') {
          (undef, $self->{dynmode_name}) = centreon::plugins::misc::mymodule_load(output => $self->{output}, module => $self->{dynmode_name}, 
                                                                                  error_msg => "Cannot load module --dyn-mode.");
          $self->{mode} = $self->{dynmode_name}->new(options => $self->{options}, output => $self->{output}, mode => $self->{dynmode_name});
      } else {
          $self->{output}->add_option_msg(short_msg => "Need to specify '--mode' or '--dyn-mode' option.");
          $self->{output}->option_exit();
      }
  
      if (defined($options{help})) {
          if (defined($self->{mode_name}) && $self->{mode_name} ne '') {
              $self->{options}->add_help(package => $self->{modes}{$self->{mode_name}}, sections => 'MODE');
          } else {
              $self->{options}->add_help(package => $self->{dynmode_name}, sections => 'MODE');
          }
          $self->{options}->display_help();
          $self->{output}->option_exit();
      }
      if (defined($options{version})) {
          $self->{mode}->version();
          $self->{output}->option_exit(nolabel => 1);
      }
      if (centreon::plugins::misc::minimal_version($self->{mode}->{version}, $self->{mode_version}) == 0) {
          $self->{output}->add_option_msg(short_msg => "Not good version for plugin mode. Excepted at least: " . $self->{mode_version} . ". Get: ".  $self->{mode}->{version});
          $self->{output}->option_exit();
      }
      
      $self->{options}->parse_options();
      $self->{option_results} = $self->{options}->get_options();
      
      $self->{pass_mgr}->manage_options(option_results => $self->{option_results}) if (defined($self->{pass_mgr}));
      $self->{snmp}->check_options(option_results => $self->{option_results});
      $self->{mode}->check_options(
          option_results => $self->{option_results},
          default => $self->{default},
          snmp => $self->{snmp},
          modes => $self->{modes} # for meta mode multi
      );
  }
  
  sub load_password_mgr {
      my ($self, %options) = @_;
      
      return if (!defined($self->{option_results}->{pass_manager}) || $self->{option_results}->{pass_manager} eq '');
  
      (undef, my $pass_mgr_name) = centreon::plugins::misc::mymodule_load(
          output => $self->{output}, module => "centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager}, 
          error_msg => "Cannot load module 'centreon::plugins::passwordmgr::" . $self->{option_results}->{pass_manager} . "'"
      );
      $self->{pass_mgr} = $pass_mgr_name->new(options => $self->{options}, output => $self->{output});
  }
  
  sub run {
      my ($self) = @_;
  
      if ($self->{output}->is_disco_format()) {
          $self->{mode}->disco_format();
          $self->{output}->display_disco_format();
          $self->{output}->exit(exit_litteral => 'ok');
      }
  
      $self->{snmp}->connect();
      if ($self->{output}->is_disco_show()) {
          $self->{mode}->disco_show(snmp => $self->{snmp});
          $self->{output}->display_disco_show();
          $self->{output}->exit(exit_litteral => 'ok');
      } else {
          $self->{mode}->run(snmp => $self->{snmp});
      }
  }
  
  sub is_mode {
      my ($self, %options) = @_;
  
      if (!defined($self->{modes}{$options{mode}})) {
          $self->{output}->add_option_msg(short_msg => "mode '" . $options{mode} . "' doesn't exist (use --list-mode option to show available modes).");
          $self->{output}->option_exit();
      }
  }
  
  sub version {
      my ($self) = @_;    
      $self->{output}->add_option_msg(short_msg => 'Plugin Version: ' . $self->{version});
      $self->{output}->option_exit(nolabel => 1);
  }
  
  sub list_mode {
      my ($self) = @_;
      $self->{options}->display_help();
  
      $self->{output}->add_option_msg(long_msg => 'Modes Meta:');
      $self->{output}->add_option_msg(long_msg => '   multi');
      $self->{output}->add_option_msg(long_msg => '');
      $self->{output}->add_option_msg(long_msg => 'Modes Available:');
      foreach (sort keys %{$self->{modes}}) {
          next if ($_ eq 'multi');
          $self->{output}->add_option_msg(long_msg => '   ' . $_);
      }
      $self->{output}->option_exit(nolabel => 1);
  }
  
  1;
  
  
  =head1 NAME
  
  -
  
  =head1 SYNOPSIS
  
  -
  
  =head1 GLOBAL OPTIONS
  
  =over 8
  
  =item B<--mode>
  
  Define the mode in which you want the plugin to be executed (see --list-mode).
  
  =item B<--dyn-mode>
  
  Specify a mode with the module's path (advanced).
  
  =item B<--list-mode>
  
  List all available modes.
  
  =item B<--mode-version>
  
  Check minimal version of mode. If not, unknown error.
  
  =item B<--version>
  
  Return the version of the plugin.
  
  =item B<--pass-manager>
  
  Define the password manager you want to use.
  Supported managers are: environment, file, keepass, hashicorpvault and teampass.
  
  =back
  
  =head1 DESCRIPTION
  
  B<>.
  
  =cut
CENTREON_PLUGINS_SCRIPT_SNMP

$fatpacked{"centreon/plugins/snmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_SNMP';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::snmp;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use SNMP;
  use Socket;
  use POSIX;
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
      # $options{options} = options object
      # $options{output} = output object
      # $options{exit_value} = integer
  
      if (!defined($options{output})) {
          print "Class SNMP: Need to specify 'output' argument.\n";
          exit 3;
      }
      if (!defined($options{options})) {
          $options{output}->add_option_msg(short_msg => "Class SNMP: Need to specify 'options' argument.");
          $options{output}->option_exit();
      }
  
      if (!defined($options{noptions})) {
          $options{options}->add_options(arguments => {
              'hostname|host:s'    => { name => 'host' },
              'snmp-community:s'   => { name => 'snmp_community', default => 'public' },
              'snmp-version:s'     => { name => 'snmp_version', default => 1 },
              'snmp-port:s'        => { name => 'snmp_port', default => 161 },
              'snmp-timeout:s'     => { name => 'snmp_timeout', default => 1 },
              'snmp-retries:s'     => { name => 'snmp_retries', default => 5 },
              'maxrepetitions:s'   => { name => 'maxrepetitions', default => 50 },
              'subsetleef:s'       => { name => 'subsetleef', default => 50 },
              'subsettable:s'      => { name => 'subsettable', default => 100 },
              'snmp-cache-file:s'  => { name => 'snmp_cache_file' },
              'snmp-autoreduce:s'  => { name => 'snmp_autoreduce' },
              'snmp-force-getnext' => { name => 'snmp_force_getnext' },
              'snmp-username:s'    => { name => 'snmp_security_name' },
              'authpassphrase:s'   => { name => 'snmp_auth_passphrase' },
              'authprotocol:s'     => { name => 'snmp_auth_protocol' },
              'privpassphrase:s'   => { name => 'snmp_priv_passphrase' },
              'privprotocol:s'     => { name => 'snmp_priv_protocol' },
              'contextname:s'      => { name => 'snmp_context_name' },
              'contextengineid:s'  => { name => 'snmp_context_engine_id' },
              'securityengineid:s' => { name => 'snmp_security_engine_id' },
              'snmp-tls-transport:s'      => { name => 'snmp_tls_transport' },
              'snmp-tls-our-identity:s'   => { name => 'snmp_tls_our_identity' },
              'snmp-tls-their-identity:s' => { name => 'snmp_tls_their_identity' },
              'snmp-tls-their-hostname:s' => { name => 'snmp_tls_their_hostname' },
              'snmp-tls-trust-cert:s    ' => { name => 'snmp_tls_trust_cert' },
              'snmp-errors-exit:s'        => { name => 'snmp_errors_exit', default => 'unknown' },
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'SNMP OPTIONS');
      }
  
      #####
      $self->{session} = undef;
      $self->{output} = $options{output};
      $self->{snmp_params} = {};
  
      $self->{use_snmp_cache} = 0;
  
      # Dont load MIB
      $SNMP::auto_init_mib = 0;
      $ENV{MIBS} = '';
      # For snmpv v1 - get request retries when you have "NoSuchName"
      $self->{RetryNoSuch} = 1;
      # Dont try to translate OID (we keep value)
      $self->{UseNumeric} = 1;
  
      $self->{error_msg} = undef;
      $self->{error_status} = 0;
  
      return $self;
  }
  
  sub connect {
      my ($self, %options) = @_;
  
      $self->{snmp_params}->{RetryNoSuch} = $self->{RetryNoSuch};
      $self->{snmp_params}->{UseNumeric} = $self->{UseNumeric};
  
      if (!$self->{output}->is_litteral_status(status => $self->{snmp_errors_exit})) {
          $self->{output}->add_option_msg(short_msg => "Unknown value '" . $self->{snmp_errors_exit}  . "' for --snmp-errors-exit.");
          $self->{output}->option_exit(exit_litteral => 'unknown');
      }
  
      $self->{session} = new SNMP::Session(%{$self->{snmp_params}});
      if (!defined($self->{session})) {
          if (defined($options{dont_quit}) && $options{dont_quit} == 1) {
              $self->set_error(error_status => -1, error_msg => 'SNMP Session: unable to create');
              return 1;
          }
          $self->{output}->add_option_msg(short_msg => 'SNMP Session: unable to create');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
      if ($self->{session}->{ErrorNum}) {
          if (defined($options{dont_quit}) && $options{dont_quit} == 1) {
              $self->set_error(error_status => -1, error_msg => 'SNMP Session: ' . $self->{session}->{ErrorStr});
              return 1;
          }
          $self->{output}->add_option_msg(short_msg => 'SNMP Session: ' . $self->{session}->{ErrorStr});
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return 0;
  }
  
  sub load {
      my ($self, %options) = @_;
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
      # $options{instances} = ref to array of oids instances
      # $options{begin}, $args->{end} = integer instance end
      # $options{instance_regexp} = str
      # 3 way to use: with instances, with end, none
      
      if (defined($options{end})) {
          for (my $i = $options{begin}; $i <= $options{end}; $i++) {
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $i;
              }
          }
          return ;
      }
      
      if (defined($options{instances})) {
          $options{instance_regexp} = defined($options{instance_regexp}) ? $options{instance_regexp} : '(\d+)$';
          foreach my $instance (@{$options{instances}}) {
              $instance =~ /$options{instance_regexp}/;
              foreach (@{$options{oids}}) {
                  push @{$self->{oids_loaded}}, $_ . "." . $1;
              }
          }
          return ;
      }
      
      push @{$self->{oids_loaded}}, @{$options{oids}};
  }
  
  sub autoreduce_table {
      my ($self, %options) = @_;
      
      return 1 if (defined($self->{snmp_force_getnext}) || $self->is_snmpv1());
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if (${$options{repeat_count}} == 1);
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_multiple_table {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      return 1 if (${$options{repeat_count}} == 1);
      
      ${$options{repeat_count}} = int(${$options{repeat_count}} / $self->{snmp_autoreduce_divisor});
      $self->{subsettable} = int($self->{subsettable} / $self->{snmp_autoreduce_divisor});
      ${$options{repeat_count}} = 1 if (${$options{repeat_count}} < 1);
      return 0;
  }
  
  sub autoreduce_leef {
      my ($self, %options) = @_;
      
      if ($self->{snmp_params}->{Retries} > 1) {
          $self->{snmp_params}->{Retries} = 1;
          $self->connect();
      }
      
      return 1 if ($self->{subsetleef} == 1);
      $self->{subsetleef} = int($self->{subsetleef} / $self->{snmp_autoreduce_divisor});
      $self->{subsetleef} = 1 if ($self->{subsetleef} < 1);
      
      my $array_ref = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach ([@{$options{current}}], @{$self->{array_ref_ar}}) {
          foreach my $entry (@$_) {;
              push @$subset_construct, [$entry->[0], $entry->[1]];
              $subset_current++;
              if ($subset_current == $self->{subsetleef}) {
                  push @$array_ref, \@$subset_construct;
                  $subset_construct = [];
                  $subset_current = 0;
              }
          }
      }
      
      if ($subset_current) {
          push @$array_ref, \@$subset_construct;
      }
  
      $self->{array_ref_ar} = \@$array_ref;
      return 0;
  }
  
  sub get_leef_cache {
      my ($self, %options) = @_;
  
      my $results = {};
      foreach my $oid (@{$options{oids}}) {
          if (defined($self->{snmp_cache}->{$oid})) {
              $results->{$oid} = $self->{snmp_cache}->{$oid};
          }
      }
  
      if ($options{nothing_quit} == 1 && scalar(keys %$results) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP GET Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return $results;
  }
  
  sub get_leef {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{nothing_quit} = integer
      # $options{oids} = ref to array of oids (example: ['.1.2', '.1.2'])
  
      # Returns array
      #    'undef' value for an OID means NoSuchValue
  
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if (!defined($options{oids})) {
          if ($#{$self->{oids_loaded}} < 0) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Need to specify OIDs");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => 'Need to specify OIDs');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
          push @{$options{oids}}, @{$self->{oids_loaded}};
          @{$self->{oids_loaded}} = ();
      }
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_leef_cache(oids => $options{oids}, nothing_quit => $nothing_quit);
      }
  
      my $results = {};
      $self->{array_ref_ar} = [];
      my $subset_current = 0;
      my $subset_construct = [];
      foreach my $oid (@{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
          
          my ($oid, $instance) = ($1, $2);
          $results->{$oid . "." . $instance} = undef;
          push @$subset_construct, [$oid, $instance];
          $subset_current++;
          if ($subset_current == $self->{subsetleef}) {
              push @{$self->{array_ref_ar}}, \@$subset_construct;
              $subset_construct = [];
              $subset_current = 0;
          }
      }
      if ($subset_current) {
          push @{$self->{array_ref_ar}}, \@$subset_construct;
      }
  
      ############################
      # If wrong oid with SNMP v1, packet resent (2 packets more). Not the case with SNMP > 1.
      # Can have "NoSuchName", if nothing works...
      # = v1: wrong oid
      #   bless( [
      #       '.1.3.6.1.2.1.1.3',
      #       '0',
      #       '199720062',
      #       'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1.999',
      #       '0'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #       '.1.3.6.1.2.1.1',
      #       '1000'
      #       ], 'SNMP::Varbind' )
      # > v1: wrong oid
      #   bless( [
      #        '.1.3.6.1.2.1.1.3',
      #        '0',
      #        '199728713',
      #        'TICKS'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #         '.1.3.6.1.2.1.1',
      #         '3',
      #         'NOSUCHINSTANCE',
      #        'TICKS'
      #    ], 'SNMP::Varbind' )
      #   bless( [
      #        '.1.3.6.1.2.1.1.999',
      #        '0',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' ),
      #   bless( [
      #        '.1.3.6.1.2.1.1',
      #        '1000',
      #        'NOSUCHOBJECT',
      #        'NOSUCHOBJECT'
      #       ], 'SNMP::Varbind' )
      ############################
  
      my $total = 0;
      while (my $entry = shift(@{$self->{array_ref_ar}})) {
          my $vb = new SNMP::VarList(@{$entry});
          $self->{session}->get($vb);
  
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We next.
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_leef(current => $entry) == 0);
              }
              my $msg = 'SNMP GET Request: ' . $self->{session}->{ErrorStr};    
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Some equipments gives a partial response and no error.
          # We look the last value if it's empty or not
          # In snmpv1 we have the retryNoSuch
          if (((scalar(@$vb) != scalar(@{$entry})) || (scalar(@{@$vb[-1]}) < 3)) && !$self->is_snmpv1()) {
              next if ($self->{snmp_autoreduce} == 1 && $self->autoreduce_leef(current => $entry) == 0);
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => 'SNMP partial response. Please try --snmp-autoreduce option');
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => 'SNMP partial response');
              return undef;
          }
  
          foreach my $entry (@$vb) {
              if ($#$entry < 3) {
                  # Can be snmpv1 not find
                  next;
              }
              if (${$entry}[2] eq 'NOSUCHOBJECT' || ${$entry}[2] eq 'NOSUCHINSTANCE') {
                  # Error in snmp > 1
                  next;
              }
  
              $total++;
              $results->{${$entry}[0] . "." . ${$entry}[1]} = ${$entry}[2];
          }
      }
  
      if ($nothing_quit == 1 && $total == 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP GET Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub multiple_find_bigger {
      my ($self, %options) = @_;
      
      my $getting = {};
      my @values = ();
      foreach my $key (keys %{$options{working_oids}}) {
          push @values, $options{working_oids}->{$key}->{start};
          $getting->{ $options{working_oids}->{$key}->{start} } = $key;
      }
      @values = $self->oid_lex_sort(@values);
      
      return $getting->{pop(@values)};
  }
  
  sub get_multiple_table_cache {
      my ($self, %options) = @_;
  
      my $results = {};
      foreach my $entry (@{$options{oids}}) {
          my $result = $self->get_table_cache(
              oid => $entry->{oid},
              start => $entry->{start},
              end => $entry->{end},
              nothing_quit => 0
          );
          if ($options{return_type} == 0) {
              $results->{ $entry->{oid} } = $result;
          } else {
              $results = { %$results, %$result };
          }
      }
  
      my $total = 0;
      if ($options{nothing_quit} == 1) {
          if ($options{return_type} == 1) {
              $total = scalar(keys %$results);
          } else {
              foreach (keys %$results) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
  
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      return $results;
  }
  
  sub get_multiple_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = refs array
      #     [ { oid => 'x.x.x.x', start => '', end => ''}, { oid => 'y.y.y.y', start => '', end => ''} ]
      # $options{return_type} = integer
  
      my ($return_type) = (defined($options{return_type}) && $options{return_type} == 1) ? 1 : 0;
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_multiple_table_cache(
              oids => $options{oids},
              return_type => $return_type,
              nothing_quit => $nothing_quit
          );
      }
  
      my $working_oids = {};
      my $results = {};
      # Check overlap
      foreach my $entry (@{$options{oids}}) {
          # Transform asking
          if ($entry->{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
              if ($dont_quit == 1) {
                  $self->set_error(error_status => -1, error_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
                  return undef;
              }
              $self->{output}->add_option_msg(short_msg => "Method 'get_multiple_table': Wrong OID '" . $entry->{oid} . "'.");
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
  
          if (defined($entry->{start})) {
              $working_oids->{$entry->{oid}} = { start => $entry->{start}, end => $entry->{end} }; # last in it
          } else {
              $working_oids->{$entry->{oid}} = { start => $entry->{oid}, end => $entry->{end} };
          }
  
          if ($return_type == 0) {
              $results->{ $entry->{oid} } = {};
          }
      }
  
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
  
      # Quit if base not the same or 'ENDOFMIBVIEW' value. Need all oid finish otherwise we continue :)
      while (1) {
          my $current_oids = 0;
          my @bindings = ();
          my @bases = ();
          foreach my $key (keys %{$working_oids}) {
              $working_oids->{$key}->{start} =~ /(.*)\.(\d+)([\.\s]*)$/;
              push @bindings, [$1, $2];
              push @bases, $key;
  
              $current_oids++;
              last if ($current_oids > $self->{subsettable});
          }
  
          # Nothing more to check. We quit
          last if ($current_oids == 0);
  
          my $vb = new SNMP::VarList(@bindings);
  
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              my $current_repeat_count = floor($repeat_count / $current_oids);
              $current_repeat_count = 1 if ($current_repeat_count == 0);
              $self->{session}->getbulk(0, $current_repeat_count, $vb);
          }
  
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. Need to find the most up oid ;)
                  my $oid_base = $self->multiple_find_bigger(working_oids => $working_oids);
                  delete $working_oids->{$oid_base};
                  next;
              }
  
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_multiple_table(repeat_count => \$repeat_count) == 0);
              }
  
              my $msg = 'SNMP Table Request: ' . $self->{session}->{ErrorStr};
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Manage
          # step by step: [ 1 => 1, 2 => 1, 3 => 1 ], [ 1 => 2, 2 => 2, 3 => 2 ],...
  
          my $pos = -1;
          foreach my $entry (@$vb) {
              $pos++;
  
              # Already destruct. we continue
              next if (!defined($working_oids->{ $bases[$pos % $current_oids] }));
  
              # ENDOFMIBVIEW is on each iteration. So we need to delete and skip after that
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  # END mib
                  next;
              }
  
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              my $base = $bases[$pos % $current_oids];
              if ($complete_oid !~ /^$base\./ ||
                  (defined($working_oids->{ $bases[$pos % $current_oids] }->{end}) && 
                   $self->check_oid_up(current => $complete_oid, end => $working_oids->{ $bases[$pos % $current_oids] }->{end}))) {
                  delete $working_oids->{ $bases[$pos % $current_oids] };
                  next;
              }
  
              if ($return_type == 0) {
                  $results->{$bases[$pos % $current_oids]}->{$complete_oid} = ${$entry}[2];
              } else {
                  $results->{$complete_oid} = ${$entry}[2];
              }
  
              $working_oids->{ $bases[$pos % $current_oids] }->{start} = $complete_oid;
          }
  
          # infinite loop. Some equipments it returns nothing!!??
          if ($pos == -1) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: problem to get values (try --snmp-force-getnext option)');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      my $total = 0;
      if ($nothing_quit == 1) {
          if ($return_type == 1) {
              $total = scalar(keys %{$results});
          } else {
              foreach (keys %{$results}) {
                  $total += scalar(keys %{$results->{$_}});
              }
          }
  
          if ($total == 0) {
              $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub get_table_cache {
      my ($self, %options) = @_;
  
      my $branch = defined($options{start}) ? $options{start} : $options{oid};
  
      my $results = {};
      foreach my $oid ($self->oid_lex_sort(keys %{$self->{snmp_cache}})) {
          if ($oid =~ /^$branch\./) {
              $results->{$oid} = $self->{snmp_cache}->{$oid};
              if (defined($options{end}) && $self->check_oid_up(current => $oid, end => $options{end})) {
                  last;
              } 
          }
      }
  
      if ($options{nothing_quit} == 1 && scalar(keys %$results) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      return $results;
  }
  
  sub get_table {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oid} = string (example: '.1.2')
      # $options{start} = string (example: '.1.2')
      # $options{end} = string (example: '.1.2')
  
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      my ($nothing_quit) = (defined($options{nothing_quit}) && $options{nothing_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      if (defined($options{start})) {
          $options{start} = $self->clean_oid($options{start});
      }
      if (defined($options{end})) {
          $options{end} = $self->clean_oid($options{end});
      }
  
      if ($self->{use_snmp_cache} == 1) {
          return $self->get_table_cache(
              oid => $options{oid},
              start => $options{start},
              end => $options{end},
              nothing_quit => $nothing_quit
          );
      }
  
      # we use a medium (UDP have a PDU limit. SNMP protcol cant send multiples for one request)
      # So we need to manage
      # It's for "bulk". We ask 50 next values. If you set 1, it's like a getnext (snmp v1)
      my $repeat_count = 50;
      if (defined($self->{maxrepetitions}) && 
          $self->{maxrepetitions} =~ /^\d+$/) {
          $repeat_count = $self->{maxrepetitions};
      }
  
      # Transform asking
      if ($options{oid} !~ /(.*)\.(\d+)([\.\s]*)$/) {
          if ($dont_quit == 1) {
              $self->set_error(error_status => -1, error_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
              return undef;
          }
          $self->{output}->add_option_msg(short_msg => "Method 'get_table': Wrong OID '" . $options{oid} . "'.");
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      my $main_indice = $1 . '.' . $2;
      my $results = {};
  
      # Quit if base not the same or 'ENDOFMIBVIEW' value
      my $leave = 1;
      my $last_oid;
  
      if (defined($options{start})) {
          $last_oid = $options{start};
      } else {
          $last_oid = $options{oid};
      }
      while ($leave) {
          $last_oid =~ /(.*)\.(\d+)([\.\s]*)$/;
          my $vb = new SNMP::VarList([$1, $2]);
  
          if ($self->is_snmpv1() || defined($self->{snmp_force_getnext})) {
              $self->{session}->getnext($vb);
          } else {
              $self->{session}->getbulk(0, $repeat_count, $vb);
          }
  
          # Error
          if ($self->{session}->{ErrorNum}) {
              # 0    noError       Pas d'erreurs.
              # 1    tooBig        Reponse de taille trop grande.
              # 2    noSuchName    Variable inexistante.
              # -24  Timeout
              if ($self->{session}->{ErrorNum} == 2) {
                  # We are at the end with snmpv1. We quit.
                  last;
              }
              if ($self->{snmp_autoreduce} == 1 && 
                  ($self->{session}->{ErrorNum} == 1 || $self->{session}->{ErrorNum} == 5 || $self->{session}->{ErrorNum} == -24)) {
                  next if ($self->autoreduce_table(repeat_count => \$repeat_count) == 0);
              }
  
              my $msg = 'SNMP Table Request: ' . $self->{session}->{ErrorStr};
  
              if ($dont_quit == 0) {
                  $self->{output}->add_option_msg(short_msg => $msg);
                  $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
              }
  
              $self->set_error(error_status => -1, error_msg => $msg);
              return undef;
          }
  
          # Manage
          foreach my $entry (@$vb) {
              if (${$entry}[2] eq 'ENDOFMIBVIEW') {
                  # END mib
                  $leave = 0;
                  last;
              }
  
              # Not in same table
              my $complete_oid = ${$entry}[0] . "." . ${$entry}[1];
              if ($complete_oid !~ /^$main_indice\./ ||
                  (defined($options{end}) && $self->check_oid_up(current => $complete_oid, end => $options{end}))) {
                  $leave = 0;
                  last;
              }
  
              $results->{$complete_oid} = ${$entry}[2];
              $last_oid = $complete_oid;
          }
      }
  
      if ($nothing_quit == 1 && scalar(keys %$results) == 0) {
          $self->{output}->add_option_msg(short_msg => 'SNMP Table Request: Cant get a single value.');
          $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
      }
  
      $self->debug(results => $results) if ($self->{output}->is_debug());
  
      return $results;
  }
  
  sub set {
      my ($self, %options) = @_;
      # $options{dont_quit} = integer
      # $options{oids} = ref to hash table
      my ($dont_quit) = (defined($options{dont_quit}) && $options{dont_quit} == 1) ? 1 : 0;
      $self->set_error();
  
      my $vars = [];
      foreach my $oid (keys %{$options{oids}}) {
          # Get last value
          next if ($oid !~ /(.*)\.(\d+)([\.\s]*)$/);
  
          my $value = $options{oids}->{$oid}->{value};
          my $type = $options{oids}->{$oid}->{type};
          my ($oid, $instance) = ($1, $2);
  
          push @$vars, [$oid, $instance, $value, $type];
      }
  
      $self->{session}->set($vars);
      if ($self->{session}->{ErrorNum}) {
          # 0    noError       Pas d'erreurs.
          # 1    tooBig        Reponse de taille trop grande.
          # 2    noSuchName    Variable inexistante.
  
          my $msg = 'SNMP SET Request: ' . $self->{session}->{ErrorStr};
          if ($dont_quit == 0) {
              $self->{output}->add_option_msg(short_msg => $msg);
              $self->{output}->option_exit(exit_litteral => $self->{snmp_errors_exit});
          }
  
          $self->set_error(error_status => -1, error_msg => $msg);
          return undef;
      }
  
      return 0;
  }
  
  sub is_snmpv1 {
      my ($self) = @_;
  
      if ($self->{snmp_params}->{Version} eq '1') {
          return 1;
      }
      return 0;
  }
  
  sub clean_oid {
      my ($self, $oid) = @_;
  
      $oid =~ s/\.$//;
      $oid =~ s/^(\d)/\.$1/;
      return $oid;
  }
  
  sub check_oid_up {
      my ($self, %options) = @_;
  
      my $current_oid = $options{current};
      my $end_oid = $options{end};
  
      my @current_oid_splitted = split /\./, $current_oid;
      my @end_oid_splitted = split /\./, $end_oid;
      # Skip first value (before first '.' empty)
      for (my $i = 1; $i <= $#current_oid_splitted && $i <= $#end_oid_splitted; $i++) {
          if (int($current_oid_splitted[$i]) > int($end_oid_splitted[$i])) {
              return 1;
          }
      }
  
      return 0;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      $self->{snmp_errors_exit} = $options{option_results}->{snmp_errors_exit};
  
      if (defined($options{option_results}->{snmp_cache_file}) && $options{option_results}->{snmp_cache_file} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'JSON::XS',
              error_msg => "Cannot load module 'JSON::XS'."
          );
          my $content = centreon::plugins::misc::slurp_file(output => $self->{output}, file => $options{option_results}->{snmp_cache_file});
          eval {
              $self->{snmp_cache} = JSON::XS->new->decode($content);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot decode json cache file: $@");
              $self->{output}->option_exit();
          }
  
          $self->{use_snmp_cache} = 1;
          return ;
      }
  
      if (!defined($options{option_results}->{host})) {
          $self->{output}->add_option_msg(short_msg => 'Missing parameter --hostname.');
          $self->{output}->option_exit();
      }
  
      $options{option_results}->{snmp_version} =~ s/^v//;
      if ($options{option_results}->{snmp_version} !~ /1|2c|2|3/) {
          $self->{output}->add_option_msg(short_msg => 'Unknown snmp version.');
          $self->{output}->option_exit();
      }
  
      $self->{snmp_force_getnext} = $options{option_results}->{snmp_force_getnext};
      $self->{maxrepetitions} = $options{option_results}->{maxrepetitions};
      $self->{subsetleef} = (defined($options{option_results}->{subsetleef}) && $options{option_results}->{subsetleef} =~ /^[0-9]+$/) ? $options{option_results}->{subsetleef} : 50;
      $self->{subsettable} = (defined($options{option_results}->{subsettable}) && $options{option_results}->{subsettable} =~ /^[0-9]+$/) ? $options{option_results}->{subsettable} : 100;
      $self->{snmp_autoreduce} = 0;
      $self->{snmp_autoreduce_divisor} = 2;
      if (defined($options{option_results}->{snmp_autoreduce})) {
          $self->{snmp_autoreduce} = 1;
          $self->{snmp_autoreduce_divisor} = $1 if ($options{option_results}->{snmp_autoreduce} =~ /(\d+(\.\d+)?)/ && $1 > 1);
      }
  
      %{$self->{snmp_params}} = (
          DestHost => $options{option_results}->{host},
          Community => $options{option_results}->{snmp_community},
          Version => $options{option_results}->{snmp_version},
          RemotePort => $options{option_results}->{snmp_port},
          Retries => 5
      );
  
      if (defined($options{option_results}->{snmp_timeout}) && $options{option_results}->{snmp_timeout} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Timeout} = $options{option_results}->{snmp_timeout} * (10**6);
      }
  
      if (defined($options{option_results}->{snmp_retries}) && $options{option_results}->{snmp_retries} =~ /^[0-9]+$/) {
          $self->{snmp_params}->{Retries} = $options{option_results}->{snmp_retries};
      }
  
      if ($options{option_results}->{snmp_version} eq '3') {
          delete $self->{snmp_params}->{Community};
  
          $self->{snmp_params}->{Context} = $options{option_results}->{snmp_context_name} if (defined($options{option_results}->{snmp_context_name}));
          $self->{snmp_params}->{ContextEngineId} = $options{option_results}->{snmp_context_engine_id} if (defined($options{option_results}->{snmp_context_engine_id}));
          $self->{snmp_params}->{SecEngineId} = $options{option_results}->{snmp_security_engine_id} if (defined($options{option_results}->{snmp_security_engine_id}));
          $self->{snmp_params}->{SecName} = $options{option_results}->{snmp_security_name} if (defined($options{option_results}->{snmp_security_name}));
  
          # Certificate SNMPv3. Need net-snmp > 5.6
          if (defined($options{option_results}->{snmp_tls_transport}) && $options{option_results}->{snmp_tls_transport} =~ /^dtlsudp|tlstcp$/) {
              $self->{snmp_params}->{DestHost} = $options{option_results}->{snmp_tls_transport} . ':' . $options{option_results}->{host};
              $self->{snmp_params}->{OurIdentity} = $options{option_results}->{snmp_tls_our_identity} if (defined($options{option_results}->{snmp_tls_our_identity}));
              $self->{snmp_params}->{TheirIdentity} = $options{option_results}->{snmp_tls_their_identity} if (defined($options{option_results}->{snmp_tls_their_identity}));
              $self->{snmp_params}->{TheirHostname} = $options{option_results}->{snmp_tls_their_hostname} if (defined($options{option_results}->{snmp_tls_their_hostname}));
              $self->{snmp_params}->{TrustCert} = $options{option_results}->{snmp_tls_trust_cert} if (defined($options{option_results}->{snmp_tls_trust_cert}));
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              return ;
          }
  
          if (!defined($options{option_results}->{snmp_security_name}) || $options{option_results}->{snmp_security_name} eq '') {
              $self->{output}->add_option_msg(short_msg => 'Missing parameter Security Name.');
              $self->{output}->option_exit();
          }
  
          # unauthenticated and unencrypted
          $self->{snmp_params}->{SecLevel} = 'noAuthNoPriv';
  
          my $user_activate = 0;
          if (defined($options{option_results}->{snmp_auth_passphrase}) && $options{option_results}->{snmp_auth_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_auth_protocol})) {
                  $self->{output}->add_option_msg(short_msg => 'Missing parameter authenticate protocol.');
                  $self->{output}->option_exit();
              }
              $options{option_results}->{snmp_auth_protocol} = uc($options{option_results}->{snmp_auth_protocol});
              if ($options{option_results}->{snmp_auth_protocol} !~ /^(?:MD5|SHA|SHA224|SHA256|SHA384|SHA512)$/) {
                  $self->{output}->add_option_msg(short_msg => 'Wrong authentication protocol.');
                  $self->{output}->option_exit();
              }
  
              $self->{snmp_params}->{SecLevel} = 'authNoPriv';
              $self->{snmp_params}->{AuthProto} = $options{option_results}->{snmp_auth_protocol};
              $self->{snmp_params}->{AuthPass} = $options{option_results}->{snmp_auth_passphrase};
              $user_activate = 1;
          }
  
          if (defined($options{option_results}->{snmp_priv_passphrase}) && $options{option_results}->{snmp_priv_passphrase} ne '') {
              if (!defined($options{option_results}->{snmp_priv_protocol})) {
                  $self->{output}->add_option_msg(short_msg => 'Missing parameter privacy protocol.');
                  $self->{output}->option_exit();
              }
  
              $options{option_results}->{snmp_priv_protocol} = uc($options{option_results}->{snmp_priv_protocol});
              if ($options{option_results}->{snmp_priv_protocol} !~ /^(?:DES|AES|AES192|AES192C|AES256|AES256C)$/) {
                  $self->{output}->add_option_msg(short_msg => 'Wrong privacy protocol.');
                  $self->{output}->option_exit();
              }
              if ($user_activate == 0) {
                  $self->{output}->add_option_msg(short_msg => 'Cannot use snmp v3 privacy option without snmp v3 authentification options.');
                  $self->{output}->option_exit();
              }
              $self->{snmp_params}->{SecLevel} = 'authPriv';
              $self->{snmp_params}->{PrivPass} = $options{option_results}->{snmp_priv_passphrase};
              $self->{snmp_params}->{PrivProto} = $options{option_results}->{snmp_priv_protocol};
          }
      }
  }
  
  sub set_snmp_connect_params {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{snmp_params}->{$_} = $options{$_};
      }
  }
  
  sub set_snmp_params {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub set_error {
      my ($self, %options) = @_;
      # $options{error_msg} = string error
      # $options{error_status} = integer status
  
      $self->{error_status} = defined($options{error_status}) ? $options{error_status} : 0;
      $self->{error_msg} = defined($options{error_msg}) ? $options{error_msg} : undef;
  }
  
  sub error_status {
      my ($self) = @_;
  
      return $self->{error_status};
  }
  
  sub error {
      my ($self) = @_;
  
      return $self->{error_msg};
  }
  
  sub get_hostname {
      my ($self) = @_;
  
      my $host = $self->{snmp_params}->{DestHost};
      $host =~ s/.*://;
      return $host;
  }
  
  sub get_port {
      my ($self) = @_;
  
      return $self->{snmp_params}->{RemotePort};
  }
  
  sub map_instance {
      my ($self, %options) = @_;
  
      my $results = {};
      my $instance = '';
      $instance = '.' . $options{instance} if (defined($options{instance}));
      foreach my $name (keys %{$options{mapping}}) {
          my $entry = $options{mapping}->{$name}->{oid} . $instance;
          if (defined($options{results}->{$entry})) {
              $results->{$name} = $options{results}->{$entry};
          } elsif (defined($options{results}->{$options{mapping}->{$name}->{oid}}->{$entry})) {
              $results->{$name} = $options{results}->{$options{mapping}->{$name}->{oid}}->{$entry};
          } else {
              $results->{$name} = defined($options{default}) ? $options{default} : undef;
          }
  
          if (defined($options{mapping}->{$name}->{map})) {
              if (defined($results->{$name})) {
                  $results->{$name} = defined($options{mapping}->{$name}->{map}->{$results->{$name}}) ? $options{mapping}->{$name}->{map}->{$results->{$name}} : (defined($options{default}) ? $options{default} : 'unknown');
              }
          }
      }
  
      return $results;
  }
  
  sub debug {
      my ($self, %options) = @_;
  
      foreach my $oid1 ($self->oid_lex_sort(keys %{$options{results}})) {
          if (ref($options{results}->{$oid1}) eq 'HASH') {
              foreach my $oid2 ($self->oid_lex_sort(keys %{$options{results}->{$oid1}})) {
                  $self->{output}->output_add(long_msg => $oid2 . ' = ' . (defined($options{results}->{$oid1}->{$oid2}) ? $options{results}->{$oid1}->{$oid2} : 'undef'), debug => 1);
              }
          } else {
              $self->{output}->output_add(long_msg => $oid1 . ' = ' . (defined($options{results}->{$oid1}) ? $options{results}->{$oid1} : 'undef'), debug => 1);
          }
      }
  }
  
  sub oid_lex_sort {
      my $self = shift;
  
      if (@_ <= 1) {
          return @_;
      }
  
      return map { $_->[0] }
          sort { $a->[1] cmp $b->[1] }
          map {
             my $oid = $_;
             $oid =~ s/^\.//;
             $oid =~ s/ /\.0/g;
             [$_, pack 'N*', split m/\./, $oid]
          } @_;
  }
  
  1;
  
  
  =head1 NAME
  
  SNMP global
  
  =head1 SYNOPSIS
  
  snmp class
  
  =head1 SNMP OPTIONS
  
  =over 8
  
  =item B<--hostname>
  
  Name or address of the host to monitor (mandatory).
  
  =item B<--snmp-community>
  
  SNMP community (default value: public). It is recommended to use a read-only
  community.
  
  =item B<--snmp-version>
  
  Version of the SNMP protocol. 1 for SNMP v1 (default), 2 for SNMP v2c, 3 for SNMP v3.
  
  =item B<--snmp-port>
  
  UDP port to send the SNMP request to (default: 161).
  
  =item B<--snmp-timeout>
  
  Time to wait before sending the request again if no reply has been received,
  in seconds (default: 1). See also --snmp-retries.
  
  =item B<--snmp-retries>
  
  Maximum number of retries (default: 5).
  
  =item B<--maxrepetitions>
  
  Max repetitions value (default: 50) (only for SNMP v2 and v3).
  
  =item B<--subsetleef>
  
  How many OID values per SNMP request (default: 50) (for get_leef method. Be cautious when you set it. Prefer to let the default value).
  
  =item B<--snmp-autoreduce>
   
  Progressively reduce the number of requested OIDs in bulk mode. Use it in case of
  SNMP errors (by default, the number is divided by 2).
  
  =item B<--snmp-force-getnext>
  
  Use SNMP getnext function in SNMP v2c and v3. This will request one OID at a
  time.
  
  =item B<--snmp-cache-file>
  
  Use SNMP cache file.
  
  =item B<--snmp-username>
  
  SNMP v3 only:
  User name (securityName). 
  
  =item B<--authpassphrase>
  
  SNMP v3 only:
  Pass phrase hashed using the authentication protocol defined in the 
  --authprotocol option.
  
  =item B<--authprotocol>
  
  SNMP v3 only:
  Authentication protocol: MD5|SHA. Since net-snmp 5.9.1: SHA224|SHA256|SHA384|SHA512.
  
  =item B<--privpassphrase>
  
  SNMP v3 only:
  Privacy pass phrase (privPassword) to encrypt messages using the protocol
  defined in the --privprotocol option.
  
  =item B<--privprotocol>
  
  SNMP v3 only:
  Privacy protocol (privProtocol) used to encrypt messages.
  Supported protocols are: DES|AES and since net-snmp 5.9.1: AES192|AES192C|AES256|AES256C.
  
  =item B<--contextname>
  
  SNMP v3 only:
  Context name (contextName), if relevant for the monitored host.
  
  =item B<--contextengineid>
  
  SNMP v3 only:
  Context engine ID (contextEngineID), if relevant for the monitored host, given 
  as a hexadecimal string.
  
  =item B<--securityengineid>
  
  SNMP v3 only:
  Security engine ID, given as a hexadecimal string.
  
  =item B<--snmp-errors-exit>
  
  Expected status in case of SNMP error or timeout.
  Possible values are warning, critical and unknown (default).
  
  =item B<--snmp-tls-transport>
  
  Transport protocol for TLS communication (can be: 'dtlsudp', 'tlstcp').
  
  =item B<--snmp-tls-our-identity>
  
  X.509 certificate to identify ourselves. Can be the path to the certificate file
  or its contents.
  
  =item B<--snmp-tls-their-identity>
  
  X.509 certificate to identify the remote host. Can be the path to the 
  certificate file or its contents. This option is unnecessary if the certificate
  is already trusted by your system.
  
  =item B<--snmp-tls-their-hostname>
  
  Common Name (CN) expected in the certificate sent by the host if it differs from
  the value of the --hostname parameter.
  
  =item B<--snmp-tls-trust-cert>
  
  A trusted CA certificate used to verify a remote host's certificate. 
  If you use this option, you must also  define --snmp-tls-their-hostname.
  
  =back
  
  =head1 DESCRIPTION
  
  B<snmp>.
  
  =cut
CENTREON_PLUGINS_SNMP

$fatpacked{"centreon/plugins/statefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_STATEFILE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::statefile;
  
  use strict;
  use warnings;
  use Data::Dumper;
  use centreon::plugins::misc;
  
  my $default_dir = '/var/lib/centreon/centplugins';
  if ($^O eq 'MSWin32') {
      $default_dir = 'C:/Windows/Temp';
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      if (defined($options{options})) {
          $options{options}->add_options(arguments => {
              'memcached:s'          => { name => 'memcached' },
              'redis-server:s'       => { name => 'redis_server' },
              'redis-attribute:s%'   => { name => 'redis_attribute' },
              'redis-db:s'           => { name => 'redis_db' },
              'memexpiration:s'      => { name => 'memexpiration', default => 86400 },
              'statefile-dir:s'      => { name => 'statefile_dir', default => $default_dir },
              'statefile-suffix:s'   => { name => 'statefile_suffix', default => '' },
              'statefile-concat-cwd' => { name => 'statefile_concat_cwd' },
              'statefile-storable'   => { name => 'statefile_storable' }, # legacy
              'failback-file'        => { name => 'failback_file' },
              'statefile-format:s'   => { name => 'statefile_format' },
              'statefile-key:s'      => { name => 'statefile_key' },
              'statefile-cipher:s'   => { name => 'statefile_cipher' }
          });
          $options{options}->add_help(package => __PACKAGE__, sections => 'RETENTION OPTIONS', once => 1);
      }
  
      $self->{error} = 0;
      $self->{output} = $options{output};
      $self->{datas} = {};
      $self->{storable} = 0;
      $self->{memcached_ok} = 0;
      $self->{memcached} = undef;
  
      $self->{statefile_dir} = undef;
      $self->{statefile_suffix} = undef;
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
  
      if (defined($options{option_results}) && defined($options{option_results}->{memcached})) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Memcached::libmemcached',
              error_msg => "Cannot load module 'Memcached::libmemcached'."
          );
          $self->{memcached} = Memcached::libmemcached->new();
          Memcached::libmemcached::memcached_server_add($self->{memcached}, $options{option_results}->{memcached});
      }
  
      # Check redis
      if (defined($options{option_results}->{redis_server})) {
          $self->{redis_attributes} = '';
          if (defined($options{option_results}->{redis_attribute})) {
              foreach (keys %{$options{option_results}->{redis_attribute}}) {
                  $self->{redis_attributes} .= "$_ => " . $options{option_results}->{redis_attribute}->{$_} . ', ';
              }
          }
  
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Redis',
              error_msg => "Cannot load module 'Redis'."
          );
          eval {
              $options{option_results}->{redis_server} .= ':6379' if ($options{option_results}->{redis_server} !~ /:\d+$/);
              $self->{redis_cnx} = Redis->new(
                  server => $options{option_results}->{redis_server}, 
                  eval $self->{redis_attributes}
              );
              if (defined($self->{redis_cnx}) && 
                  defined($options{option_results}->{redis_db}) &&
                  $options{option_results}->{redis_db} ne ''
                  ) {
                  $self->{redis_cnx}->select($options{option_results}->{redis_db});
              }
          };
          if (!defined($self->{redis_cnx}) && !defined($options{option_results}->{failback_file})) {
              $self->{output}->add_option_msg(short_msg => "redis connection issue: $@");
              $self->{output}->option_exit();
          }
      }
  
      $self->{statefile_format} = 'json';
      if (defined($options{option_results}->{statefile_format}) && $options{option_results}->{statefile_format} ne '' && 
          $options{option_results}->{statefile_format} =~ /^(?:dumper|json|storable)$/) {
          $self->{statefile_format} = $options{option_results}->{statefile_format};
      } elsif (defined($options{default_format}) && $options{default_format} =~ /^(?:dumper|json|storable)$/) {
          $self->{statefile_format} = $options{default_format};
      }
  
      if (defined($options{option_results}->{statefile_storable})) {
          $self->{statefile_format} = 'storable';
      }
  
      if ($self->{statefile_format} eq 'dumper') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'Safe', 
              no_quit => 1
          );
          $self->{safe} = Safe->new();
          $self->{safe}->share('$datas');
      } elsif ($self->{statefile_format} eq 'storable') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Storable',
              error_msg => "Cannot load module 'Storable'."
          );
      } elsif ($self->{statefile_format} eq 'json') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'JSON::XS',
              error_msg => "Cannot load module 'JSON::XS'."
          );
      }
  
      $self->{statefile_cipher} = defined($options{option_results}->{statefile_cipher}) && $options{option_results}->{statefile_cipher} ne '' ?    
          $options{option_results}->{statefile_cipher} : 'AES';
      $self->{statefile_key} = defined($options{option_results}->{statefile_key}) && $options{option_results}->{statefile_key} ne '' ?    
          $options{option_results}->{statefile_key} : '';
  
      if ($self->{statefile_key} ne '') {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Crypt::Mode::CBC',
              error_msg => "Cannot load module 'Crypt::Mode::CBC'."
          );
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Crypt::PRNG',
              error_msg => "Cannot load module 'Crypt::PRNG'."
          );
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'MIME::Base64',
              error_msg => "Cannot load module 'MIME::Base64'."
          );
      }
  
      $self->{statefile_dir} = $options{option_results}->{statefile_dir};
      if (defined($self->{statefile_dir})
              && $self->{statefile_dir} ne $default_dir
              && defined($options{option_results}->{statefile_concat_cwd})
      ) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'Cwd',
              error_msg => "Cannot load module 'Cwd'."
          );
          $self->{statefile_dir} = Cwd::cwd() . '/' . $self->{statefile_dir};
      }
  
      $self->{$_} = $options{option_results}->{$_} foreach qw/statefile_suffix memexpiration/;
  }
  
  sub error {
      my ($self) = shift;
  
      if (@_) {
          $self->{error} = $_[0];
      }
      return $self->{error};
  }
  
  sub get_key {
      my ($self, %options) = @_;
  
      my $key = $options{key};
  
      {
          use bytes;
  
          my $size = length($key);
          my $minsize = Crypt::Cipher->min_keysize($options{cipher});
          if ($minsize > $size) {
              $key .= "0" x ($minsize - $size);
          }
      }
  
      return $key;
  }
  
  sub decrypt {
      my ($self, %options) = @_;
  
      return (1, $options{data}) if (!defined($options{data}->{encrypted}));
  
      my $plaintext;
      eval {
          my $cipher = Crypt::Mode::CBC->new($options{data}->{cipher}, 1);
          $plaintext = $cipher->decrypt(
              MIME::Base64::decode_base64($options{data}->{ciphertext}),
              $self->get_key(key => $self->{statefile_key}, cipher => $options{data}->{cipher}),
              pack('H*', $options{data}->{iv})
          );
      };
  
      if ($@) {
          return 0;
      }
  
      return $self->deserialize(data => $plaintext, nocipher => 1);
  }
  
  sub deserialize {
      my ($self, %options) = @_;
  
      my $deserialized = '';
      if ($self->{statefile_format} eq 'dumper') {
          our $datas;
          $self->{safe}->reval($options{data}, 1);
          return 0 if ($@);
  
          $deserialized = $datas;
      } elsif ($self->{statefile_format} eq 'storable') {
          eval {
              $deserialized = Storable::thaw($options{data});
          };
          return 0 if ($@);
      } elsif ($self->{statefile_format} eq 'json') {
          eval {
              $deserialized = JSON::XS->new->decode($options{data});
          };
          return 0 if ($@);
      }
  
      return 0 if (!defined($deserialized) || ref($deserialized) ne 'HASH');
  
      my $rv = 1;
      if ($self->{statefile_key} ne '' && !defined($options{nocipher})) {
          ($rv, $deserialized) = $self->decrypt(data => $deserialized);
      }
  
      return ($rv, $deserialized);
  }
  
  sub slurp {
      my ($self, %options) = @_;
  
      my $content = do {
          local $/ = undef;
          if (!open my $fh, '<', $options{file}) {
              $self->{output}->add_option_msg(short_msg => "Could not open file $options{file}: $!");
              $self->{output}->option_exit();
          }
          <$fh>;
      };
  
      return $content;
  }
  
  sub read {
      my ($self, %options) = @_;
      $self->{statefile_suffix} = defined($options{statefile_suffix}) ? $options{statefile_suffix} : $self->{statefile_suffix};
      $self->{statefile_dir} = defined($options{statefile_dir}) ? $options{statefile_dir} : $self->{statefile_dir};
      $self->{statefile} = defined($options{statefile}) ? $options{statefile} . $self->{statefile_suffix} : $self->{statefile};
      $self->{no_quit} = defined($options{no_quit}) && $options{no_quit} == 1 ? 1 : 0;
  
      my ($data, $rv);
  
      if (defined($self->{memcached})) {
          # if "SUCCESS" or "NOT FOUND" is ok. Other with use the file
          my $val = Memcached::libmemcached::memcached_get($self->{memcached}, $self->{statefile_dir} . '/' . $self->{statefile});
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS|NOT FOUND$/i) {
              $self->{memcached_ok} = 1;
              if (defined($val)) {
                  ($rv, $data) = $self->deserialize(data => $val);
                  $self->{datas} = defined($data) ? $data : {};
                  return $rv;
              }
  
              return 0;
          }
      }
  
      if (defined($self->{redis_cnx})) {
          my $val = $self->{redis_cnx}->get($self->{statefile_dir} . "/" . $self->{statefile});
          if (defined($val)) {
              ($rv, $data) = $self->deserialize(data => $val);
              $self->{datas} = defined($data) ? $data : {};
              return $rv;
          }
  
          return 0;
      }
  
      if (! -e $self->{statefile_dir} . '/' . $self->{statefile}) {
          if (! -w $self->{statefile_dir} || ! -x $self->{statefile_dir}) {
              $self->error(1);
              $self->{output}->add_option_msg(short_msg =>  "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write/exec permissions on directory.");
              if ($self->{no_quit} == 0) {
                  $self->{output}->option_exit();
              }
          }
          return 0;
      } elsif (! -w $self->{statefile_dir} . '/' . $self->{statefile}) {
          $self->error(1);
          $self->{output}->add_option_msg(short_msg => "Cannot write statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'. Need write permissions on file.");
          if ($self->{no_quit} == 0) {
              $self->{output}->option_exit();
          }
          return 1;
      } elsif (! -s $self->{statefile_dir} . '/' . $self->{statefile}) {
          # Empty file. Not a problem. Maybe plugin not manage not values
          return 0;
      }
  
      $data = $self->slurp(file => $self->{statefile_dir} . '/' . $self->{statefile});
      ($rv, $data) = $self->deserialize(data => $data);
      $self->{datas} = defined($data) ? $data : {};
  
      return $rv;
  }
  
  sub get_string_content {
      my ($self, %options) = @_;
  
      return Data::Dumper::Dumper($self->{datas});
  }
  
  sub get {
      my ($self, %options) = @_;
  
      if (defined($self->{datas}->{ $options{name} })) {
          return $self->{datas}->{ $options{name} };
      }
      return undef;
  }
  
  sub encrypt {
      my ($self, %options) = @_;
  
      my $data = {
          encrypted => 1,
          cipher => $self->{statefile_cipher},
          iv => Crypt::PRNG::random_bytes_hex(16)
      };
  
      eval {
          my $cipher = Crypt::Mode::CBC->new($self->{statefile_cipher}, 1);
          $data->{ciphertext} = MIME::Base64::encode_base64(
              $cipher->encrypt(
                  $options{data},
                  $self->get_key(key => $self->{statefile_key}, cipher => $self->{statefile_cipher}),
                  pack('H*', $data->{iv})
              ),
              ''
          );
      };
      if ($@) {
          $self->{output}->add_option_msg(short_msg => "cipher encrypt error: $@");
          $self->{output}->option_exit();
      }
  
      return $self->serialize(data => $data, nocipher => 1);
  }
  
  sub serialize {
      my ($self, %options) = @_;
  
      my $serialized = '';
      if ($self->{statefile_format} eq 'dumper') {
          $serialized = Data::Dumper->Dump([$options{data}], ['datas']);
      } elsif ($self->{statefile_format} eq 'storable') {
          $serialized = Storable::freeze($options{data});
      } elsif ($self->{statefile_format} eq 'json') {
          eval {
              $serialized = JSON::XS->new->encode($options{data});
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg =>  "Cannot serialize statefile '" . $self->{statefile_dir} . "/" . $self->{statefile} . "'");
              $self->{output}->option_exit();
          }
      }
  
      if ($self->{statefile_key} ne '' && !defined($options{nocipher})) {
          $serialized = $self->encrypt(data => $serialized);
      }
  
      return $serialized;
  }
  
  sub write {
      my ($self, %options) = @_;
  
      my $serialized = $self->serialize(data => $options{data});
      if ($self->{memcached_ok} == 1) {
          Memcached::libmemcached::memcached_set(
              $self->{memcached},
              $self->{statefile_dir} . '/' . $self->{statefile}, 
              $serialized,
              $self->{memexpiration}
          );
          if (defined($self->{memcached}->errstr) && $self->{memcached}->errstr =~ /^SUCCESS$/i) {
              return ;
          }
      }
      if (defined($self->{redis_cnx})) {
          return if (defined($self->{redis_cnx}->set(
              $self->{statefile_dir} . '/' . $self->{statefile},
              $serialized,
              'EX', $self->{memexpiration}))
          );
      }
      open FILE, '>', $self->{statefile_dir} . '/' . $self->{statefile};
      print FILE $serialized;
      close FILE;
  }
  
  1;
  
  
  =head1 NAME
  
  centreon::plugins::statefile - A module for managing state files with various storage backends.
  
  =head1 SYNOPSIS
  
      use centreon::plugins::statefile;
  
      my $statefile = centreon::plugins::statefile->new(
          output => $output,
          options => $options
      );
  
      $statefile->check_options(option_results => $option_results);
      $statefile->read(statefile => 'my_statefile');
      my $data = $statefile->get(name => 'some_key');
      $statefile->write(data => { some_key => 'some_value' });
  
  =head1 DESCRIPTION
  
  The `centreon::plugins::statefile` module provides methods to manage state files (files storing the data to keep from an
  execution to the next one), supporting various storage backends such as local files, Memcached, and Redis. It also supports encryption and different serialization formats.
  
  =head1 METHODS
  
  =head2 new
  
      my $statefile = centreon::plugins::statefile->new(%options);
  
  Creates a new `centreon::plugins::statefile` object.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<output> - An C<centreon::plugins::output> object to log error messages.
  
  =item * C<options> - A C<centreon::plugins::options> object to add command-line options.
  
  =back
  
  =back
  
  =head2 check_options
  
      $statefile->check_options(%options);
  
  Checks and processes the provided options.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<option_results> - A hash of option results.
  
  =back
  
  =back
  
  =head2 read
  
      $statefile->read(%options);
  
  Reads the state file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<statefile> - The name of the state file to read.
  
  =item * C<statefile_suffix> - An optional suffix for the state file name.
  
  =item * C<statefile_dir> - An optional directory for the state file.
  
  =item * C<no_quit> - An optional flag to prevent the program from exiting on error.
  
  =back
  
  =back
  
  =head2 write
  
      $statefile->write(%options);
  
  Writes data to the state file.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<data> - A hash reference containing the data to write.
  
  =back
  
  =back
  
  =head2 get
  
      my $value = $statefile->get(%options);
  
  Retrieves a value from the state file data.
  
  =over 4
  
  =item * C<%options> - A hash of options. The following keys are supported:
  
  =over 8
  
  =item * C<name> - The key name of the value to retrieve.
  
  =back
  
  =back
  
  =head2 get_string_content
  
      my $string = $statefile->get_string_content();
  
  Returns the state file data as a string.
  
  =head2 error
  
      my $error = $statefile->error();
  
  Gets or sets the error state.
  
  =over 4
  
  =item * C<$error> - An optional error value to set.
  
  =back
  
  =head1 EXAMPLES
  
  =head2 Creating a Statefile Object
  
      use centreon::plugins::statefile;
  
      my $statefile = centreon::plugins::statefile->new(
          output => $output,
          options => $options
      );
  
  =head2 Checking Options
  
      $statefile->check_options(option_results => $option_results);
  
  =head2 Reading a Statefile
  
      $statefile->read(statefile => 'my_statefile');
  
  =head2 Writing to a Statefile
  
      $statefile->write(data => { some_key => 'some_value' });
  
  =head2 Retrieving a Value
  
      my $value = $statefile->get(name => 'some_key');
  
  =head2 Getting Statefile Data as a String
  
      my $string = $statefile->get_string_content();
  
  =head1 AUTHOR
  
  Centreon
  
  =head1 LICENSE
  
  Licensed under the Apache License, Version 2.0.
  
  =cut
  
  =head1 RETENTION OPTIONS
  
  =over 8
  
  =item B<--memcached>
  
  Memcached server to use (only one server).
  
  =item B<--redis-server>
  
  Redis server to use (only one server). Syntax: address[:port]
  
  =item B<--redis-attribute>
  
  Set Redis Options (--redis-attribute="cnx_timeout=5").
  
  =item B<--redis-db>
  
  Set Redis database index.
  
  =item B<--failback-file>
  
  Fall back on a local file if Redis connection fails.
  
  =item B<--memexpiration>
  
  Time to keep data in seconds (default: 86400).
  
  =item B<--statefile-dir>
  
  Define the cache directory (default: '/var/lib/centreon/centplugins').
  
  =item B<--statefile-suffix>
  
  Define a suffix to customize the statefile name (default: '').
  
  =item B<--statefile-concat-cwd>
  
  If used with the '--statefile-dir' option, the latter's value will be used as
  a sub-directory of the current working directory.
  Useful on Windows when the plugin is compiled, as the file system and permissions are different from Linux.
  
  =item B<--statefile-format>
  
  Define the format used to store the cache. Available formats: 'dumper', 'storable', 'json' (default).
  
  =item B<--statefile-key>
  
  Define the key to encrypt/decrypt the cache.
  
  =item B<--statefile-cipher>
  
  Define the cipher algorithm to encrypt the cache (default: 'AES').
  
  =back
  
  =head1 DESCRIPTION
  
  B<statefile>.
  
  =cut
CENTREON_PLUGINS_STATEFILE

$fatpacked{"centreon/plugins/templates/catalog_functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS';
  #
  # Copyright 2018 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::catalog_functions;
  
  use strict;
  use warnings;
  use Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(catalog_status_threshold catalog_status_threshold_ng catalog_status_calc);
  
  sub catalog_status_threshold {
      my ($self, %options) = @_;
      my $status = 'ok';
  
      my $label = $self->{label};
      $label =~ s/-/_/g;
      if (defined($self->{instance_mode}->{option_results}->{'ok_' . $label}) && $self->{instance_mode}->{option_results}->{'ok_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'ok_' . $label})) {
          $status = 'ok';
      } elsif (defined($self->{instance_mode}->{option_results}->{'critical_' . $label}) && $self->{instance_mode}->{option_results}->{'critical_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'critical_' . $label})) {
          $status = 'critical';
      } elsif (defined($self->{instance_mode}->{option_results}->{'warning_' . $label}) && $self->{instance_mode}->{option_results}->{'warning_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'warning_' . $label})) {
          $status = 'warning';
      } elsif (defined($self->{instance_mode}->{option_results}->{'unknown_' . $label}) && $self->{instance_mode}->{option_results}->{'unknown_' . $label} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'unknown_' . $label})) {
          $status = 'unknown';
      }
  
      return $status;
  }
  
  sub catalog_status_threshold_ng {
      my ($self, %options) = @_;
      my $status = 'ok';
      my $message;
  
      if (defined($self->{instance_mode}->{option_results}->{'critical-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'critical-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'critical-' . $self->{label}})) {
          $status = 'critical';
      } elsif (defined($self->{instance_mode}->{option_results}->{'warning-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'warning-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'warning-' . $self->{label}})) {
          $status = 'warning';
      } elsif (defined($self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}}) && $self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}} ne '' &&
          $self->eval(value => $self->{instance_mode}->{option_results}->{'unknown-' . $self->{label}})) {
          $status = 'unknown';
      }
  
      return $status;
  }
  
  sub catalog_status_calc {
      my ($self, %options) = @_;
  
      foreach (keys %{$options{new_datas}}) {
          if (/^\Q$self->{instance}\E_(.*)/) {
              $self->{result_values}->{$1} = $options{new_datas}->{$_};
          }
      }
  }
  
  1;
  
  
CENTREON_PLUGINS_TEMPLATES_CATALOG_FUNCTIONS

$fatpacked{"centreon/plugins/templates/counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_COUNTER';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  
  package centreon::plugins::templates::counter;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use centreon::plugins::values;
  use centreon::plugins::misc;
  use JSON::XS;
  
  my $sort_subs = {
      num => sub { $a <=> $b },
      cmp => sub { $a cmp $b },
  };
  
  sub set_counters {
      my ($self, %options) = @_;
      
      if (!defined($self->{maps_counters})) {
          $self->{maps_counters} = {};
      }
      
      $self->{maps_counters_type} = [];
      
      # 0 = mode total
      # 1 = mode instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'global', type => 0, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #};
  
      #$self->{maps_counters}->{global} = [
      #    { label => 'client', set => {
      #           key_values => [ { name => 'client' } ],
      #           output_template => 'Current client connections : %s',
      #           perfdatas => [
      #               { label => 'Client', value => 'client', template => '%s', 
      #                 min => 0, unit => 'con' },
      #           ],
      #       }
      #    },
      #];
      
      # Example for instances
      #push @{$self->{maps_counters_type}}, { 
      #    name => 'cpu', type => 1, message_separator => ', ', cb_prefix_output => undef, cb_init => undef,
      #    message_multiple => 'All CPU usages are ok',
      #};    
  }
  
  sub get_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          return $self->can($options{method_name});
      }
      
      return undef;
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
      
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
      
      return undef;
  }
  
  sub get_threshold_prefix {
      my ($self, %options) = @_;
      
      my $prefix = '';
      END_LOOP: foreach (@{$self->{maps_counters_type}}) {
          if ($_->{name} eq $options{name}) {
              $prefix = 'instance-' if ($_->{type} == 1);
              last;
          }
          
          if ($_->{type} == 3) {
              foreach (@{$_->{group}}) {
                  if ($_->{name} eq $options{name}) {
                      $prefix = 'instance-' if ($_->{type} == 0);
                      $prefix = 'subinstance-' if ($_->{type} == 1);
                      last END_LOOP;
                  }
              }
          }
      }
  
      return $prefix;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'filter-counters-block:s' => { name => 'filter_counters_block' },
          'filter-counters:s'       => { name => 'filter_counters' },
          'display-ok-counters:s'   => { name => 'display_ok_counters' },
          'list-counters'           => { name => 'list_counters' }
      });
      $self->{statefile_value} = undef;
      if (defined($options{statefile}) && $options{statefile}) {
          centreon::plugins::misc::mymodule_load(
              output => $self->{output},
              module => 'centreon::plugins::statefile',
              error_msg => "Cannot load module 'centreon::plugins::statefile'."
          );
          $self->{statefile_value} = centreon::plugins::statefile->new(%options);
      }
  
      $self->{maps_counters} = {} if (!defined($self->{maps_counters}));
      $self->set_counters(%options);
      
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              my $label = $_->{label};
              my $thlabel = $label;
              if ($self->{output}->use_new_perfdata() && defined($_->{nlabel})) {
                  $label = $_->{nlabel};
                  $thlabel = $self->get_threshold_prefix(name => $key) . $label;
              }
              $thlabel =~ s/\./-/g;
  
              if (!defined($_->{threshold}) || $_->{threshold} != 0) {
                  $options{options}->add_options(arguments => {
                      'unknown-' . $thlabel . ':s'  => { name => 'unknown-' . $thlabel, default => $_->{unknown_default} },
                      'warning-' . $thlabel . ':s'  => { name => 'warning-' . $thlabel, default => $_->{warning_default} },
                      'critical-' . $thlabel . ':s' => { name => 'critical-' . $thlabel, default => $_->{critical_default} }
                  });
  
                  if (defined($_->{nlabel})) {
                      $options{options}->add_options(arguments => {
                          'unknown-' . $_->{label} . ':s'  => { name => 'unknown-' . $_->{label}, redirect => 'unknown-' . $thlabel },
                          'warning-' . $_->{label} . ':s'  => { name => 'warning-' . $_->{label}, redirect => 'warning-' . $thlabel },
                          'critical-' . $_->{label} . ':s' => { name => 'critical-' . $_->{label}, redirect => 'critical-' . $thlabel }
                      });
                  }
              }
  
              $_->{obj} = centreon::plugins::values->new(
                  statefile => $self->{statefile_value},
                  output => $self->{output}, perfdata => $self->{perfdata},
                  label => $_->{label}, nlabel => $_->{nlabel}, thlabel => $thlabel
              );
              $_->{obj}->set(%{$_->{set}});
          }
      }
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL COUNTERS OPTIONS', once => 1) if $options{display_template_help};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (defined($self->{option_results}->{list_counters})) {
          my $list_counter = '';
          my $th_counter = '';
          my $counters;
          foreach my $key (keys %{$self->{maps_counters}}) {
              foreach (@{$self->{maps_counters}->{$key}}) {
                  $counters->{metrics}->{$_->{label}}->{nlabel} ="";
                  $counters->{metrics}->{$_->{label}}->{min}="";
                  $counters->{metrics}->{$_->{label}}->{max}="";
                  $counters->{metrics}->{$_->{label}}->{unit}="";
                  $counters->{metrics}->{$_->{label}}->{output_template}="";
                  if(defined($_->{nlabel})) {
                      $counters->{metrics}->{$_->{label}}->{nlabel} = $_->{nlabel};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{min})) {
                      $counters->{metrics}->{$_->{label}}->{min} = $_->{set}->{perfdatas}->[0]->{min};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{max})) {
                      $counters->{metrics}->{$_->{label}}->{max} = $_->{set}->{perfdatas}->[0]->{max};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{unit})) {
                      $counters->{metrics}->{$_->{label}}->{unit} = $_->{set}->{perfdatas}->[0]->{unit};
                  }
                  if(defined($_->{set}->{perfdatas}->[0]->{template})) {
                      $counters->{metrics}->{$_->{label}}->{output_template} = $_->{set}->{perfdatas}->[0]->{template};
                  }
                  my $label = $_->{label};
                  $label =~ s/-//g;
                  $list_counter .= $_->{label}." ";
                  $th_counter .= " --warning-$_->{label}='\$_SERVICEWARNING" . uc($label) . "\$' --critical-$_->{label}='\$_SERVICECRITICAL" . uc($label) . "\$'";
  
              }
          }
          $counters->{"counter list"}=$list_counter;
          $counters->{"pack configuration"}=$th_counter." \$_SERVICEEXTRAOPTIONS\$";
  
          my $result_data ="";
          eval {
              $result_data = JSON::XS->new->indent->space_after->canonical->utf8->encode($counters);
          };
          if ($@) {
              $self->{output}->add_option_msg(short_msg => "Cannot use \$counters as it is a malformed JSON: " . $@);
              $self->{output}->option_exit();
          }
  
          $self->{output}->output_add(short_msg => "counter list: ".$list_counter);
          $self->{output}->output_add(long_msg => $result_data);
          $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1);
          $self->{output}->exit();
      }
  
      my $change_macros_opt = [];
      foreach my $key (keys %{$self->{maps_counters}}) {
          foreach (@{$self->{maps_counters}->{$key}}) {
              push @$change_macros_opt, 'unknown-' . $_->{label}, 'warning-' . $_->{label}, 'critical-' . $_->{label}
                  if (defined($_->{type}) && $_->{type} == 2);
              $_->{obj}->{instance_mode} = $self;
              $_->{obj}->init(option_results => $self->{option_results}) if (!defined($_->{type}) || $_->{type} != 2);
          }
      }
  
      $self->change_macros(macros => $change_macros_opt) if (scalar(@$change_macros_opt) > 0);
  
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->check_options(%options);
      }
  }
  
  sub run_global {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
      # Can be set when it comes from type 3 counters
      my $called_multiple = defined($options{called_multiple}) && $options{called_multiple} == 1 ? 1 : 0;
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? 1 : 0;
      my $force_instance = defined($options{force_instance}) ? $options{force_instance} : undef;
  
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
      my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
      my @exits;
      foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
          my $obj = $_->{obj};
  
          next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
              $_->{label} !~ /$self->{option_results}->{filter_counters}/);
  
          $obj->set(instance => defined($force_instance) ? $force_instance : $options{config}->{name});
  
          my ($value_check) = $obj->execute(new_datas => $self->{new_datas}, values => $self->{$options{config}->{name}});
  
          next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
          if ($value_check != 0) {
              $long_msg .= $long_msg_append . $obj->output_error();
              $long_msg_append = $message_separator;
              next;
          }
          my $exit2 = $obj->threshold_check();
          push @exits, $exit2;
  
          my $output = $obj->output();
          if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
              (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
               $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
              $long_msg .= $long_msg_append . $output;
              $long_msg_append = $message_separator;
          }
  
          if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
              $short_msg .= $short_msg_append . $output;
              $short_msg_append = $message_separator;
          }
  
          $obj->perfdata(extra_instance => $multiple_parent);
      }
  
      my ($prefix_output, $suffix_output);
      $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance_value => $self->{$options{config}->{name}}) 
          if (defined($options{config}->{cb_prefix_output}));
      $prefix_output = '' if (!defined($prefix_output));
  
      $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}, instance_value => $self->{$options{config}->{name}}) 
          if (defined($options{config}->{cb_suffix_output}));
      $suffix_output = '' if (!defined($suffix_output));
  
      if ($called_multiple == 1 && $long_msg ne '') {
          $self->{output}->output_add(long_msg => $options{indent_long_output} . $prefix_output. $long_msg . $suffix_output);
      }
  
      my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
      if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
          if ($called_multiple == 0) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          } else {
              $self->run_multiple_prefix_output(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
      } else {
          if ($long_msg ne '' && $multiple_parent == 0) {
              if ($called_multiple == 0) {
                  $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output)
                      if ($display_short == 1);
              } else {
                  $self->run_multiple_prefix_output(
                      severity => 'ok',
                      short_msg => $prefix_output . $long_msg . $suffix_output
                  ) if ($display_short == 1);
              }
          }
      }
  }
  
  sub run_instances {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $cb_init_counters = $self->get_callback(method_name => $options{config}->{cb_init_counters});
      my $display_status_lo = defined($options{display_status_long_output}) && $options{display_status_long_output} == 1 ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
      my $display_long = (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0) ? 1 : 0;
      my $resume = defined($options{resume}) && $options{resume} == 1 ? 1 : 0;
      my $no_message_multiple = 1;
      
      $self->{lproblems} = 0;
      $self->{multiple} = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $self->{multiple} = 0;
      }
      
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator}: ', ';
  
      # The default sort method is cmp (string comparison)
      my $sort_method = 'cmp';
      # If configured otherwise, we take it from the counter (only other method is 'num' for '<=>')
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
  
      # In the absence of sort_attribute the sort method is set now
      my $sort_sub = $sort_subs->{$sort_method};
  
      # If sort_attribute is set, then we'll redefine how things are sorted depending on the specified sort_method
      if (defined($options{config}->{sort_attribute})) {
          my $sort_attribute = $options{config}->{sort_attribute};
          if ($sort_method eq 'cmp') {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} cmp $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          } else {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} <=> $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          }
      }
  
      # Now the loop begins with the desired sorting method
      foreach my $id (sort { $sort_sub->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
  
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              next if ($cb_init_counters && $self->$cb_init_counters(%$_) == 1);
  
              $no_message_multiple = 0;
              $obj->set(instance => $id);
          
              my ($value_check) = $obj->execute(
                  new_datas => $self->{new_datas},
                  values => $self->{$options{config}->{name}}->{$id}
              );
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
              
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $self->{lproblems}++;
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              $obj->perfdata(extra_instance => $self->{multiple});
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
          
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          # in mode grouped, we don't display 'ok'
          my $debug = 0;
          $debug = 1 if ($display_status_lo == 1 && $self->{output}->is_status(value => $exit, compare => 'OK', litteral => 1));
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => ($display_status_lo == 1 ? lc($exit) . ': ' : '') . $prefix_output . $long_msg . $suffix_output, debug => $debug)
                  if ($display_long == 1);
          }
          if ($resume == 1) {
              $self->{most_critical_instance} = $self->{output}->get_most_critical(status => [ $self->{most_critical_instance},  $exit ]);  
              next;
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
          
          if ($self->{multiple} == 0)  {
              $self->{output}->output_add(short_msg => $prefix_output . $long_msg . $suffix_output)
                  if ($display_short == 1);
          }
      }
      
      if ($no_message_multiple == 0 && $self->{multiple} == 1 && $resume == 0) {
          $self->{output}->output_add(short_msg => $options{config}->{message_multiple})
              if ($display_short == 1);
      }
  }
  
  sub run_group {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      return if (scalar(keys %{$self->{$options{config}->{name}}}) <= 0);
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
      
      if ($multiple == 1) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => $options{config}->{message_multiple}
          );
      }
  
      my $format_output = defined($options{config}->{format_output}) ? $options{config}->{format_output} : '%s problem(s) detected';
  
      my ($global_exit, $total_problems) = ([], 0);
      foreach my $id (sort keys %{$self->{$options{config}->{name}}}) {
          $self->{most_critical_instance} = 'ok';
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(
                  long_msg => $self->call_object_callback(
                      method_name => $options{config}->{cb_long_output},
                      instance => $id,
                      instance_value => $self->{$options{config}->{name}}->{$id}
                  )
              );
          }
  
          foreach my $group (@{$options{config}->{group}}) {
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$id}->{$group->{name}};
              
              # we resume datas
              $self->run_instances(config => $group, display_status_long_output => 1, resume => 1);
              
              push @{$global_exit}, $self->{most_critical_instance};
              $total_problems += $self->{lproblems};
              
              my $prefix_output;
              $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
                  if (defined($options{config}->{cb_prefix_output}));
              $prefix_output = '' if (!defined($prefix_output));
              
              if ($multiple == 0 && (!defined($group->{display}) || $group->{display} != 0)) {
                  $self->{output}->output_add(
                      severity => $self->{most_critical_instance},
                      short_msg => sprintf("${prefix_output}" . $format_output, $self->{lproblems})
                  );
              }
          }
      }
      
      if ($multiple == 1) {
          my $exit = $self->{output}->get_most_critical(status => [ @{$global_exit} ]);
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->{output}->output_add(
                  severity => $exit,
                  short_msg => sprintf($format_output, $total_problems)
              );
          }
      }
      
      if (defined($options{config}->{display_counter_problem})) {
          $self->{output}->perfdata_add(
              label => $options{config}->{display_counter_problem}->{label},
              nlabel => $options{config}->{display_counter_problem}->{nlabel},
              unit => $options{config}->{display_counter_problem}->{unit},
              value => $total_problems,
              min => $options{config}->{display_counter_problem}->{min}, max => $options{config}->{display_counter_problem}->{max}
          );
      }
  }
  
  sub run_multiple_instances {
      my ($self, %options) = @_;
  
      return undef if (defined($self->{option_results}->{filter_counters_block}) && $self->{option_results}->{filter_counters_block} ne '' 
          && $options{config}->{name} =~ /$self->{option_results}->{filter_counters_block}/);
      return undef if (defined($options{config}->{cb_init}) && $self->call_object_callback(method_name => $options{config}->{cb_init}) == 1);
      my $use_new_perfdata = $self->{output}->use_new_perfdata();
      my $multiple_parent = defined($options{multiple_parent}) && $options{multiple_parent} == 1 ? $options{multiple_parent} : 0;
      my $indent_long_output = defined($options{indent_long_output}) ? $options{indent_long_output} : '';
      my $no_message_multiple = 1;
      my $display_long = (!defined($options{config}->{display_long}) || $options{config}->{display_long} != 0) ? 1 : 0;
      my $display_short = (!defined($options{config}->{display_short}) || $options{config}->{display_short} != 0) ? 1 : 0;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
  
      my $message_separator = defined($options{config}->{message_separator}) ? 
          $options{config}->{message_separator} : ', ';
  
      # The default sort method is cmp (string comparison)
      my $sort_method = 'cmp';
      # If configured otherwise, we take it from the counter (only other method is 'num' for '<=>')
      $sort_method = $options{config}->{sort_method}
          if (defined($options{config}->{sort_method}));
  
      # In the absence of sort_attribute the sort method is set now
      my $sort_sub = $sort_subs->{$sort_method};
  
      # If sort_attribute is set, then we'll redefine how things are sorted depending on the specified sort_method
      if (defined($options{config}->{sort_attribute})) {
          my $sort_attribute = $options{config}->{sort_attribute};
          if ($sort_method eq 'cmp') {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} cmp $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          } else {
              $sort_sub = sub { $self->{$options{config}->{name}}->{$a}->{$sort_attribute} <=> $self->{$options{config}->{name}}->{$b}->{$sort_attribute}};
          }
      }
  
      # Now the loop begins with the desired sorting method
      foreach my $id (sort { $sort_sub->() } keys %{$self->{$options{config}->{name}}}) {
          my ($short_msg, $short_msg_append, $long_msg, $long_msg_append) = ('', '', '', '');
          my @exits = ();
          foreach (@{$self->{maps_counters}->{$options{config}->{name}}}) {
              my $obj = $_->{obj};
              
              next if (defined($self->{option_results}->{filter_counters}) && $self->{option_results}->{filter_counters} ne '' &&
                  $_->{label} !~ /$self->{option_results}->{filter_counters}/);
              
              my $instance = $id;
              if ($use_new_perfdata || ($multiple_parent == 1 && $multiple == 1)) {
                  $instance = $options{instance_parent} . ($self->{output}->get_instance_perfdata_separator()) . $id;
              } elsif ($multiple_parent == 1 && $multiple == 0) {
                  $instance = $options{instance_parent};
              }
              
              $no_message_multiple = 0;
              $obj->set(instance => $instance);
          
              my ($value_check) = $obj->execute(
                  new_datas => $self->{new_datas},
                  values => $self->{$options{config}->{name}}->{$id}
              );
              next if (defined($options{config}->{skipped_code}) && defined($options{config}->{skipped_code}->{$value_check}));
              if ($value_check != 0) {
                  $long_msg .= $long_msg_append . $obj->output_error();
                  $long_msg_append = $message_separator;
                  next;
              }
              my $exit2 = $obj->threshold_check();
              push @exits, $exit2;
  
              my $output = $obj->output();
              if (!defined($_->{display_ok}) || $_->{display_ok} != 0 ||
                  (defined($self->{option_results}->{display_ok_counters}) && $self->{option_results}->{display_ok_counters} ne '' &&
                   $_->{label} =~ /$self->{option_results}->{display_ok_counters}/)) {
                  $long_msg .= $long_msg_append . $output;
                  $long_msg_append = $message_separator;
              }
  
              if (!$self->{output}->is_status(litteral => 1, value => $exit2, compare => 'ok')) {
                  $short_msg .= $short_msg_append . $output;
                  $short_msg_append = $message_separator;
              }
              
              if ($multiple_parent == 1 && $multiple == 0) {
                  $obj->perfdata(extra_instance => 1);
              } else {
                  $obj->perfdata(extra_instance => $multiple);
              }
          }
  
          my ($prefix_output, $suffix_output);
          $prefix_output = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $id, instance_value => $self->{$options{config}->{name}}->{$id})
              if (defined($options{config}->{cb_prefix_output}));
          $prefix_output = '' if (!defined($prefix_output));
  
          $suffix_output = $self->call_object_callback(method_name => $options{config}->{cb_suffix_output}) 
          if (defined($options{config}->{cb_suffix_output}));
          $suffix_output = '' if (!defined($suffix_output));
  
          my $exit = $self->{output}->get_most_critical(status => [ @exits ]);
          if (scalar @{$self->{maps_counters}->{$options{config}->{name}}} > 0 && $long_msg ne '') {
              $self->{output}->output_add(long_msg => $indent_long_output . $prefix_output . $long_msg . $suffix_output)
                  if ($display_long == 1);
          }
          
          if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
              $self->run_multiple_prefix_output(
                  severity => $exit,
                  short_msg => $prefix_output . $short_msg . $suffix_output
              );
          }
  
          if ($multiple == 0 && $multiple_parent == 0) {
              $self->run_multiple_prefix_output(severity => 'ok', short_msg => $prefix_output . $long_msg . $suffix_output)
                  if ($display_short == 1);
          }
      }
  
      if ($no_message_multiple == 0 && $multiple == 1 && $multiple_parent == 0) {
          $self->run_multiple_prefix_output(severity => 'ok', short_msg => $options{config}->{message_multiple})
              if ($display_short == 1);
      }
  }
  
  sub run_multiple_prefix_output {
      my ($self, %options) = @_;
      
      my %separator;
      if ($self->{prefix_multiple_output_done}->{lc($options{severity})} == 0) {
          $self->{output}->output_add(severity => $options{severity}, short_msg => $self->{prefix_multiple_output});
          $self->{prefix_multiple_output_done}->{lc($options{severity})} = 1;
          $separator{separator} = '';
      }
  
      $self->{output}->output_add(severity => $options{severity}, short_msg => $options{short_msg}, %separator);
  }
  
  sub run_multiple {
      my ($self, %options) = @_;
  
      my $multiple = 1;
      if (scalar(keys %{$self->{$options{config}->{name}}}) <= 1) {
          $multiple = 0;
      }
  
      if ($multiple == 1) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => $options{config}->{message_multiple}
          );
      }
  
      foreach my $instance (sort keys %{$self->{$options{config}->{name}}}) {
          if (defined($options{config}->{cb_long_output})) {
              $self->{output}->output_add(
                  long_msg => $self->call_object_callback(
                      method_name => $options{config}->{cb_long_output},
                      instance => $instance,
                      instance_value => $self->{$options{config}->{name}}->{$instance}
                  )
              );
          }
  
          $self->{prefix_multiple_output} = '';
          $self->{prefix_multiple_output_done} = { ok => 0, warning => 0, critical => 0, unknown => 0 };
          $self->{prefix_multiple_output} = $self->call_object_callback(method_name => $options{config}->{cb_prefix_output}, instance => $instance, instance_value => $self->{$options{config}->{name}}->{$instance})
               if (defined($options{config}->{cb_prefix_output}));
          my $indent_long_output = '';
          $indent_long_output = $options{config}->{indent_long_output}
              if (defined($options{config}->{indent_long_output}));
  
          foreach my $group (@{$options{config}->{group}}) {
              next if (!defined($self->{$options{config}->{name}}->{$instance}->{$group->{name}}));
              $self->{$group->{name}} = $self->{$options{config}->{name}}->{$instance}->{$group->{name}};
  
              if ($group->{type} == 1) {
                  $self->run_multiple_instances(config => $group, multiple_parent => $multiple, instance_parent => $instance, indent_long_output => $indent_long_output);
              } elsif ($group->{type} == 0) {
                  $self->run_global(
                      config => $group,
                      multiple_parent => $multiple,
                      called_multiple => 1,
                      force_instance => $instance,
                      indent_long_output => $indent_long_output
                  );
              }
          }
      }
  }
  
  sub read_statefile_key {
      my ($self, %options) = @_;
  
      $self->{statefile_value}->read(statefile => $self->{cache_name});
      return $self->{statefile_value}->get(name => $options{key});
  }
  
  sub set_timestamp {
      my ($self, %options) = @_;
  
      $self->{override_timestamp} = $options{timestamp};
  }
  
  sub run {
      my ($self, %options) = @_;
      
      $self->manage_selection(%options);
      
      $self->{new_datas} = undef;
      if (defined($self->{statefile_value})) {
          $self->{new_datas} = {};
          $self->{statefile_value}->read(statefile => $self->{cache_name}) if (defined($self->{cache_name}));
          $self->{new_datas}->{last_timestamp} = defined($self->{override_timestamp}) ? $self->{override_timestamp} : time();
      }
  
      foreach my $entry (@{$self->{maps_counters_type}}) {
          if ($entry->{type} == 0) {
              $self->run_global(config => $entry);
          } elsif ($entry->{type} == 1) {
              $self->run_instances(config => $entry);
          } elsif ($entry->{type} == 2) {
              $self->run_group(config => $entry);
          } elsif ($entry->{type} == 3) {
              $self->run_multiple(config => $entry);
          }
      }
  
      if (defined($self->{statefile_value})) {
          $self->{statefile_value}->write(data => $self->{new_datas});
      }
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      # example for snmp
      #use Digest::MD5 qw(md5_hex);
      #$self->{cache_name} = "choose_name_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
      #    (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  sub compat_threshold_counter {
      my ($self, %options) = @_;
  
      foreach ('warning', 'critical') {
          foreach my $th (@{$options{compat}->{th}}) {
              next if (!defined($options{option_results}->{$_ . '-' . $th->[0]}) || $options{option_results}->{$_ . '-' . $th->[0]} eq '');
  
              my $src_threshold = $options{option_results}->{$_ . '-' . $th->[0]};
              if (defined($options{compat}->{units}) && $options{compat}->{units} eq '%') {
                  $options{option_results}->{$_ . '-' . $th->[0]} = undef;
                  if (defined($options{compat}->{free})) {
                      $options{option_results}->{$_ . '-' . $th->[0]} = undef;
                      my ($status, $result) = centreon::plugins::misc::parse_threshold(threshold => $src_threshold);
                      next if ($status == 0);
  
                      my $tmp = { arobase => $result->{arobase}, infinite_pos => 0, infinite_neg => 0, start => $result->{start}, end => $result->{end} };
                      $tmp->{infinite_neg} = 1 if ($result->{infinite_pos} == 1);
                      $tmp->{infinite_pos} = 1 if ($result->{infinite_neg} == 1);
  
                      if ($result->{start} ne '' && $result->{infinite_neg} == 0) {
                          $tmp->{end} = 100 - $result->{start};
                      }
                      if ($result->{end} ne '' && $result->{infinite_pos} == 0) {
                          $tmp->{start} = 100 - $result->{end};
                      }
  
                      $options{option_results}->{$_ . '-' . $th->[1]->{prct}} = centreon::plugins::misc::get_threshold_litteral(%$tmp);
                  } else {
                      $options{option_results}->{$_ . '-' . $th->[1]->{prct}} = $src_threshold;
                  }
              } elsif (defined($options{compat}->{free})) {
                  $options{option_results}->{$_ . '-' . $th->[1]->{free}} = $options{option_results}->{$_ . '-' . $th->[0]};
                  $options{option_results}->{$_ . '-' . $th->[0]} = undef;
              }
          }
      }
  }
  
  sub change_macros {
      my ($self, %options) = @_;
  
      foreach (@{$options{macros}}) {
          if (defined($self->{option_results}->{$_}) && $self->{option_results}->{$_} ne '') {
              $self->{option_results}->{$_} =~ s/%\{(.*?)\}/\$values->{$1}/g;
          }
      }
  }
  
  sub custom_perfdata_instances {
      my ($self, %options) = @_;
  
      my $instances = [];
      foreach (split(/\s+/, $options{instances})) {
          while (/%\((.+?)\)/g) {
              my $name = $1;
              if (!defined($options{labels}->{$name})) {
                  $self->{output}->add_option_msg(short_msg => "option $options{option_name} unsupported label: %($name)");
                  $self->{output}->option_exit();
              }
  
              push @$instances, $name;
          }
      }
  
      if (scalar(@$instances) <= 0) {
          $self->{output}->add_option_msg(short_msg => "option $options{option_name} need at least one label");
          $self->{output}->option_exit();
      }
  
      return $instances;
  }
  
  1;
  
  
  =head1 GLOBAL COUNTERS OPTIONS
  
  Global options for counters.
  
  =over 8
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example to check SSL connections only : --filter-counters='^xxxx|yyyy$'
  
  =item B<--warning-*>
  
  Warning threshold.
  Can be: 'xxx', 'xxx'.
  
  =item B<--critical-*>
  
  Critical threshold.
  Can be: 'xxx', 'xxx'.
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_COUNTER

$fatpacked{"centreon/plugins/templates/hardware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_TEMPLATES_HARDWARE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::templates::hardware;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
  
      #$self->{regexp_threshold_numeric_check_section_option} = '';
      #$self->{cb_threshold_numeric_check_section_option} = 'callbackname';
  
      # Some callbacks 
      #$self->{cb_hook1} = 'callbackname'; # before the loads
      #$self->{cb_hook2} = 'callbackname'; # between loads and requests
      #$self->{cb_hook3} = 'callbackname'; # after requests
      #$self->{cb_hook4} = 'callbackname'; # after output
  
      # Example for threshold:
      #$self->{thresholds} = {
      #    fan => [
      #        ['bad', 'CRITICAL'],
      #        ['good', 'OK'],
      #        ['notPresent', 'OK'],
      #    ],
      #};
      
      # Unset the call to load components
      #$self->{components_exec_load} = 0;
  
      # Set the path_info
      #$self->{components_path} = 'network::xxxx::mode::components';
  
      # Set the components
      #$self->{components_module} = ['cpu', 'memory', ...];
  }
  
  sub call_object_callback {
      my ($self, %options) = @_;
  
      if (defined($options{method_name})) {
          my $method = $self->can($options{method_name});
          if ($method) {
              return $self->$method(%options);
          }
      }
  
      return undef;
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      $options{options}->add_options(arguments => {
          'component:s'            => { name => 'component', default => '.*' },
          'no-component:s'         => { name => 'no_component', default => 'critical' },
          'threshold-overload:s@'  => { name => 'threshold_overload' },
          'add-name-instance'      => { name => 'add_name_instance' },
          'no-component-count'     => { name => 'no_component_count' }
      });
  
      $self->{performance} = (defined($options{no_performance}) && $options{no_performance} == 1) ?
          0 : 1;
      if ($self->{performance} == 1) {
          $options{options}->add_options(arguments => {
              'warning:s@'  => { name => 'warning' },
              'critical:s@' => { name => 'critical' }
          });
      }
  
      $self->{filter_exclude} = (defined($options{no_filter_exclude}) && $options{no_filter_exclude} == 1) ?
          0 : 1;
      if ($self->{filter_exclude} == 1) {
          $options{options}->add_options(arguments => {
              'exclude:s'     => { name => 'exclude' },
              'filter:s@'     => { name => 'filter' }
          });
      }
      $self->{absent} = (defined($options{no_absent}) && $options{no_absent} == 1) ?
          0 : 1;
      if ($self->{absent} == 1) {
          $options{options}->add_options(arguments => {
              'absent-problem:s@' => { name => 'absent_problem' }
          });
      }
  
      $self->{load_components} = (defined($options{no_load_components}) && $options{no_load_components} == 1) ?
          0 : 1;
      $self->{components} = {};
      $self->{no_components} = undef;
  
      $self->{components_module} = [];
      $self->{components_exec_load} = 1;
      $self->set_system();
  
      $self->{count} = (defined($options{no_count}) && $options{no_count} == 1) ? 0 : 1;
      if ($self->{count} == 1) {
          foreach my $component (@{$self->{components_module}}) {
              $options{options}->add_options(arguments => {
                  'unknown-count-' . $component . ':s'  => { name => 'unknown_count_' . $component },
                  'warning-count-' . $component . ':s'  => { name => 'warning_count_' . $component },
                  'critical-count-' . $component . ':s' => { name => 'critical_count_' . $component }
              });
          }
      }
  
      $self->{request} = [];
  
      $options{options}->add_help(package => __PACKAGE__, sections => 'GLOBAL HARDWARE OPTIONS', once => 1) if $options{display_template_help};
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      # For compatibility both $self->{option_results}->{no_component} and $self->{no_components} are initialized.
      # If unset or empty the default value 'critical' is used.
      $self->{option_results}->{no_component} = $self->{no_components} = $self->{option_results}->{no_component} || 'critical';
  
      if ($self->{filter_exclude} == 1) {
          $self->{filter} = [];
          foreach my $val (@{$self->{option_results}->{filter}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{filter}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
  
      if ($self->{absent} == 1) {
          $self->{absent_problem} = [];
          foreach my $val (@{$self->{option_results}->{absent_problem}}) {
              next if (!defined($val) || $val eq '');
              my @values = split (/,/, $val);
              push @{$self->{absent_problem}}, { filter => $values[0], instance => $values[1] }; 
          }
      }
  
      $self->{overload_th} = [];
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          next if (!defined($val) || $val eq '');
          my @values = split (/,/, $val);
          if (scalar(@values) < 3) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $instance, $status, $filter);
          if (scalar(@values) == 3) {
              ($section, $status, $filter) = @values;
              $instance = '.*';
          } else {
               ($section, $instance, $status, $filter) = @values;
          }
  
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          push @{$self->{overload_th}}, { section => $section, filter => $filter, status => $status, instance => $instance };
      }
  
      if ($self->{performance} == 1) {
          $self->{numeric_threshold} = {};
          foreach my $option (('warning', 'critical')) {
              foreach my $val (@{$self->{option_results}->{$option}}) {
                  next if (!defined($val) || $val eq '');
                  if ($val !~ /^(.*?),(.*?),(.*)$/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }
                  my ($section, $instance, $value) = ($1, $2, $3);                
                  if (defined($self->{regexp_threshold_numeric_check_section_option}) && 
                      $section !~ /$self->{regexp_threshold_numeric_check_section_option}/) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option option '" . $val . "'.");
                      $self->{output}->option_exit();
                  }   
                  $self->call_object_callback(
                      method_name => $self->{cb_threshold_numeric_check_section_option}, 
                      section => $section,
                      option_name => $option,
                      option_value => $val
                  );
  
                  my $position = 0;
                  if (defined($self->{numeric_threshold}->{$section})) {
                      $position = scalar(@{$self->{numeric_threshold}->{$section}});
                  }
                  if (($self->{perfdata}->threshold_validate(label => $option . '-' . $section . '-' . $position, value => $value)) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong $option threshold '" . $value . "'.");
                      $self->{output}->option_exit();
                  }
                  $self->{numeric_threshold}->{$section} = [] if (!defined($self->{numeric_threshold}->{$section}));
                  push @{$self->{numeric_threshold}->{$section}}, { label => $option . '-' . $section . '-' . $position, threshold => $option, instance => $instance };
              }
          }
      }
  
      if ($self->{count} == 1) {
          foreach my $comp (@{$self->{components_module}}) {
              foreach my $threshold (('warning', 'critical', 'unknown')) {
                  if (($self->{perfdata}->threshold_validate(label => $threshold . '-count-' . $comp, value => $self->{option_results}->{$threshold . '_count_' . $comp})) == 0) {
                      $self->{output}->add_option_msg(short_msg => "Wrong " . $threshold . " threshold '" . $self->{option_results}->{$threshold . '_count_' . $comp} . "'.");
                      $self->{output}->option_exit();
                  }
              }
          }
      }
  }
  
  sub load_components {
      my ($self, %options) = @_;
  
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              centreon::plugins::misc::mymodule_load(
                  output => $self->{output}, module => $mod_name,
                  error_msg => "Cannot load module '$mod_name'.") if ($self->{load_components} == 1);
              $self->{loaded} = 1;
              if ($self->{components_exec_load} == 1) {
                  my $func = $mod_name->can('load');
                  $func->($self);
              }
          }
      }
  }
  
  sub exec_components {
      my ($self, %options) = @_;
  
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              my $func = $mod_name->can('check');
              $func->($self); 
          }
      }
  }
  
  sub display {
      my ($self, %options) = @_;
  
      my $total_components = 0;
      my $display_by_component = '';
      my $display_by_component_append = '';
      my $exit = 'OK';
      my $exits = [];
      my ($warn, $crit);
  
      foreach my $comp (sort(keys %{$self->{components}})) {
          # Skipping short msg when no components
          next if (!defined($self->{option_results}->{no_component_count}) && $self->{components}->{$comp}->{total} == 0 && $self->{components}->{$comp}->{skip} == 0);
          next if (defined($self->{option_results}->{component}) && $comp !~ /$self->{option_results}->{component}/ );
  
          if ($self->{count} == 1) {
              ($exit, $warn, $crit) = $self->get_severity_count(label => $comp, value => $self->{components}->{$comp}->{total});
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(
                      severity => $exit,
                      short_msg => sprintf(
                          "'%s' components '%s' checked",
                          $self->{components}->{$comp}->{total},
                          $comp
                      )
                  );
              }
              $self->{output}->perfdata_add(
                  label => 'count_' . $comp,
                  nlabel => 'hardware.' . $comp . '.count',
                  value => $self->{components}->{$comp}->{total},
                  warning => $warn,
                  critical => $crit
              );
              push @{$exits}, $exit;
          }
  
          $total_components += $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip};
          my $count_by_components = $self->{components}->{$comp}->{total} + $self->{components}->{$comp}->{skip}; 
          $display_by_component .= $display_by_component_append . $self->{components}->{$comp}->{total} . '/' . $count_by_components . ' ' . $self->{components}->{$comp}->{name};
          $display_by_component_append = ', ';
      }
  
      $exit = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
  
      if ($self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
          $self->{output}->output_add(
              short_msg => sprintf(
                  'All %s components are ok [%s].', 
                  $total_components,
                  $display_by_component
              )
          );
      }
  
      if (defined($self->{option_results}->{no_component}) && $total_components == 0) {
          $self->{output}->output_add(
              severity => $self->{no_components},
              short_msg => 'No components are checked.'
          );
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
  
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      $self->exec_components(%options);
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
  
      $self->display();
  
      $self->call_object_callback(method_name => $self->{cb_hook4}, %options);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      $self->{output}->add_disco_format(elements => ['component', 'instance', 'description']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->{loaded} = 0;  
      $self->call_object_callback(method_name => $self->{cb_hook1}, %options);
  
      $self->load_components(%options);
      if ($self->{loaded} == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong option. Cannot find component '" . $self->{option_results}->{component} . "'.");
          $self->{output}->option_exit();
      }
      
      $self->call_object_callback(method_name => $self->{cb_hook2}, %options);
      
      foreach (@{$self->{components_module}}) {
          if (/$self->{option_results}->{component}/) {
              my $mod_name = $self->{components_path} . "::$_";
              if (my $func = $mod_name->can('disco_show')) {
                  $func->($self);
              }
          }
      }
  
      $self->call_object_callback(method_name => $self->{cb_hook3}, %options);
  }
  
  sub check_filter {
      my ($self, %options) = @_;
  
      # Old compatibility variable. We'll be deleted
      if (defined($self->{option_results}->{exclude})) {
          if (defined($options{instance})) {
              if ($self->{option_results}->{exclude} =~ /(^|\s|,)${options{section}}[^,]*#\Q$options{instance}\E#/) {
                  $self->{components}->{$options{section}}->{skip}++;
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          } elsif (defined($self->{option_results}->{exclude}) && $self->{option_results}->{exclude} =~ /(^|\s|,)$options{section}(\s|,|$)/) {
              $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
              return 1;
          }
      }
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));   
      foreach (@{$self->{filter}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($options{instance}) && !defined($_->{instance})) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section."));
                  return 1;
              } elsif (defined($options{instance}) && $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(long_msg => sprintf("skipping $options{section} section $options{instance} instance."));
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  sub absent_problem {
      my ($self, %options) = @_;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      foreach (@{$self->{absent_problem}}) {
          if ($options{section} =~ /$_->{filter}/) {
              if (!defined($_->{instance}) || $options{instance} =~ /$_->{instance}/) {
                  $self->{output}->output_add(
                      severity => 'CRITICAL',
                      short_msg => sprintf(
                          "Component '%s' instance '%s' is not present", 
                          $options{section},
                          $options{instance}
                      )
                  );
                  $self->{output}->output_add(long_msg => sprintf("Skipping $options{section} section $options{instance} instance (not present)"));
                  $self->{components}->{$options{section}}->{skip}++;
                  return 1;
              }
          }
      }
  
      return 0;
  }
  
  sub get_severity_count {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
  
      $status = $self->{perfdata}->threshold_check(
          value => $options{value},
          threshold => [
              { label => 'critical-count-' . $options{label}, exit_litteral => 'critical' }, 
              { label => 'warning-count-' . $options{label}, exit_litteral => 'warning' },
              { label => 'unknown-count-' . $options{label}, exit_litteral => 'unknown' },
          ]
      );
      $thresholds->{critical} = $self->{perfdata}->get_perfdata_for_output(label => 'critical-count-' . $options{label});
      $thresholds->{warning} = $self->{perfdata}->get_perfdata_for_output(label => 'warning-count-' . $options{label});
  
      return ($status, $thresholds->{warning}, $thresholds->{critical});
  }
  
  sub get_severity_numeric {
      my ($self, %options) = @_;
      my $status = 'OK'; # default
      my $thresholds = { warning => undef, critical => undef };
      my $checked = 0;
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
      if (defined($self->{numeric_threshold}->{$options{section}})) {
          my $exits = [];
          foreach (@{$self->{numeric_threshold}->{$options{section}}}) {
              if ($options{instance} =~ /$_->{instance}/) {
                  push @{$exits}, $self->{perfdata}->threshold_check(value => $options{value}, threshold => [ { label => $_->{label}, exit_litteral => $_->{threshold} } ]);
                  $thresholds->{$_->{threshold}} = $self->{perfdata}->get_perfdata_for_output(label => $_->{label});
                  $checked = 1;
              }
          }
          $status = $self->{output}->get_most_critical(status => $exits) if (scalar(@{$exits}) > 0);
      }
  
      return ($status, $thresholds->{warning}, $thresholds->{critical}, $checked);
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
  
      $options{instance} .= '#' . $options{name} if (defined($self->{option_results}->{add_name_instance}) && defined($options{name}));
  
      foreach (@{$self->{overload_th}}) {
          if ($options{section} =~ /$_->{section}/i) {
              if ($options{value} =~ /$_->{filter}/i &&
                  (!defined($options{instance}) || $options{instance} =~ /$_->{instance}/)) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
  
      my $label = defined($options{label}) ? $options{label} : $options{section};
      foreach (@{$self->{thresholds}->{$label}}) {
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
  
      return $status;
  }
      
  1;
  
  
  =head1 GLOBAL HARDWARE OPTIONS
  
  Global options for hardware.
  
  =over 8
  
  =back
  
  =cut
CENTREON_PLUGINS_TEMPLATES_HARDWARE

$fatpacked{"centreon/plugins/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CENTREON_PLUGINS_VALUES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package centreon::plugins::values;
  
  use strict;
  use warnings;
  use centreon::plugins::misc;
  use centreon::plugins::constants qw(:values);
  
  # Warning message with sprintf and too much arguments.
  # Really annoying. Need to disable that warning
  no if ($^V gt v5.22.0), 'warnings' => 'redundant';
  
  sub new {
      my ($class, %options) = @_;
      my $self  = {};
      bless $self, $class;
  
      $self->{statefile} = $options{statefile};
      $self->{output} = $options{output};
      $self->{perfdata} = $options{perfdata};
      $self->{label} = $options{label};
      $self->{nlabel} = $options{nlabel};
      $self->{thlabel} = defined($options{thlabel}) ? $options{thlabel} : $self->{label};
  
      $self->{perfdatas} = [];
      
      $self->{output_template} = $self->{label} . ' : %s';
      $self->{output_use} = undef;
      $self->{output_change_bytes} = 0;
      
      $self->{output_error_template} = $self->{label} . ' : %s';
      
      $self->{threshold_use} = undef;
      $self->{threshold_warn} = undef;
      $self->{threshold_crit} = undef;
  
      $self->{per_second} = 0;
      $self->{manual_keys} = 0;
      $self->{last_timestamp} = undef;
  
      $self->{result_values} = {};
      $self->{safe_test} = 0;
  
      return $self;
  }
  
  sub init {
      my ($self, %options) = @_;
      my $unkn = defined($self->{threshold_unkn}) ? $self->{threshold_unkn} : 'unknown-' . $self->{thlabel};
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
  
      if (($self->{perfdata}->threshold_validate(label => $unkn, value => $options{option_results}->{$unkn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $unkn threshold '" . $options{option_results}->{$unkn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $warn, value => $options{option_results}->{$warn})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $warn threshold '" . $options{option_results}->{$warn} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => $crit, value => $options{option_results}->{$crit})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong $crit threshold '" . $options{option_results}->{$crit} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub set {
      my ($self, %options) = @_;
  
      foreach (keys %options) {
          $self->{$_} = $options{$_};
      }
  }
  
  sub calc {
      my ($self, %options) = @_;
  
      # manage only one value ;)
      foreach my $value (@{$self->{key_values}}) {
          if (defined($value->{diff}) && $value->{diff} == 1)  {
              $self->{result_values}->{$value->{name}} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}};
          } elsif (defined($value->{per_second}) && $value->{per_second} == 1) {
              $self->{result_values}->{$value->{name}} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / $options{delta_time};
          } elsif (defined($value->{per_minute}) && $value->{per_minute} == 1) {
              $self->{result_values}->{$value->{name}} = ($options{new_datas}->{$self->{instance} . '_' . $value->{name}} - $options{old_datas}->{$self->{instance} . '_' . $value->{name}}) / ($options{delta_time} / 60);
          } else {
              $self->{result_values}->{$value->{name}} = $options{new_datas}->{$self->{instance} . '_' . $value->{name}};
          }
      }
  
      return 0;
  }
  
  sub threshold_check {
      my ($self, %options) = @_;
      if (defined($self->{closure_custom_threshold_check})) {
          return &{$self->{closure_custom_threshold_check}}($self, %options);
      }
  
      my $unkn = defined($self->{threshold_unkn}) ? $self->{threshold_unkn} : 'unknown-' . $self->{thlabel};
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel};
      
      my $value = '';
      if (defined($self->{threshold_use})) {
          $value = $self->{result_values}->{ $self->{threshold_use} };
      } else {
          $value = defined($self->{key_values}->[0]) ? $self->{result_values}->{ $self->{key_values}->[0]->{name} } : '';
      }
  
      return $self->{perfdata}->threshold_check(
          value => $value, threshold => [
              { label => $crit, exit_litteral => 'critical' },
              { label => $warn, exit_litteral => 'warning' },
              { label => $unkn, exit_litteral => 'unknown' }
          ]
      );
  }
  
  sub output_error {
      my ($self, %options) = @_;
  
      return sprintf($self->{output_error_template}, $self->{error_msg});
  }
  
  sub output {
      my ($self, %options) = @_;
       
      if (defined($self->{closure_custom_output})) {
          return $self->{closure_custom_output}->($self);
      }
  
      my ($value, $unit, $name) = ('', '');
      if (defined($self->{output_use})) {
          $name = $self->{output_use};
      } else {
          $name = defined($self->{key_values}->[0]) ? $self->{key_values}->[0]->{name} : undef;
      }
  
      if (defined($name)) {
          $value = $self->{result_values}->{$name};
          if ($self->{output_change_bytes} == 1) {
              ($value, $unit) = $self->{perfdata}->change_bytes(value => $value);
          } elsif ($self->{output_change_bytes} == 2) {
              ($value, $unit) = $self->{perfdata}->change_bytes(value => $value, network => 1);
          }
      }
  
      return sprintf($self->{output_template}, $value, $unit);
  }
  
  sub use_instances {
      my ($self, %options) = @_;
  
      if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
          return 1;
      }
      
      return 0;
  }
  
  sub perfdata {
      my ($self, %options) = @_;
      
      if (defined($self->{closure_custom_perfdata})) {
          return &{$self->{closure_custom_perfdata}}($self, %options);
      }
      
      my $warn = defined($self->{threshold_warn}) ? $self->{threshold_warn} : 'warning-' . $self->{thlabel};
      my $crit = defined($self->{threshold_crit}) ? $self->{threshold_crit} : 'critical-' . $self->{thlabel}; 
      
      foreach my $perf (@{$self->{perfdatas}}) {
          my ($label, $extra_label, $min, $max, $th_total) = ($self->{label}, '');
          my $cast_int = (defined($perf->{cast_int}) && $perf->{cast_int} == 1) ? 1 : 0;
          my $template = '%s';
          
          $template = $perf->{template} if (defined($perf->{template}));
          $label = $perf->{label} if (defined($perf->{label}));
          if (defined($perf->{min})) {
              $min = ($perf->{min} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{min}} : $perf->{min};
          }
          if (defined($perf->{max})) {
              $max = ($perf->{max} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{max}} : $perf->{max};
          }
          if (defined($perf->{threshold_total})) {
              $th_total = ($perf->{threshold_total} =~ /[^0-9.-]/) ? $self->{result_values}->{$perf->{threshold_total}} : $perf->{threshold_total};
          }
          
          my $instances;
          if (defined($perf->{label_extra_instance}) && $perf->{label_extra_instance} == 1) {
              my $instance = '';
              if (defined($perf->{instance_use})) {
                  $instance = $self->{result_values}->{$perf->{instance_use}};
              } else {
                  $instance = $self->{instance};
              }
              
              if (!defined($options{extra_instance}) || $options{extra_instance} != 0 || $self->{output}->use_new_perfdata()) {
                  $instances = $instance;
              }
          }
  
          my $value = defined($perf->{value}) ? $perf->{value} : $self->{key_values}->[0]->{name};
          $self->{output}->perfdata_add(
              label => $label,
              instances => $instances,
              nlabel => $self->{nlabel},
              unit => $perf->{unit},
              value => $cast_int == 1 ? int($self->{result_values}->{$value}) : sprintf($template, $self->{result_values}->{$value}),
              warning => $self->{perfdata}->get_perfdata_for_output(label => $warn, total => $th_total, cast_int => $cast_int),
              critical => $self->{perfdata}->get_perfdata_for_output(label => $crit, total => $th_total, cast_int => $cast_int),
              min => $min,
              max => $max
          );
      }
  }
  
  sub eval {
      my ($self, %options) = @_;
  
      if ($self->{safe_test} == 0) {
          my ($code) = centreon::plugins::misc::mymodule_load(
              output => $self->{output}, module => 'Safe', 
              no_quit => 1
          );
          if ($code == 0) {
              $self->{safe} = Safe->new();
              $self->{safe}->share('$values');
          }
          $self->{safe_test} = 1;
      }
  
      my $result;
      if (defined($self->{safe})) {
          our $values = $self->{result_values};
          $result = $self->{safe}->reval($options{value}, 1);
          if ($@) {
              die 'Unsafe code evaluation: ' . $@;
          }
      } else {
          my $values = $self->{result_values};
          {
              local $SIG{__WARN__} = sub {}; # ignore
              
              $result = eval "$options{value}";
              if ($@) {
                  die 'Code evaluation error: ' . $@;
              }
          }
      }
  
      return $result;
  }
  
  sub execute {
      my ($self, %options) = @_;
      my $old_datas = {};
  
      $self->{result_values} = {},
      $self->{error_msg} = undef;
      my $quit = 0;
      
      $options{new_datas} = {} if (!defined($options{new_datas}));
      foreach my $value (@{$self->{key_values}}) {
          if (!defined($options{values}->{$value->{name}}) || 
              defined($value->{no_value}) && $options{values}->{$value->{name}} eq $value->{no_value}) {
              $quit = 2;
              last;
          }
      
          if ((defined($value->{diff}) && $value->{diff} == 1) ||
              (defined($value->{per_minute}) && $value->{per_minute} == 1) ||
              (defined($value->{per_second}) && $value->{per_second} == 1)) {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              if (!defined($old_datas->{$self->{instance} . '_' . $value->{name}})) {
                  $quit = 1;
                  next;
              }
              if ($old_datas->{$self->{instance} . '_' . $value->{name}} > $options{new_datas}->{$self->{instance} . '_' . $value->{name}}) {
                  $old_datas->{$self->{instance} . '_' . $value->{name} . '_real'} = $old_datas->{$self->{instance} . '_' . $value->{name}};
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = 0;
              }
          } else {
              $options{new_datas}->{$self->{instance} . '_' . $value->{name}} = $options{values}->{$value->{name}};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $value->{name}} = $self->{statefile}->get(name => $self->{instance} . '_' . $value->{name});
              }
          }
      }
      
      # Very manual
      if ($self->{manual_keys} == 1) {
          foreach my $name (keys %{$options{values}}) {
              $options{new_datas}->{$self->{instance} . '_' . $name} = $options{values}->{$name};
              if (defined($self->{statefile})) {
                  $old_datas->{$self->{instance} . '_' . $name} = $self->{statefile}->get(name => $self->{instance} . '_' . $name);
              }
          }
      }
  
      if ($quit == 2) {
          $self->{error_msg} = 'skipped (no value(s))';
          return NO_VALUE;
      }
  
      if (defined($self->{statefile})) {
          $self->{last_timestamp} = $self->{statefile}->get(name => 'last_timestamp');
      }
  
      if ($quit == 1) {
          $self->{error_msg} = 'Buffer creation';
          return BUFFER_CREATION;
      }
  
      my $delta_time;
      if (defined($self->{statefile}) && defined($self->{last_timestamp})) {
          $delta_time = $options{new_datas}->{last_timestamp} - $self->{last_timestamp};
          if ($delta_time <= 0) {
              $delta_time = 1;
          }
      }
  
      if (defined($self->{closure_custom_calc})) {
          return $self->{closure_custom_calc}->(
              $self,
              old_datas => $old_datas,
              new_datas => $options{new_datas},
              delta_time => $delta_time,
              extra_options => $self->{closure_custom_calc_extra_options}
          );
      }
      return $self->calc(old_datas => $old_datas, new_datas => $options{new_datas}, delta_time => $delta_time);
  }
  
  1;
  
  
CENTREON_PLUGINS_VALUES

$fatpacked{"snmp_standard/mode/uptime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SNMP_STANDARD_MODE_UPTIME';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  
  
  package snmp_standard::mode::uptime;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use POSIX;
  use centreon::plugins::misc;
  use centreon::plugins::statefile;
  use Time::HiRes qw(time);
  
  my $unitdiv = { s => 1, w => 604800, d => 86400, h => 3600, m => 60 };
  my $unitdiv_long = { s => 'seconds', w => 'weeks', d => 'days', h => 'hours', m => 'minutes' };
  
  sub custom_uptime_output { 
      my ($self, %options) = @_;
  
      my $msg = sprintf(
          'System uptime is: %s',
          centreon::plugins::misc::change_seconds(value => $self->{result_values}->{uptime}, start => 'd')
      );
      if (defined($self->{instance_mode}->{option_results}->{add_sysdesc})) {
          $msg .= sprintf(', %s', $self->{result_values}->{sysdesc});
      }
  
      return $msg;
  }
  
  sub custom_uptime_perfdata {
      my ($self, %options) = @_;
  
      $self->{output}->perfdata_add(
          label => 'uptime', unit => $self->{instance_mode}->{option_results}->{unit},
          nlabel => 'system.uptime.' . $unitdiv_long->{ $self->{instance_mode}->{option_results}->{unit} },
          value => sprintf("%.2f", $self->{result_values}->{uptime} / $unitdiv->{ $self->{instance_mode}->{option_results}->{unit} }),
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
          min => 0
      );
  }
  
  sub custom_uptime_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(
          value => sprintf("%.2f", $self->{result_values}->{uptime} / $unitdiv->{ $self->{instance_mode}->{option_results}->{unit} }),
          threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' },
              { label => 'unknown-'. $self->{thlabel}, exit_litteral => 'unknown' }
          ]
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0 }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'uptime', set => {
                  key_values => [ { name => 'uptime' }, { name => 'sysdesc' } ],
                  closure_custom_output => $self->can('custom_uptime_output'),
                  closure_custom_perfdata => $self->can('custom_uptime_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_uptime_threshold')
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'force-oid:s'     => { name => 'force_oid' },
          'check-overload'  => { name => 'check_overload' },
          'reboot-window:s' => { name => 'reboot_window', default => 5000 },
          'unit:s'          => { name => 'unit', default => 's' },
          'add-sysdesc'     => { name => 'add_sysdesc' }
      });
  
      $self->{statefile_cache} = centreon::plugins::statefile->new(%options);
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      if ($self->{option_results}->{unit} eq '' || !defined($unitdiv->{$self->{option_results}->{unit}})) {
          $self->{option_results}->{unit} = 's';
      }
  
      $self->{statefile_cache}->check_options(%options);
  }
  
  sub check_overload {
      my ($self, %options) = @_;
      
      return $options{timeticks} if (!defined($self->{option_results}->{check_overload}));
      
      my $current_time = floor(time() * 100);
      $self->{new_datas} = { last_time => $current_time, uptime => $options{timeticks} };
      $self->{statefile_cache}->read(statefile => 'cache_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode});
      my $old_uptime = $self->{statefile_cache}->get(name => 'uptime');
      my $last_time = $self->{statefile_cache}->get(name => 'last_time');
      $self->{new_datas}->{overload} = $self->{statefile_cache}->get(name => 'overload') || 0;
      
      if (defined($old_uptime) && $options{timeticks} < $old_uptime) {
          my $diff_time = $current_time - $last_time;
          my $overflow = ($old_uptime + $diff_time) % 4294967296;
          my $division = ($old_uptime + $diff_time) / 4294967296;
          if ($division >= 1 && 
              $overflow >= ($options{timeticks} - ($self->{option_results}->{reboot_window} / 2)) &&
              $overflow <= ($options{timeticks} + ($self->{option_results}->{reboot_window} / 2))) {
              $self->{new_datas}->{overload}++;
          } else {
              $self->{new_datas}->{overload} = 0;
          }
      }
      $options{timeticks} += ($self->{new_datas}->{overload} * 4294967296);
  
      $self->{statefile_cache}->write(data => $self->{new_datas});
      return $options{timeticks};
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_sysDescr = '.1.3.6.1.2.1.1.1.0';
      my @oids = ();
      if (defined($self->{option_results}->{add_sysdesc})) {
          @oids = ($oid_sysDescr);
      }
  
      # To be used first for OS
      my $oid_hrSystemUptime = '.1.3.6.1.2.1.25.1.1.0';
      # For network equipment or others
      my $oid_sysUpTime = '.1.3.6.1.2.1.1.3.0';
      my ($result, $value);
  
      if (defined($self->{option_results}->{force_oid})) {
          $result = $options{snmp}->get_leef(oids => [ @oids, $self->{option_results}->{force_oid} ], nothing_quit => 1);
          $value = $result->{ $self->{option_results}->{force_oid} };
      } else {
          $result = $options{snmp}->get_leef(oids => [ @oids, $oid_hrSystemUptime, $oid_sysUpTime ], nothing_quit => 1);
          if (defined($result->{$oid_hrSystemUptime})) {
              $value = $result->{$oid_hrSystemUptime};
          } else {
              $value = $result->{$oid_sysUpTime};
          }
      }
  
      $value = $self->check_overload(timeticks => $value, snmp => $options{snmp});
      $value = floor($value / 100);
  
      $self->{global} = { uptime => $value, sysdesc => defined($result->{$oid_sysDescr}) ? $result->{$oid_sysDescr} : '-' };
  }
  
  1;
  
  
  =head1 MODE
  
  Check system uptime.
  
  =over 8
  
  =item B<--warning-uptime>
  
  Warning threshold.
  
  =item B<--critical-uptime>
  
  Critical threshold.
  
  =item B<--add-sysdesc>
  
  Display system description.
  
  =item B<--force-oid>
  
  Can choose your OID (numeric format only).
  
  =item B<--check-overload>
  
  Uptime counter limit is 4294967296 and overflow.
  With that option, we manage the counter going back. But there is a few chance we can miss a reboot.
  
  =item B<--reboot-window>
  
  To be used with check-overload option. Time in milliseconds (default: 5000)
  You increase the chance of not missing a reboot if you decrease that value.
  
  =item B<--unit>
  
  Select the time unit for thresholds. May be 's' for seconds, 'm' for minutes, 'h' for hours, 'd' for days, 'w' for weeks. Default is seconds.
  
  =back
  
  =cut
SNMP_STANDARD_MODE_UPTIME

$fatpacked{"storage/netapp/ontap/snmp/mode/aggregates.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_AGGREGATES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::aggregates;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold_ng);
  
  sub prefix_agg_output {
      my ($self, %options) = @_;
  
      return "Aggregate '" . $options{instance_value}->{name} . "' ";
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'agg', type => 1, cb_prefix_output => 'prefix_agg_output', message_multiple => 'All aggregates are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{agg} = [
          { label => 'state', type => 2, critical_default => '%{state} =~ /offline/i',set => {
                  key_values => [ { name => 'state' }, { name => 'name' } ],
                  output_template => "state: %s",
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
          { label => 'status', type => 2, critical_default => '%{status} !~ /normal|mirrored/i', set => {
                  key_values => [ { name => 'status' }, { name => 'name' } ],
                  output_template => "status: '%s'",
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'filter-name:s' => { name => 'filter_name' }
      });
  
      return $self;
  }
  
  my $mapping = {
      state  => { oid => '.1.3.6.1.4.1.789.1.5.11.1.5' }, # aggrState
      status => { oid => '.1.3.6.1.4.1.789.1.5.11.1.6' }  # aggrStatus
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_aggrName = '.1.3.6.1.4.1.789.1.5.11.1.2';
  
      $self->{agg} = {};
      my $snmp_result = $options{snmp}->get_table(oid => $oid_aggrName, nothing_quit => 1);
      foreach my $oid (keys %$snmp_result) {
          $oid =~ /^$oid_aggrName\.(.*)$/;
          my $instance = $1;
          my $name = $snmp_result->{$oid};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping aggregatge '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{agg}->{$instance} = { name => $name };
      }
  
      if (scalar(keys %{$self->{agg}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No aggregate found");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(
          oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [keys %{$self->{agg}}],
          instance_regexp => '^(.*)$'
      );
      $snmp_result = $options{snmp}->get_leef();
      
      foreach (keys %{$self->{agg}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
  
          $self->{agg}->{$_}->{state} = $result->{state};
          $self->{agg}->{$_}->{status} = $result->{status};
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check aggregates.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter aggregates by name.
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{status}, %{name}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING.
  You can use the following variables: %{status}, %{name}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{status} !~ /normal|mirrored/i').
  You can use the following variables: %{status}, %{name}
  
  =item B<--unknown-state>
  
  Set unknown threshold for state.
  You can use the following variables: %{state}, %{name}
  
  =item B<--warning-state>
  
  Set warning threshold for state.
  You can use the following variables: %{state}, %{name}
  
  =item B<--critical-state>
  
  Set critical threshold for state (default: '%{state} =~ /offline/i').
  You can use the following variables: %{state}, %{name}
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_AGGREGATES

$fatpacked{"storage/netapp/ontap/snmp/mode/cacheage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_CACHEAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::cacheage;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => { 
          'warning:s'  => { name => 'warning' },
          'critical:s' => { name => 'critical' }
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }    
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cacheAge = ".1.3.6.1.4.1.789.1.2.2.23.0"; 
  
      my $result = $self->{snmp}->get_leef(oids => [$oid_cacheAge],
                                           nothing_quit => 1);
                                           
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_cacheAge},
                                                    threshold => [ { label => 'critical', 'exit_litteral' => 'critical' },
                                                                   { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("Cache age is '%s' minutes", $result->{$oid_cacheAge}));
      $self->{output}->perfdata_add(label => 'cache_age', unit => 'm',
                                    value => $result->{$oid_cacheAge},
                                    warning => $self->{option_results}->{warning},
                                    critical => $self->{option_results}->{critical},
                                    min => 0);
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check age in minutes of the oldest read-only blocks in the buffer cache.
  
  =over 8
  
  =item B<--warning>
  
  Warning threshold in minutes
  
  =item B<--critical>
  
  Critical threshold in minutes
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_CACHEAGE

$fatpacked{"storage/netapp/ontap/snmp/mode/clusternodes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_CLUSTERNODES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::clusternodes;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold_ng);
  use Digest::MD5 qw(md5_hex);
  
  sub custom_node_status_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "node status: %s",
          $self->{result_values}->{node_status}
      );
  }
  
  sub custom_bbu_status_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "nvram battery status: %s",
          $self->{result_values}->{bbu_status}
      );
  }
  
  sub custom_cpu_calc {
      my ($self, %options) = @_;
  
      my $diff_uptime = $options{new_datas}->{$self->{instance} . '_cpuUptime'} - $options{old_datas}->{$self->{instance} . '_cpuUptime'};
      my $diff_busy = $options{new_datas}->{$self->{instance} . '_cpuBusyTime'} - $options{old_datas}->{$self->{instance} . '_cpuBusyTime'};
      
      if ($diff_uptime == 0) {
          $self->{result_values}->{cpu_used} = 0;
      } else {
          $self->{result_values}->{cpu_used} = $diff_busy * 100 / $diff_uptime;
      }
  
      return 0;
  }
  
  sub custom_port_link_status_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "operational status: %s [admin: %s]",
          $self->{result_values}->{opstatus},
          $self->{result_values}->{admstatus}
      );
  }
  
  sub custom_port_health_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "health: %s",
          $self->{result_values}->{health}
      );
  }
  
  sub node_long_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "checking node '%s'",
          $options{instance_value}->{name}
      );
  }
  
  sub prefix_node_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "node '%s' ",
          $options{instance_value}->{name}
      );
  }
  
  sub prefix_port_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "port '%s' [role: %s] ",
          $options{instance_value}->{port_id},
          $options{instance_value}->{role}
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'nodes', type => 3, cb_prefix_output => 'prefix_node_output', cb_long_output => 'node_long_output',
            indent_long_output => '    ', message_multiple => 'All nodes are ok',
              group => [
                  { name => 'status', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'cpu', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'env', type => 0, skipped_code => { -10 => 1 } },
                  { name => 'ports', type => 1, cb_prefix_output => 'prefix_port_output', message_multiple => 'ports are ok', display_long => 1, skipped_code => { -10 => 1 } }
              ]
          }
      ];
  
      $self->{maps_counters}->{status} = [
          { label => 'node-status', type => 2, critical_default => '%{node_status} eq "clusterComLost"', set => {
                  key_values => [
                      { name => 'node_status' }, { name => 'node_name' }
                  ],
                  closure_custom_output => $self->can('custom_node_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
          { label => 'bbu-status', type => 2, critical_default => '%{bbu_status} !~ /fullyCharged|ok/i', set => {
                  key_values => [
                      { name => 'bbu_status' }, { name => 'node_name' }
                  ],
                  closure_custom_output => $self->can('custom_bbu_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          }
      ];
  
      $self->{maps_counters}->{cpu} = [
           { label => 'cpu-utilization', nlabel => 'node.cpu.utilization.percentage', set => {
                  key_values => [ { name => 'cpuUptime', diff => 1 }, { name => 'cpuBusyTime', diff => 1 } ],
                  closure_custom_calc => $self->can('custom_cpu_calc'),
                  output_template => 'cpu utilization: %.2f%%',
                  output_use => 'cpu_used', threshold_use => 'cpu_used',
                  perfdatas => [
                      { value => 'cpu_used', template => '%s', min => 0, max => 100, unit => '%', label_extra_instance => 1 }
                  ]
              }
          }
      ];
  
      $self->{maps_counters}->{env} = [
          { label => 'fan-failed', nlabel => 'node.hardware.fans.failed.count', set => {
                  key_values => [ { name => 'envFailedFanCount' } ],
                  output_template => 'number of fans failed: %s',
                  perfdatas => [
                      { template => '%s', min => 0, label_extra_instance => 1 }
                  ]
              }
          },
          { label => 'psu-failed', nlabel => 'node.hardware.power_supplies.failed.count', set => {
                  key_values => [ { name => 'envFailedPSUCount' } ],
                  output_template => 'number of power supplies failed: %s',
                  perfdatas => [
                      { template => '%s', min => 0, label_extra_instance => 1 }
                  ]
              }
          },
          { label => 'temperature-overrange', nlabel => 'node.hardware.temperatures.over_range.count', set => {
                  key_values => [ { name => 'envOverTemp' } ],
                  output_template => 'number of temperatures over range: %s',
                  perfdatas => [
                      { template => '%s', min => 0, label_extra_instance => 1 }
                  ]
              }
          }
      ];
  
      $self->{maps_counters}->{ports} = [
          { label => 'port-link-status', type => 2, critical_default => '%{admstatus} eq "up" and %{opstatus} ne "up"', set => {
                  key_values => [
                      { name => 'admstatus' }, { name => 'opstatus' }, { name => 'port_id' }, { name => 'node_name' }
                  ],
                  closure_custom_output => $self->can('custom_port_link_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
          { label => 'port-health', type => 2, warning_default => '%{health} eq "degraded"', set => {
                  key_values => [
                      { name => 'health' }, { name => 'port_id' }, { name => 'node_name' }
                  ],
                  closure_custom_output => $self->can('custom_port_health_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1, statefile => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-node-name:s' => { name => 'filter_node_name' },
          'filter-port-id:s'   => { name => 'filter_port_id' },
          'filter-port-role:s' => { name => 'filter_port_role' }
      });
  
      return $self;
  }
  
  my $map_node_health = {
      0 => 'clusterComLost', 1 => 'clusterComOk'
  };
  my $map_nvram_status = {
      1 => 'ok', 2 => 'partiallyDischarged',
      3 => 'fullyDischarged', 4 => 'notPresent',
      5 => 'nearEndOfLife', 6 => 'atEndOfLife',
      7 => 'unknown', 8 => 'overCharged', 9 => 'fullyCharged'
  };
  my $map_port_admin = {
      0 => 'down', 1 => 'up'
  };
  my $map_port_state = {
      0 => 'undef', 1 => 'off', 2 => 'up', 3 => 'down'
  };
  my $map_port_health = {
      -1 => 'unknown', 0 => 'healthy', 1 => 'degraded'
  };
  my $map_port_role = {
      0 => 'undef', 1 => 'cluster', 2 => 'data',
      3 => 'node-mgmt', 4 => 'intercluster', 5 => 'cluster-mgmt'
  };
  
  my $mapping = {
      health            => { oid => '.1.3.6.1.4.1.789.1.25.2.1.11', map => $map_node_health }, # nodeHealth
      cpuUptime         => { oid => '.1.3.6.1.4.1.789.1.25.2.1.15' }, # nodeCpuUptime
      cpuBusyTime       => { oid => '.1.3.6.1.4.1.789.1.25.2.1.16' }, # nodeCpuBusyTime
      bbuStatus         => { oid => '.1.3.6.1.4.1.789.1.25.2.1.17', map => $map_nvram_status }, # nodeNvramBatteryStatus
      envOverTemp       => { oid => '.1.3.6.1.4.1.789.1.25.2.1.18' }, # nodeEnvOverTemperature
      envFailedFanCount => { oid => '.1.3.6.1.4.1.789.1.25.2.1.19' }, # nodeEnvFailedFanCount
      envFailedPSUCount => { oid => '.1.3.6.1.4.1.789.1.25.2.1.21' }  # nodeEnvFailedPowerSupplyCount
  };
  my $mapping_port = {
      port_id   => { oid => '.1.3.6.1.4.1.789.1.22.2.1.2' }, # netportPort
      role      => { oid => '.1.3.6.1.4.1.789.1.22.2.1.3', map => $map_port_role }, # netportRole
      opstatus  => { oid => '.1.3.6.1.4.1.789.1.22.2.1.4', map => $map_port_state }, # netportLinkState
      admstatus => { oid => '.1.3.6.1.4.1.789.1.22.2.1.14', map => $map_port_admin }, # netportUpAdmin
      health    => { oid => '.1.3.6.1.4.1.789.1.22.2.1.30', map => $map_port_health } # netportHealthStatus
  };
  
  sub add_ports {
      my ($self, %options) = @_;
  
      my $oid_netportNode = '.1.3.6.1.4.1.789.1.22.2.1.1';
      my $snmp_result = $options{snmp}->get_table(
          oid => $oid_netportNode
      );
      my $instances = {};
      foreach (keys %$snmp_result) {
          next if (!defined($self->{nodes}->{ $snmp_result->{$_} }));
  
          /^$oid_netportNode\.(.*)$/;
          $instances->{$1} = $snmp_result->{$_};
      }
  
      return if (scalar(keys %$instances) <= 0);
  
      $options{snmp}->load(
          oids => [ map($_->{oid}, values(%$mapping_port)) ],
          instances => [ keys %$instances ],
          instance_regexp => '^(.*)$'
      );
      $snmp_result = $options{snmp}->get_leef();
      foreach (keys %$instances) {
          my $result = $options{snmp}->map_instance(mapping => $mapping_port, results => $snmp_result, instance => $_);
  
          if (defined($self->{option_results}->{filter_port_id}) && $self->{option_results}->{filter_port_id} ne '' &&
              $result->{port_id} !~ /$self->{option_results}->{filter_port_id}/) {
              $self->{output}->output_add(long_msg => "skipping port '" . $result->{port_id} . "'.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_port_role}) && $self->{option_results}->{filter_port_role} ne '' &&
              $result->{role} !~ /$self->{option_results}->{filter_port_role}/) {
              $self->{output}->output_add(long_msg => "skipping port '" . $result->{port_id} . "'.", debug => 1);
              next;
          }
  
          $self->{nodes}->{ $instances->{$_} }->{ports}->{ $result->{port_id} } = $result;
          $self->{nodes}->{ $instances->{$_} }->{ports}->{ $result->{port_id} }->{node_name} = $instances->{$_};
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $snmp_result = $options{snmp}->get_table(
          oid => $oid_nodeName,
          nothing_quit => 1
      );
  
      $self->{nodes} = {};
      foreach (keys %$snmp_result) {
          /$oid_nodeName\.(.*)$/;
  
          my $instance = $1;
          my $name = $snmp_result->{$_};
          if (defined($self->{option_results}->{filter_node_name}) && $self->{option_results}->{filter_node_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_node_name}/) {
              $self->{output}->output_add(long_msg => "skipping node '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{nodes}->{$name} = {
              instance => $instance,
              name => $name,
              status => { name => $name },
              ports => {}
          };
      }
  
      return if (scalar(keys %{$self->{nodes}}) <= 0);
  
      $options{snmp}->load(
          oids => [ map($_->{oid}, values(%$mapping)) ],
          instances => [ map($_->{instance}, values(%{$self->{nodes}})) ],
          instance_regexp => '^(.*)$'
      );
      $snmp_result = $options{snmp}->get_leef();
      foreach (keys %{$self->{nodes}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $self->{nodes}->{$_}->{instance});
  
          $self->{nodes}->{$_}->{status}->{node_status} = $result->{node_status};
          $self->{nodes}->{$_}->{status}->{bbu_status} = $result->{bbu_status};
  
          $self->{nodes}->{$_}->{cpu} = {
              cpuUptime => $result->{cpuUptime},
              cpuBusyTime => $result->{cpuBusyTime}
          };
          $self->{nodes}->{$_}->{env} = {
              envOverTemp => $result->{envOverTemp},
              envFailedFanCount => $result->{envFailedFanCount},
              envFailedPSUCount => $result->{envFailedPSUCount}
          };
      }
  
      $self->add_ports(snmp => $options{snmp});
  
      $self->{cache_name} = 'netapp_ontap_' . $self->{mode} . '_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' .
          md5_hex(
              (defined($self->{option_results}->{filter_counters}) ? $self->{option_results}->{filter_counters} : 'all') . '_' .
              (defined($self->{option_results}->{filter_node_name}) ? $self->{option_results}->{filter_node_name} : 'all') . '_' .
              (defined($self->{option_results}->{filter_port_id}) ? $self->{option_results}->{filter_port_id} : 'all') . '_' .
              (defined($self->{option_results}->{filter_port_role}) ? $self->{option_results}->{filter_port_role} : 'all')
          );
  }
  
  1;
  
  
  =head1 MODE
  
  Check cluster nodes.
  
  =over 8
  
  =item B<--filter-node-name>
  
  Filter nodes by name (can be a regexp).
  
  =item B<--filter-port-id>
  
  Filter ports by ID (can be a regexp).
  
  =item B<--filter-port-role>
  
  Filter ports by role (can be a regexp).
  
  =item B<--unknown-node-status>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{node_status}, %{node_name}
  
  =item B<--warning-node-status>
  
  Define the conditions to match for the status to be WARNING.
  You can use the following variables: %{node_status}, %{node_name}
  
  =item B<--critical-node-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{node_status} eq "clusterComLost"').
  You can use the following variables: %{node_status}, %{node_name}
  
  =item B<--unknown-bbu-status>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{bbu_status}, %{node_name}
  
  =item B<--warning-bbu-status>
  
  Define the conditions to match for the status to be WARNING.
  You can use the following variables: %{bbu_status}, %{node_name}
  
  =item B<--critical-bbu-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{bbu_status} !~ /fullyCharged|ok/i').
  You can use the following variables: %{bbu_status}, %{node_name}
  
  =item B<--unknown-port-link-status>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{admstatus}, %{opstatus}, %{port_id}, %{node_name}
  
  =item B<--warning-port-link-status>
  
  Define the conditions to match for the status to be WARNING.
  You can use the following variables: %{admstatus}, %{opstatus}, %{port_id}, %{node_name}
  
  =item B<--critical-port-link-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{admstatus} eq "up" and %{opstatus} ne "up"').
  You can use the following variables: %{admstatus}, %{opstatus}, %{port_id}, %{node_name}
  
  =item B<--unknown-port-health>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{health}, %{port_id}, %{node_name}
  
  =item B<--warning-port-health>
  
  Define the conditions to match for the status to be WARNING (default: '%{health} eq "degraded"').
  You can use the following variables: %{health}, %{port_id}, %{node_name}
  
  =item B<--critical-port-health>
  
  Define the conditions to match for the status to be CRITICAL.
  You can use the following variables: %{health}, %{port_id}, %{node_name}
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'cpu-utilization', 'temperature-overrange', 'fan-failed', 'psu-failed'.
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_CLUSTERNODES

$fatpacked{"storage/netapp/ontap/snmp/mode/components/communication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_COMMUNICATION';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::communication;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %map_com_states = (
      1 => 'initializing', 
      2 => 'transitioning', 
      3 => 'active', 
      4 => 'inactive',
      5 => 'reconfiguring',
      6 => 'nonexistent',
  );
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclContactState = '.1.3.6.1.4.1.789.1.21.1.2.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclContactState };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking communications");
      $self->{components}->{communication} = {name => 'communications', total => 0, skip => 0};
      return if ($self->check_filter(section => 'communication'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $com_state = $map_com_states{$self->{results}->{$oid_enclContactState}->{$oid_enclContactState . '.' . $i}};
  
          next if ($self->check_filter(section => 'communication', instance => $shelf_addr));
          
          $self->{components}->{communication}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Shelve '%s' communication state is '%s'", 
                                                            $shelf_addr, $com_state));
          my $exit = $self->get_severity(section => 'communication', value => $com_state);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Shelve '%s' communication state is '%s'", 
                                                            $shelf_addr, $com_state));
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_COMMUNICATION

$fatpacked{"storage/netapp/ontap/snmp/mode/components/electronics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_ELECTRONICS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::electronics;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclElectronicsPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.31';
  my $oid_enclElectronicsFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.33';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclElectronicsPresent }, { oid => $oid_enclElectronicsFailed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking electronics");
      $self->{components}->{electronics} = {name => 'electronics', total => 0, skip => 0};
      return if ($self->check_filter(section => 'electronics'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclElectronicsPresent}->{$oid_enclElectronicsPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclElectronicsFailed}->{$oid_enclElectronicsFailed . '.' . $i};
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              
              next if ($self->check_filter(section => 'electronics', instance => $shelf_addr . '.' . $num));
              $self->{components}->{electronics}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' electronics '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'electronics', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' electronics '%s' is '%s'", $shelf_addr, $num, $status));
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_ELECTRONICS

$fatpacked{"storage/netapp/ontap/snmp/mode/components/fan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_FAN';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::fan;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclFansPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.17';
  my $oid_enclFansFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.18';
  my $oid_enclFansSpeed = '.1.3.6.1.4.1.789.1.21.1.2.1.62';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclFansPresent }, { oid => $oid_enclFansFailed },
          { oid => $oid_enclFansSpeed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking fans");
      $self->{components}->{fan} = {name => 'fans', total => 0, skip => 0};
      return if ($self->check_filter(section => 'fan'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclFansPresent}->{$oid_enclFansPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclFansFailed}->{$oid_enclFansFailed . '.' . $i};
          my @current_speed = defined($self->{results}->{$oid_enclFansSpeed}->{$oid_enclFansSpeed . '.' . $i}) ? split /,/, $self->{results}->{$oid_enclFansSpeed}->{$oid_enclFansSpeed . '.' . $i} : ();
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              my $current_value = (defined($current_speed[$num - 1]) && $current_speed[$num - 1] =~ /(^|\s)([0-9]+)/) ? $2 : '';
              
              next if ($self->check_filter(section => 'fan', instance => $shelf_addr . '.' . $num));
              $self->{components}->{fan}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' Fan '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'fan', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' Fan '%s' is '%s'", $shelf_addr, $num, $status));
              }
              
              if ($current_value ne '') {
                  my ($exit, $warn, $crit) = $self->get_severity_numeric(section => 'fan', instance => $shelf_addr . '.' . $num, value => $current_value);
                  if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                      $self->{output}->output_add(severity => $exit,
                                                  short_msg => sprintf("Shelve '%s' Fan '%s' speed is '%s'", $shelf_addr, $num, $current_value));
                  }
                  
                  $self->{output}->perfdata_add(
                      label => "speed", unit => 'rpm',
                      nlabel => 'hardware.fan.speed.rpm',
                      instances => [$shelf_addr, $num],
                      value => $current_value,
                      warning => $warn,
                      critical => $crit,
                      min => 0
                  );
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_FAN

$fatpacked{"storage/netapp/ontap/snmp/mode/components/psu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_PSU';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::psu;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclPowerSuppliesPresent = '.1.3.6.1.4.1.789.1.21.1.2.1.13';
  my $oid_enclPowerSuppliesFailed = '.1.3.6.1.4.1.789.1.21.1.2.1.15';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclPowerSuppliesPresent }, { oid => $oid_enclPowerSuppliesFailed };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking power supplies");
      $self->{components}->{psu} = {name => 'psus', total => 0, skip => 0};
      return if ($self->check_filter(section => 'psu'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my $present = $self->{results}->{$oid_enclPowerSuppliesPresent}->{$oid_enclPowerSuppliesPresent . '.' . $i};
          my $failed = $self->{results}->{$oid_enclPowerSuppliesFailed}->{$oid_enclPowerSuppliesFailed . '.' . $i};
          
          foreach my $num (split /,/, $present) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/);
              
              next if ($self->check_filter(section => 'psu', instance => $shelf_addr . '.' . $num));
              $self->{components}->{psu}->{total}++;
  
              my $status = 'ok';
              if ($failed =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'failed';
              }
  
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' PSU '%s' is '%s'", 
                                          $shelf_addr, $num, $status));
              my $exit = $self->get_severity(section => 'psu', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' PSU '%s' is '%s'", $shelf_addr, $num, $status));
              }
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_PSU

$fatpacked{"storage/netapp/ontap/snmp/mode/components/raid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_RAID';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::raid;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %map_raid_states = (
      1 => 'active',
      2 => 'reconstructionInProgress',
      3 => 'parityReconstructionInProgress',
      4 => 'parityVerificationInProgress',
      5 => 'scrubbingInProgress',
      6 => 'failed',
      9 => 'prefailed',
      10 => 'offline',
  );
  my $oid_raidPStatus = '.1.3.6.1.4.1.789.1.6.10.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_raidPStatus };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking raids");
      $self->{components}->{raid} = {name => 'raids', total => 0, skip => 0};
      return if ($self->check_filter(section => 'raid'));
  
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{results}->{$oid_raidPStatus}})) {
          $oid =~ /^$oid_raidPStatus\.(.*)$/;
          my $instance = $1;
          my $raid_state = $map_raid_states{$self->{results}->{$oid_raidPStatus}->{$oid}};
  
          next if ($self->check_filter(section => 'raid', instance => $instance));
          
          $self->{components}->{raid}->{total}++;
          $self->{output}->output_add(long_msg => sprintf("Raid '%s' state is '%s'", 
                                                          $instance, $raid_state));
          my $exit = $self->get_severity(section => 'raid', value => $raid_state);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Raid '%s' state is '%s'", 
                                                               $instance, $raid_state));
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_RAID

$fatpacked{"storage/netapp/ontap/snmp/mode/components/temperature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_TEMPERATURE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::temperature;
  
  use strict;
  use warnings;
  
  my %map_hum_status = (
      1 => 'noStatus',
      2 => 'normal',
      3 => 'highWarning',
      4 => 'highCritical',
      5 => 'lowWarning',
      6 => 'lowCritical',
      7 => 'sensorError',
  );
  my %map_hum_online = (
      1 => 'online',
      2 => 'offline',
  );
  
  my $mapping = {
      enclTempSensorsPresent => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.20' },
      enclTempSensorsOverTempFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.21' },
      enclTempSensorsOverTempWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.22' },
      enclTempSensorsUnderTempFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.23' },
      enclTempSensorsUnderTempWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.24' },
      enclTempSensorsCurrentTemp => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.25' },
      enclTempSensorsOverTempFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.26' },
      enclTempSensorsOverTempWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.27' },
      enclTempSensorsUnderTempFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.28' },
      enclTempSensorsUnderTempWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.29' },
  };
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclEntry = '.1.3.6.1.4.1.789.1.21.1.2.1';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclEntry, start => $mapping->{enclTempSensorsPresent}->{oid}, end => $mapping->{enclTempSensorsUnderTempWarnThr}->{oid} };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking temperatures");
      $self->{components}->{temperature} = {name => 'temperatures', total => 0, skip => 0};
      return if ($self->check_filter(section => 'temperature'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_enclEntry}, instance => $i);
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my @current_temp = split /,/, $result->{enclTempSensorsCurrentTemp};
          
          my @warn_under_thr = split /,/, $result->{enclTempSensorsUnderTempWarnThr};
          my @crit_under_thr = split /,/, $result->{enclTempSensorsUnderTempFailThr};
          my @warn_over_thr = split /,/, $result->{enclTempSensorsOverTempWarnThr};
          my @crit_over_thr = split /,/, $result->{enclTempSensorsOverTempFailThr};
  
          foreach my $num (split /,/, $result->{enclTempSensorsPresent}) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/ || !defined($current_temp[$num - 1]));
              
              next if ($self->check_filter(section => 'temperature', instance => $shelf_addr . '.' . $num));
      
              $warn_under_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $wu_thr = $1;
              $crit_under_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $cu_thr = $1;
              $warn_over_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $wo_thr = $1;
              $crit_over_thr[$num - 1] =~ /(-*[0-9]+)C/;
              my $co_thr = $1;
              $current_temp[$num - 1] =~ /(-*[0-9]+)C/;
              my $current_value = $1;
              
              $self->{components}->{temperature}->{total}++;
              
              my $status = 'ok';
              if ($result->{enclTempSensorsUnderTempFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under critical threshold';
              } elsif ($result->{enclTempSensorsUnderTempWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under warning threshold';
              } elsif ($result->{enclTempSensorsOverTempFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over critical threshold';
              } elsif ($result->{enclTempSensorsOverTempWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over warning threshold';
              }
              
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s [current = %s]", 
                                                              $shelf_addr, $num, $status, $current_value));
              my $exit = $self->get_severity(section => 'temperature', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s", 
                                                                   $shelf_addr, $num, $status));
              }
              
              my $warn = $wu_thr . ':' . $wo_thr;
              my $crit = $cu_thr . ':' . $co_thr;
              my ($exit2, $warn2, $crit2, $checked) = $self->get_severity_numeric(section => 'temperature', instance => $shelf_addr . '.' . $num, value => $current_value);
              if ($checked == 1) { 
                 ($warn, $crit) = ($warn2, $crit2);
              }
              
              if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit2,
                                              short_msg => sprintf("Shelve '%s' temperature sensor '%s' is %s degree centigrade", 
                                                                   $shelf_addr, $num, $current_value));
              }
              
              $self->{output}->perfdata_add(
                  label => "temp", unit => 'C',
                  nlabel => 'hardware.temperature.celsius',
                  instances => [$shelf_addr, $num],
                  value => $current_value,
                  warning => $warn,
                  critical => $crit
              );
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_TEMPERATURE

$fatpacked{"storage/netapp/ontap/snmp/mode/components/voltage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_VOLTAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::components::voltage;
  
  use strict;
  use warnings;
  
  my %map_hum_status = (
      1 => 'noStatus',
      2 => 'normal',
      3 => 'highWarning',
      4 => 'highCritical',
      5 => 'lowWarning',
      6 => 'lowCritical',
      7 => 'sensorError',
  );
  my %map_hum_online = (
      1 => 'online',
      2 => 'offline',
  );
  
  my $mapping = {
      enclVoltSensorsPresent => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.35' },
      enclVoltSensorsOverVoltFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.36' },
      enclVoltSensorsOverVoltWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.37' },
      enclVoltSensorsUnderVoltFail => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.38' },
      enclVoltSensorsUnderVoltWarn => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.39' },
      enclVoltSensorsCurrentVolt => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.40' },
      enclVoltSensorsOverVoltFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.41' },
      enclVoltSensorsOverVoltWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.42' },
      enclVoltSensorsUnderVoltFailThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.43' },
      enclVoltSensorsUnderVoltWarnThr => { oid => '.1.3.6.1.4.1.789.1.21.1.2.1.44' },
  };
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  my $oid_enclTable = '.1.3.6.1.4.1.789.1.21.1.2';
  
  sub load {
      my ($self) = @_;
      
      push @{$self->{request}}, { oid => $oid_enclTable, start => $mapping->{enclVoltSensorsPresent}->{oid}, end => $mapping->{enclVoltSensorsUnderVoltWarnThr}->{oid} };
  }
  
  sub check {
      my ($self) = @_;
  
      $self->{output}->output_add(long_msg => "Checking voltages");
      $self->{components}->{voltage} = {name => 'voltages', total => 0, skip => 0};
      return if ($self->check_filter(section => 'voltage'));
  
      for (my $i = 1; $i <= $self->{number_shelf}; $i++) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $self->{results}->{$oid_enclTable}, instance => $i);
          my $shelf_addr = $self->{shelf_addr}->{$oid_enclChannelShelfAddr . '.' . $i};
          my @current_volt = defined($result->{enclVoltSensorsCurrentVolt}) ? split /,/, $result->{enclVoltSensorsCurrentVolt} : ();
          
          my @warn_under_thr = defined($result->{enclVoltSensorsUnderVoltWarnThr}) ? split /,/, $result->{enclVoltSensorsUnderVoltWarnThr} : ();
          my @crit_under_thr = defined($result->{enclVoltSensorsUnderVoltFailThr}) ? split /,/, $result->{enclVoltSensorsUnderVoltFailThr} : ();
          my @warn_over_thr = defined($result->{enclVoltSensorsOverVoltWarnThr}) ? split /,/, $result->{enclVoltSensorsOverVoltWarnThr} : ();
          my @crit_over_thr = defined($result->{enclVoltSensorsOverVoltFailThr}) ? split /,/, $result->{enclVoltSensorsOverVoltFailThr} : ();
  
          my @values = defined($result->{enclVoltSensorsPresent}) ? split /,/, $result->{enclVoltSensorsPresent} : ();
          foreach my $num (@values) {
              $num = centreon::plugins::misc::trim($num);
              next if ($num !~ /[0-9]/ || !defined($current_volt[$num - 1]));
      
              my $wu_thr = (defined($warn_under_thr[$num - 1]) && $warn_under_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $cu_thr = (defined($crit_under_thr[$num - 1]) && $crit_under_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $wo_thr = (defined($warn_over_thr[$num - 1]) && $warn_over_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $co_thr = (defined($crit_over_thr[$num - 1]) && $crit_over_thr[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              my $current_value = ($current_volt[$num - 1] =~ /(^|\s)(-*[0-9]+)/) ? $2 : '';
              
              next if ($self->check_filter(section => 'voltage', instance => $shelf_addr . '.' . $num));
              $self->{components}->{voltage}->{total}++;
              
              my $status = 'ok';
              if ($result->{enclVoltSensorsUnderVoltFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under critical threshold';
              } elsif ($result->{enclVoltSensorsUnderVoltWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'under warning threshold';
              } elsif ($result->{enclVoltSensorsOverVoltFailThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over critical threshold';
              } elsif ($result->{enclVoltSensorsOverVoltWarnThr} =~ /(^|,|\s)$num(,|\s|$)/) {
                  $status = 'over warning threshold';
              }
              
              $self->{output}->output_add(long_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s [current = %s]", 
                                                              $shelf_addr, $num, $status, $current_value));
              my $exit = $self->get_severity(section => 'voltage', value => $status);
              if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s", 
                                                                   $shelf_addr, $num, $status));
              }
              
              my $warn = $wu_thr . ':' . $wo_thr;
              my $crit = $cu_thr . ':' . $co_thr;
              my ($exit2, $warn2, $crit2, $checked) = $self->get_severity_numeric(section => 'voltage', instance => $shelf_addr . '.' . $num, value => $current_value);
              if ($checked == 1) { 
                 ($warn, $crit) = ($warn2, $crit2);
              }
              
              if (!$self->{output}->is_status(value => $exit2, compare => 'ok', litteral => 1)) {
                  $self->{output}->output_add(severity => $exit2,
                                              short_msg => sprintf("Shelve '%s' voltage sensor '%s' is %s mV", 
                                                                   $shelf_addr, $num, $current_value));
              }
              
              $self->{output}->perfdata_add(
                  label => "volt", unit => 'mV',
                  nlabel => 'hardware.voltage.millivolt',
                  instances => [$shelf_addr, $num],
                  value => $current_value,
                  warning => $warn,
                  critical => $crit
              );
          }
      }
  }
  
  1;
STORAGE_NETAPP_ONTAP_SNMP_MODE_COMPONENTS_VOLTAGE

$fatpacked{"storage/netapp/ontap/snmp/mode/cpstatistics.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_CPSTATISTICS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::cpstatistics;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1, -11 => 1 } }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'timer', nlabel => 'storage.cp.timer.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'timer', diff => 1 }, ],
                  output_template => 'CP timer : %s',
                  perfdatas => [
                      { value => 'timer', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'snapshot', nlabel => 'storage.cp.snapshot.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'snapshot', diff => 1 }, ],
                  output_template => 'CP snapshot : %s',
                  perfdatas => [
                      { value => 'snapshot', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowerwater', nlabel => 'storage.cp.lowerwatermark.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowerwater', diff => 1 }, ],
                  output_template => 'CP low water mark : %s',
                  perfdatas => [
                      { value => 'lowerwater', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'highwater', nlabel => 'storage.cp.highwatermark.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'highwater', diff => 1 }, ],
                  output_template => 'CP high water mark : %s',
                  perfdatas => [
                      { value => 'highwater', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'logfull', nlabel => 'storage.cp.logfull.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'logfull', diff => 1 }, ],
                  output_template => 'CP nv-log full : %s',
                  perfdatas => [
                      { value => 'logfull', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'back', nlabel => 'storage.cp.back2back.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'back', diff => 1 }, ],
                  output_template => 'CP back-to-back : %s',
                  perfdatas => [
                      { value => 'back', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'flush', nlabel => 'storage.cp.flushunlog.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'flush', diff => 1 }, ],
                  output_template => 'CP flush unlogged write data : %s',
                  perfdatas => [
                      { value => 'flush', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'sync', nlabel => 'storage.cp.syncrequests.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'sync', diff => 1 }, ],
                  output_template => 'CP sync requests : %s',
                  perfdatas => [
                      { value => 'sync', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowvbuf', nlabel => 'storage.cp.lowvirtualbuffers.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowvbuf', diff => 1 }, ],
                  output_template => 'CP low virtual buffers : %s',
                  perfdatas => [
                      { value => 'lowvbuf', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'deferred', nlabel => 'storage.cp.deferred.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'deferred', diff => 1 }, ],
                  output_template => 'CP deferred : %s',
                  perfdatas => [
                      { value => 'deferred', template => '%d', min => 0 },
                  ],
              }
          },
          { label => 'lowdatavecs', nlabel => 'storage.cp.lowdatavecs.operations.count', display_ok => 0, set => {
                  key_values => [ { name => 'lowdatavecs', diff => 1 }, ],
                  output_template => 'CP low datavecs : %s',
                  perfdatas => [
                      { value => 'lowdatavecs', template => '%d', min => 0 },
                  ],
              }
          },
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $oid_cpFromTimerOps = '.1.3.6.1.4.1.789.1.2.6.2.0';
  my $oid_cpFromSnapshotOps = '.1.3.6.1.4.1.789.1.2.6.3.0';
  my $oid_cpFromLowWaterOps = '.1.3.6.1.4.1.789.1.2.6.4.0';
  my $oid_cpFromHighWaterOps = '.1.3.6.1.4.1.789.1.2.6.5.0';
  my $oid_cpFromLogFullOps = '.1.3.6.1.4.1.789.1.2.6.6.0';
  my $oid_cpFromCpOps = '.1.3.6.1.4.1.789.1.2.6.7.0';
  my $oid_cpTotalOps = '.1.3.6.1.4.1.789.1.2.6.8.0';
  my $oid_cpFromFlushOps = '.1.3.6.1.4.1.789.1.2.6.9.0';
  my $oid_cpFromSyncOps = '.1.3.6.1.4.1.789.1.2.6.10.0';
  my $oid_cpFromLowVbufOps = '.1.3.6.1.4.1.789.1.2.6.11.0';
  my $oid_cpFromCpDeferredOps = '.1.3.6.1.4.1.789.1.2.6.12.0';
  my $oid_cpFromLowDatavecsOps = '.1.3.6.1.4.1.789.1.2.6.13.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $request = [
          $oid_cpFromTimerOps, $oid_cpFromSnapshotOps,
          $oid_cpFromLowWaterOps, $oid_cpFromHighWaterOps,
          $oid_cpFromLogFullOps, $oid_cpFromCpOps,
          $oid_cpTotalOps, $oid_cpFromFlushOps,
          $oid_cpFromSyncOps, $oid_cpFromLowVbufOps,
          $oid_cpFromCpDeferredOps, $oid_cpFromLowDatavecsOps
      ];
      
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'All CP statistics are ok'
      );
  
      $self->{global} = {};
      $self->{global}->{timer} = defined($snmp_result->{$oid_cpFromTimerOps}) ? $snmp_result->{$oid_cpFromTimerOps} : undef;
      $self->{global}->{snapshot} = defined($snmp_result->{$oid_cpFromSnapshotOps}) ? $snmp_result->{$oid_cpFromSnapshotOps} : undef;
      $self->{global}->{lowerwater} = defined($snmp_result->{$oid_cpFromLowWaterOps}) ? $snmp_result->{$oid_cpFromLowWaterOps} : undef;
      $self->{global}->{highwater} = defined($snmp_result->{$oid_cpFromHighWaterOps}) ? $snmp_result->{$oid_cpFromHighWaterOps} : undef;
      $self->{global}->{logfull} = defined($snmp_result->{$oid_cpFromLogFullOps}) ? $snmp_result->{$oid_cpFromLogFullOps} : undef;
      $self->{global}->{back} = defined($snmp_result->{$oid_cpFromCpOps}) ? $snmp_result->{$oid_cpFromCpOps} : undef;
      $self->{global}->{flush} = defined($snmp_result->{$oid_cpFromFlushOps}) ? $snmp_result->{$oid_cpFromFlushOps} : undef;
      $self->{global}->{sync} = defined($snmp_result->{$oid_cpFromSyncOps}) ? $snmp_result->{$oid_cpFromSyncOps} : undef;
      $self->{global}->{lowvbuf} = defined($snmp_result->{$oid_cpFromLowVbufOps}) ? $snmp_result->{$oid_cpFromLowVbufOps} : undef;
      $self->{global}->{deferred} = defined($snmp_result->{$oid_cpFromCpDeferredOps}) ? $snmp_result->{$oid_cpFromCpDeferredOps} : undef;
      $self->{global}->{lowdatavecs} = defined($snmp_result->{$oid_cpFromLowDatavecsOps}) ? $snmp_result->{$oid_cpFromLowDatavecsOps} : undef;
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check consistency point metrics.
  
  =over 8
  
  =item B<--warning-*>
  
  Warning threshold.
  Can be: 'timer', 'snapshot', 'lowerwater', 'highwater', 
  'logfull', 'back', 'flush', 'sync', 'lowvbuf', 'deferred', 'lowdatavecs'.
  
  =item B<--critical-*>
  
  Critical threshold.
  Can be: 'timer', 'snapshot', 'lowerwater', 'highwater', 
  'logfull', 'back', 'flush', 'sync', 'lowvbuf', 'deferred', 'lowdatavecs'.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_CPSTATISTICS

$fatpacked{"storage/netapp/ontap/snmp/mode/cpuload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_CPULOAD';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::cpuload;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'warning:s'  => { name => 'warning' },
          'critical:s' => { name => 'critical' }
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cpuBusyTimePerCent = '.1.3.6.1.4.1.789.1.2.1.3.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_cpuBusyTimePerCent], nothing_quit => 1);
      
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_cpuBusyTimePerCent}, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("CPU Usage %d %%", $result->{$oid_cpuBusyTimePerCent}));
      $self->{output}->perfdata_add(label => 'cpuload', unit => '%',
                                    value => sprintf("%d", $result->{$oid_cpuBusyTimePerCent}),
                                    warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning'),
                                    critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical'),
                                    min => 0, max => 100);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check CPU usage.
  
  =over 8
  
  =item B<--warning>
  
  Warning threshold in percent.
  
  =item B<--critical>
  
  Critical threshold in percent.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_CPULOAD

$fatpacked{"storage/netapp/ontap/snmp/mode/diskfailed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_DISKFAILED';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::diskfailed;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_diskFailedCount = '.1.3.6.1.4.1.789.1.6.4.7.0';
      my $oid_diskFailedMessage = '.1.3.6.1.4.1.789.1.6.4.10.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_diskFailedCount], nothing_quit => 1);
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'Disks are ok.');
      if ($result->{$oid_diskFailedCount} != 0) {
          $self->{output}->output_add(severity => 'CRITICAL',
                                      short_msg => sprintf("'%d' disks are failed [message: %s].", 
                                                      $result->{$oid_diskFailedCount}, 
                                                      defined($result->{$oid_diskFailedMessage}) ? $result->{$oid_diskFailedMessage} : '-'));
      }
  
      $self->{output}->perfdata_add(label => 'failed',
                                    value => $result->{$oid_diskFailedCount},
                                    min => 0);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check the current number of disk broken.
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_DISKFAILED

$fatpacked{"storage/netapp/ontap/snmp/mode/failover.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_FAILOVER';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::failover;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold catalog_status_calc);
  
  sub custom_cluster_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "cluster status is '%s' [partner status: %s][reason cannot takeover: %s]",
          $self->{result_values}->{cluster_status},
          $self->{result_values}->{partner_status},
          $self->{result_values}->{reason_cannot_takeover}
      );
  }
  
  sub custom_node_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "status is '%s' [partner status: %s][reason cannot takeover: %s]",
          $self->{result_values}->{status},
          $self->{result_values}->{partner_status},
          $self->{result_values}->{reason_cannot_takeover}
      );
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } },
          { name => 'nodes', type => 1, cb_prefix_output => 'prefix_node_output', message_multiple => 'All high-availability nodes are OK' },
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'cluster-status', set => {
                  key_values => [ { name => 'cluster_status' }, { name => 'reason_cannot_takeover' }, { name => 'partner_status' } ],
                  closure_custom_calc => \&catalog_status_calc,
                  closure_custom_output => $self->can('custom_cluster_output'),
                  closure_custom_threshold_check => \&catalog_status_threshold,
                  closure_custom_perfdata => sub { return 0; },
              }
          }
      ];
  
      $self->{maps_counters}->{nodes} = [
          { label => 'node-status', threshold => 0,  set => {
                  key_values => [ { name => 'status' }, { name => 'reason_cannot_takeover' }, { name => 'partner_status' }, { name => 'display' } ],
                  closure_custom_calc => \&catalog_status_calc,
                  closure_custom_output => $self->can('custom_node_output'),
                  closure_custom_threshold_check => \&catalog_status_threshold,
                  closure_custom_perfdata => sub { return 0; },
              }
          }
      ];
  }
  
  sub prefix_node_output {
      my ($self, %options) = @_;
  
      return "Node '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-node:s'             => { name => 'filter_node' },
          'unknown-cluster-status:s'  => { name => 'unknown_cluster_status', default => '' },
          'warning-cluster-status:s'  => { name => 'warning_cluster_status', default => '%{cluster_status} =~ /^takeover|partialGiveback/i' },
          'critical-cluster-status:s' => { name => 'critical_cluster_status', default => '%{cluster_status} =~ /dead|cannotTakeover/i' },
          'unknown-node-status:s'     => { name => 'unknown_node_status', default => '' },
          'warning-node-status:s'     => { name => 'warning_node_status', default => '%{status} =~ /^takeover|partialGiveback/i' },
          'critical-node-status:s'    => { name => 'critical_node_status', default => '%{status} =~ /dead|cannotTakeover/i' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => [
          'unknown_cluster_status', 'warning_cluster_status', 'critical_cluster_status',
          'unknown_node_status', 'warning_node_status', 'critical_node_status'
      ]);
  }
  
  my $map_cannot_takeover = {
      1 => 'ok', 2 => 'unknownReason',
      3 => 'disabledByOperator', 4 => 'interconnectOffline',
      5 => 'disabledByPartner', 6 => 'takeoverFailed',
      7 => 'mailboxIsInDegradedState', 8 => 'partnermailboxIsInUninitialisedState',
      9 => 'mailboxVersionMismatch', 10 => 'nvramSizeMismatch',
      11 => 'kernelVersionMismatch', 12 => 'partnerIsInBootingStage',
      13 => 'diskshelfIsTooHot', 14 => 'partnerIsPerformingRevert',
      15 => 'nodeIsPerformingRevert', 16 => 'sametimePartnerIsAlsoTryingToTakeUsOver',
      17 => 'alreadyInTakenoverMode', 18 => 'nvramLogUnsynchronized',
      19 => 'stateofBackupMailboxIsDoubtful', 19 => 'stateofBackupMailboxIsDoubtful'
  };
  my $map_state = {
      1 => 'dead', 2 => 'canTakeover',
      3 => 'cannotTakeover', 4 => 'takeover',
      5 => 'partialGiveback'
  };
  my $map_partner_status = {
      1 => 'maybeDown', 2 => 'ok', 3 => 'dead'
  };
  
  my $mapping_cf = {
      cfState               => { oid => '.1.3.6.1.4.1.789.1.2.3.2', map => $map_state },
      cfCannotTakeoverCause => { oid => '.1.3.6.1.4.1.789.1.2.3.3', map => $map_cannot_takeover },
      cfPartnerStatus       => { oid => '.1.3.6.1.4.1.789.1.2.3.4', map => $map_partner_status },
  };
  my $mapping_ha = {
      haState               => { oid => '.1.3.6.1.4.1.789.1.21.2.1.4', map => $map_state },
      haCannotTakeoverCause => { oid => '.1.3.6.1.4.1.789.1.21.2.1.5', map => $map_cannot_takeover },
      haPartnerStatus       => { oid => '.1.3.6.1.4.1.789.1.21.2.1.6', map => $map_partner_status },
  };
  my $oid_cf = '.1.3.6.1.4.1.789.1.2.3';
  my $oid_haEntry = '.1.3.6.1.4.1.789.1.21.2.1';
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [
              { oid => $oid_cf, start => $mapping_cf->{cfState}->{oid}, end => $mapping_cf->{cfPartnerStatus}->{oid} },
              { oid => $oid_haEntry, start => $mapping_ha->{haState}->{oid}, end => $mapping_ha->{haPartnerStatus}->{oid} },
          ],
          nothing_quit => 1
      );
      my $result = $options{snmp}->map_instance(mapping => $mapping_cf, results => $snmp_result->{$oid_cf}, instance => '0');
      $self->{global} = {
          cluster_status => $result->{cfState},
          reason_cannot_takeover => $result->{cfCannotTakeoverCause},
          partner_status => $result->{cfPartnerStatus}
      };
  
      $self->{nodes} = {};
      foreach my $oid (keys %{$snmp_result->{$oid_haEntry}}) {
          next if ($oid !~ /^$mapping_ha->{haState}->{oid}\.(.*)$/);
          my $instance = $1;
  
          $result = $options{snmp}->map_instance(mapping => $mapping_ha, results => $snmp_result->{$oid_haEntry}, instance => $instance);
          my $name = $self->{output}->decode(join('', map(chr($_), split(/\./, $instance))));
          if (defined($self->{option_results}->{filter_node}) && $self->{option_results}->{filter_node} ne '' &&
              $name !~ /$self->{option_results}->{filter_node}/) {
              $self->{output}->output_add(long_msg => "skipping node '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{nodes}->{$instance} = {
              display => $name,
              status => $result->{haState},
              reason_cannot_takeover => $result->{haCannotTakeoverCause},
              partner_status => $result->{haPartnerStatus}
          };
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check failover status.
  
  =over 8
  
  =item B<--filter-node>
  
  Filter name with regexp (based on serial)
  
  =item B<--unknown-cluster-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{cluster_status}, %{reason_cannot_takeover}, %{partner_status}
  
  =item B<--warning-cluster-status>
  
  Define the conditions to match for the status to be WARNING (default: '%{cluster_status} =~ /^takeover|partialGiveback/i').
  You can use the following variables: %{cluster_status}, %{reason_cannot_takeover}, %{partner_status}
  
  =item B<--critical-cluster-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{cluster_status} =~ /dead|cannotTakeover/i').
  You can use the following variables: %{cluster_status}, %{reason_cannot_takeover}, %{partner_status}
  
  =item B<--unknown-node-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{status}, %{reason_cannot_takeover}, %{partner_status}, %{display}
  
  =item B<--warning-node-status>
  
  Define the conditions to match for the status to be WARNING (default: '%{status} =~ /^takeover|partialGiveback/i').
  You can use the following variables: %{status}, %{reason_cannot_takeover}, %{partner_status}, %{display}
  
  =item B<--critical-node-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{status} =~ /dead|cannotTakeover/i').
  You can use the following variables: %{status}, %{reason_cannot_takeover}, %{partner_status}, %{display}
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_FAILOVER

$fatpacked{"storage/netapp/ontap/snmp/mode/fan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_FAN';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::fan;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envFailedFanCount = '.1.3.6.1.4.1.789.1.2.4.2';
      my $oid_envFailedFanMessage = '.1.3.6.1.4.1.789.1.2.4.3';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvFailedFanCount = '.1.3.6.1.4.1.789.1.25.2.1.19';
      my $oid_nodeEnvFailedFanMessage = '.1.3.6.1.4.1.789.1.25.2.1.20';
      my $results = $self->{snmp}->get_multiple_table(
          oids => [
              { oid => $oid_envFailedFanCount }, 
              { oid => $oid_envFailedFanMessage },
              { oid => $oid_nodeName },
              { oid => $oid_nodeEnvFailedFanCount },
              { oid => $oid_nodeEnvFailedFanMessage }
          ],
          nothing_quit => 1
      );
      
      if (defined($results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'})) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => 'Fans are ok.'
          );
          if ($results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'} != 0) {
              $self->{output}->output_add(
                  severity => 'CRITICAL',
                  short_msg => sprintf(
                      "'%d' fans are failed [message: %s].", 
                      $results->{$oid_envFailedFanCount}->{$oid_envFailedFanCount . '.0'},
                      $results->{$oid_envFailedFanMessage}->{$oid_envFailedFanMessage . '.0'}
                  )
              );
          }
      } else {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => 'Fans are ok on all nodes'
          );
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvFailedFanCount}})) {
              $oid =~ /^$oid_nodeEnvFailedFanCount\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $count = $results->{$oid_nodeEnvFailedFanCount}->{$oid};
              my $message = $results->{$oid_nodeEnvFailedFanMessage}->{$oid_nodeEnvFailedFanMessage . '.' . $instance};
              $self->{output}->output_add(
                  long_msg => sprintf(
                      "'%d' fans are failed on node '%s' [message: %s]", 
                      $count, $name, defined($message) ? $message : '-'
                  )
              );
              if ($count != 0) {
                  $self->{output}->output_add(
                      severity => 'CRITICAL',
                      short_msg => sprintf(
                          "'%d' fans are failed on node '%s' [message: %s]", 
                          $count, $name, defined($message) ? $message : '-'
                      )
                  );
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if fans are failed (not operating within the recommended RPM range).
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_FAN

$fatpacked{"storage/netapp/ontap/snmp/mode/filesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_FILESYS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::filesys;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold catalog_status_calc);
  
  sub custom_vs_status_output {
      my ($self, %options) = @_;
  
      my $msg = sprintf(
          "vserver '%s' status : %s",
          $self->{result_values}->{vserver_name},
          $self->{result_values}->{vserver_status},
      );
      return $msg;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'fs', type => 1, cb_prefix_output => 'prefix_fs_output', message_multiple => 'All filesystems are ok', skipped_code => { -10 => 1 } },
      ];
      
      $self->{maps_counters}->{fs} = [
          { label => 'usage', set => {
                  key_values => [ { name => 'display' }, { name => 'used' }, { name => 'total' } ],
                  closure_custom_calc => $self->can('custom_usage_calc'),
                  closure_custom_output => $self->can('custom_usage_output'),
                  closure_custom_perfdata => $self->can('custom_usage_perfdata'),
                  closure_custom_threshold_check => $self->can('custom_usage_threshold'),
              }
          },
          { label => 'inodes', set => {
                  key_values => [ { name => 'dfPerCentInodeCapacity' }, { name => 'display' } ],
                  output_template => 'Inodes Used : %s %%', output_error_template => "Inodes : %s",
                  perfdatas => [
                      { label => 'inodes', value => 'dfPerCentInodeCapacity', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'compresssaved', set => {
                  key_values => [ { name => 'dfCompressSavedPercent' }, { name => 'display' } ],
                  output_template => 'Compress Saved : %s %%', output_error_template => "Compress Saved : %s",
                  perfdatas => [
                      { label => 'compresssaved', value => 'dfCompressSavedPercent', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'dedupsaved', set => {
                  key_values => [ { name => 'dfDedupeSavedPercent' }, { name => 'display' } ],
                  output_template => 'Dedupe Saved : %s %%', output_error_template => "Dedupe Saved : %s",
                  perfdatas => [
                      { label => 'dedupsaved', value => 'dfDedupeSavedPercent', template => '%d',
                         unit => '%', min => 0, max => 100, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'vserver-status', threshold => 0, set => {
                  key_values => [ { name => 'vserver_status' }, { name => 'vserver_name' } ],
                  closure_custom_calc => \&catalog_status_calc,
                  closure_custom_output => $self->can('custom_vs_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub custom_usage_perfdata {
      my ($self, %options) = @_;
      
      return if ($self->{result_values}->{total} <= 0);
      my $label = 'used';
      my $value_perf = $self->{result_values}->{used};
      if (defined($self->{instance_mode}->{option_results}->{free})) {
          $label = 'free';
          $value_perf = $self->{result_values}->{free};
      }
  
      my %total_options = ();
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $total_options{total} = $self->{result_values}->{total};
          $total_options{cast_int} = 1;
      }
  
      $self->{output}->perfdata_add(
          label => $label, unit => 'B',
          instances => $self->use_instances(extra_instance => $options{extra_instance}) ? $self->{result_values}->{display} : undef,
          value => $value_perf,
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}, %total_options),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}, %total_options),
          min => 0, max => $self->{result_values}->{total}
      );
  }
  
  sub custom_usage_threshold {
      my ($self, %options) = @_;
      
      return 'ok' if ($self->{result_values}->{total} <= 0);
      my ($exit, $threshold_value);
      $threshold_value = $self->{result_values}->{used};
      $threshold_value = $self->{result_values}->{free} if (defined($self->{instance_mode}->{option_results}->{free}));
      if ($self->{instance_mode}->{option_results}->{units} eq '%') {
          $threshold_value = $self->{result_values}->{prct_used};
          $threshold_value = $self->{result_values}->{prct_free} if (defined($self->{instance_mode}->{option_results}->{free}));
      }
      $exit = $self->{perfdata}->threshold_check(value => $threshold_value, threshold => [ { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' }, { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' } ]);
      return $exit;
  }
  
  sub custom_usage_output {
      my ($self, %options) = @_;
      
      my $msg;
      if ($self->{result_values}->{total} == 0) {
          $msg = 'skipping: total size is 0';
      } elsif ($self->{result_values}->{total} < 0) {
          $msg = 'skipping: negative total value (maybe use snmp v2c)';
      } else {
          my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
          my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
          my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
          $msg = sprintf("Total: %s Used: %s (%.2f%%) Free: %s (%.2f%%)",
                     $total_size_value . " " . $total_size_unit,
                     $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
                     $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free});
      }
      return $msg;
  }
  
  sub custom_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};    
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'};
  
      return 0 if ($options{new_datas}->{$self->{instance} . '_total'} == 0);
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
  
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      # snapshot can be over 100%
      if ($self->{result_values}->{free} < 0) {
          $self->{result_values}->{free} = 0;
          $self->{result_values}->{prct_free} = 0;
      }
      
      return 0;
  }
  
  sub prefix_fs_output {
      my ($self, %options) = @_;
      
      return "Filesys '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'units:s'                   => { name => 'units', default => '%' },
          'free'                      => { name => 'free' },
          'filter-name:s'             => { name => 'filter_name' },
          'filter-type:s'             => { name => 'filter_type' },
          'filter-vserver:s'          => { name => 'filter_vserver' },
          'filter-vserver-state:s'    => { name => 'filter_vserver_state' },
          'unknown-vserver-status:s'  => { name => 'unknown_vserver_status', default => '' },
          'warning-vserver-status:s'  => { name => 'warning_vserver_status', default => '' },
          'critical-vserver-status:s' => { name => 'critical_vserver_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_vserver_status', 'critical_vserver_status', 'unknown_vserver_status']);
  }
  
  my $map_types = {
      1 => 'traditionalVolume',
      2 => 'flexibleVolume',
      3 => 'aggregate',
      4 => 'stripedAggregate',
      5 => 'stripedVolume'
  };
  my $map_vserver_state = {
      0 => 'running', 1 => 'stopped', 2 => 'starting', 3 => 'stopping'
  };
  my $mapping = {
      dfType      => { oid => '.1.3.6.1.4.1.789.1.5.4.1.23', map => $map_types },
  };
  my $mapping2 = {
      dfFileSys               => { oid => '.1.3.6.1.4.1.789.1.5.4.1.2' },
      dfKBytesTotal           => { oid => '.1.3.6.1.4.1.789.1.5.4.1.3' },
      dfKBytesUsed            => { oid => '.1.3.6.1.4.1.789.1.5.4.1.4' },
      dfPerCentInodeCapacity  => { oid => '.1.3.6.1.4.1.789.1.5.4.1.9' },
      df64TotalKBytes         => { oid => '.1.3.6.1.4.1.789.1.5.4.1.29' },
      df64UsedKBytes          => { oid => '.1.3.6.1.4.1.789.1.5.4.1.30' },
      dfVserver               => { oid => '.1.3.6.1.4.1.789.1.5.4.1.34' },
      dfCompressSavedPercent  => { oid => '.1.3.6.1.4.1.789.1.5.4.1.38' },
      dfDedupeSavedPercent    => { oid => '.1.3.6.1.4.1.789.1.5.4.1.40' },
  };
  my $mapping3 = {
      vserverName     => { oid => '.1.3.6.1.4.1.789.1.27.1.1.2' },
      vserverState    => { oid => '.1.3.6.1.4.1.789.1.27.1.1.16', map => $map_vserver_state },
  };
  
  sub get_vserver_state {
      my ($self, %options) = @_;
  
      return if (
          (!defined($self->{option_results}->{filter_vserver_state}) || $self->{option_results}->{filter_vserver} eq '') &&
          (!defined($self->{option_results}->{warning_vserver_status}) || $self->{option_results}->{warning_vserver_status} eq '') &&
          (!defined($self->{option_results}->{critical_vserver_status}) || $self->{option_results}->{critical_vserver_status} eq '') &&
          (!defined($self->{option_results}->{unknown_vserver_status}) || $self->{option_results}->{unknown_vserver_status} eq '')
      );
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [
              { oid => $mapping3->{vserverName}->{oid} }, 
              { oid => $mapping3->{vserverState}->{oid} }
          ],
          return_type => 1,
      );
      
      $self->{vserver} = {};
      foreach (keys %$snmp_result) {
          next if (! /^$mapping3->{vserverName}->{oid}\.(.*)/);
          my $result = $options{snmp}->map_instance(mapping => $mapping3, results => $snmp_result, instance => $1);
          $self->{vserver}->{$result->{vserverName}} = $result->{vserverState};
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my @oids = (
          $mapping2->{dfKBytesTotal}->{oid},
          $mapping2->{dfKBytesUsed}->{oid},
          $mapping2->{dfPerCentInodeCapacity}->{oid},
          $mapping2->{dfCompressSavedPercent}->{oid},
          $mapping2->{dfDedupeSavedPercent}->{oid},
          $mapping2->{dfVserver}->{oid},
      );
      if (!$options{snmp}->is_snmpv1()) {
          push @oids, $mapping2->{df64TotalKBytes}->{oid};
          push @oids, $mapping2->{df64UsedKBytes}->{oid};
      }
  
      $self->get_vserver_state(%options);
  
      my $results;
      if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '') {
          $results = $options{snmp}->get_multiple_table(
              oids => [
                  { oid => $mapping->{dfType}->{oid} }, 
                  { oid => $mapping2->{dfFileSys}->{oid} }
              ],
              return_type => 1,
              nothing_quit => 1
          );
      } else {
          $results = $options{snmp}->get_table(oid => $mapping2->{dfFileSys}->{oid}, nothing_quit => 1);
      }
      my @fs_selected;
      foreach my $oid (keys %{$results}) {
          next if ($oid !~ /^$mapping2->{dfFileSys}->{oid}\.(\d+)/);
          my $instance = $1;
          my $name = $results->{$oid};
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter name.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '' &&
              $map_types->{$results->{$mapping->{dfType}->{oid} . '.' . $instance}} !~ /$self->{option_results}->{filter_type}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $name . "': no matching filter type.", debug => 1);
              next;
          }
          push @fs_selected, $instance;
      }
  
      if (scalar(@fs_selected) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
  
      $self->{fs} = {};
      $options{snmp}->load(oids => \@oids, instances => \@fs_selected);
      my $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      foreach my $instance (sort @fs_selected) {
          my $result2 = $options{snmp}->map_instance(mapping => $mapping2, results => $snmp_result, instance => $instance);
  
          if (defined($result2->{dfVserver}) && $result2->{dfVserver} ne '' && 
              defined($self->{option_results}->{filter_vserver_state}) && $self->{option_results}->{filter_vserver_state} ne '' &&
              $self->{vserver}->{$result2->{dfVserver}} !~ /$self->{option_results}->{filter_vserver_state}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $instance . "': no matching filter vserver state.", debug => 1);
              next;
          }
          if (defined($result2->{dfVserver}) && defined($self->{option_results}->{filter_vserver}) && $self->{option_results}->{filter_vserver} ne '' &&
              $result2->{dfVserver} !~ /$self->{option_results}->{filter_vserver}/) {
              $self->{output}->output_add(long_msg => "skipping  '" . $instance . "': no matching filter vserver.", debug => 1);
              next;
          }
  
          $self->{fs}->{$instance} = {
              display => defined($result2->{dfVserver}) && $result2->{dfVserver} ne '' ? 
                  $result2->{dfVserver} . ':' . $results->{$mapping2->{dfFileSys}->{oid} . '.' . $instance} : 
                  $results->{$mapping2->{dfFileSys}->{oid} . '.' . $instance}
          };
          $self->{fs}->{$instance}->{total} = $result2->{dfKBytesTotal} * 1024;
          $self->{fs}->{$instance}->{used} = $result2->{dfKBytesUsed} * 1024;
          if (defined($result2->{df64TotalKBytes}) && $result2->{df64TotalKBytes} > 0) {
              $self->{fs}->{$instance}->{total} = $result2->{df64TotalKBytes} * 1024;
              $self->{fs}->{$instance}->{used} = $result2->{df64UsedKBytes} * 1024;
          }
          $self->{fs}->{$instance}->{dfCompressSavedPercent} = $result2->{dfCompressSavedPercent};
          $self->{fs}->{$instance}->{dfDedupeSavedPercent} = $result2->{dfDedupeSavedPercent};
          if ($self->{fs}->{$instance}->{total} > 0) {
              $self->{fs}->{$instance}->{dfPerCentInodeCapacity} = $result2->{dfPerCentInodeCapacity};
          }
  
          $self->{fs}->{$instance}->{vserver_name} = $result2->{dfVserver};
          $self->{fs}->{$instance}->{vserver_status} = defined($result2->{dfVserver}) ? $self->{vserver}->{$result2->{dfVserver}} : undef;
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check filesystem usage (volumes, snapshots and aggregates also).
  
  =over 8
  
  =item B<--unknown-vserver-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{vserver_status}, %{vserver_name}
  
  =item B<--warning-vserver-status>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{vserver_status}, %{vserver_name}
  
  =item B<--critical-vserver-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '').
  You can use the following variables: %{vserver_status}, %{vserver_name}
  
  =item B<--warning-*>
  
  Warning threshold.
  Can be: usage, inodes (%), compresssaved (%), dedupsaved (%).
  
  =item B<--critical-*>
  
  Critical threshold.
  Can be: usage, inodes (%), compresssaved (%), dedupsaved (%).
  
  =item B<--units>
  
  Units of thresholds (default: '%') ('%', 'B').
  
  =item B<--free>
  
  Thresholds are on free space left.
  
  =item B<--filter-name>
  
  Filter by filesystem name (can be a regexp).
  
  =item B<--filter-vserver>
  
  Filter by vserver name (can be a regexp).
  
  =item B<--filter-vserver-state>
  
  Filter by vserver state (can be a regexp).
  
  =item B<--filter-type>
  
  Filter filesystem type (can be a regexp. Example: 'flexibleVolume|aggregate').
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_FILESYS

$fatpacked{"storage/netapp/ontap/snmp/mode/globalstatus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_GLOBALSTATUS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::globalstatus;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'read', nlabel => 'storage.io.read.usage.bytespersecond', set => {
                  key_values => [ { name => 'read', per_second => 1 } ],
                  output_template => 'Read I/O : %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { template => '%d', unit => 'B/s', min => 0 }
                  ]
              }
          },
          { label => 'write', nlabel => 'storage.io.write.usage.bytespersecond', set => {
                  key_values => [ { name => 'write', per_second => 1 } ],
                  output_template => 'Write I/O : %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { template => '%d', unit => 'B/s', min => 0 }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {});
  
      return $self;
  }
  
  my %states = (
      1 => ['other', 'WARNING'], 
      2 => ['unknown', 'UNKNOWN'], 
      3 => ['ok', 'OK'], 
      4 => ['non critical', 'WARNING'],
      5 => ['critical', 'CRITICAL'],
      6 => ['nonRecoverable', 'WARNING']
  );
  my %fs_states = (
      1 => ['ok', 'OK'],
      2 => ['nearly full', 'WARNING'],
      3 => ['full', 'CRITICAL']
  );
  
  my $oid_fsOverallStatus = '.1.3.6.1.4.1.789.1.5.7.1.0';
  my $oid_fsStatusMessage = '.1.3.6.1.4.1.789.1.5.7.2.0';
  my $oid_miscGlobalStatus = '.1.3.6.1.4.1.789.1.2.2.4.0';
  my $oid_miscGlobalStatusMessage = '.1.3.6.1.4.1.789.1.2.2.25.0';
  my $oid_misc64DiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.32.0';
  my $oid_misc64DiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.33.0';
  my $oid_miscHighDiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.15.0';
  my $oid_miscLowDiskReadBytes = '.1.3.6.1.4.1.789.1.2.2.16.0';
  my $oid_miscHighDiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.17.0';
  my $oid_miscLowDiskWriteBytes = '.1.3.6.1.4.1.789.1.2.2.18.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $request = [
          $oid_fsOverallStatus, $oid_fsStatusMessage,
          $oid_miscGlobalStatus, $oid_miscGlobalStatusMessage, 
          $oid_miscHighDiskReadBytes, $oid_miscLowDiskReadBytes,
          $oid_miscHighDiskWriteBytes, $oid_miscLowDiskWriteBytes
      ];
      if (!$options{snmp}->is_snmpv1()) {
          push @{$request}, ($oid_misc64DiskReadBytes, $oid_misc64DiskWriteBytes);
      }
  
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
  
      $self->{global} = {};
      
      if (defined($snmp_result->{$oid_misc64DiskReadBytes})) {
          $self->{global}->{read} = $snmp_result->{$oid_misc64DiskReadBytes};
      } elsif (defined($snmp_result->{$oid_miscLowDiskReadBytes})) {
          $self->{global}->{read} = ($snmp_result->{$oid_miscHighDiskReadBytes} << 32) + $snmp_result->{$oid_miscLowDiskReadBytes};
      }
  
      if (defined($snmp_result->{$oid_misc64DiskWriteBytes})) {
          $self->{global}->{write} = $snmp_result->{$oid_misc64DiskWriteBytes};
      } elsif (defined($snmp_result->{$oid_miscLowDiskWriteBytes})) {
          $self->{global}->{write} = ($snmp_result->{$oid_miscHighDiskWriteBytes} << 32) + $snmp_result->{$oid_miscLowDiskWriteBytes};
      }
  
      $snmp_result->{$oid_miscGlobalStatusMessage} =~ s/\n//g;
      $self->{output}->output_add(
          severity =>  ${$states{$snmp_result->{$oid_miscGlobalStatus}}}[1],
          short_msg => sprintf(
              "Overall global status is '%s' [message: '%s']", 
              $states{ $snmp_result->{$oid_miscGlobalStatus} }->[0], $snmp_result->{$oid_miscGlobalStatusMessage}
          )
      );
  
      if (defined($snmp_result->{$oid_fsStatusMessage})) {
          $snmp_result->{$oid_fsStatusMessage} =~ s/\n//g;
          $self->{output}->output_add(
              severity =>  ${$fs_states{$snmp_result->{$oid_fsOverallStatus}}}[1],
              short_msg => sprintf(
                  "Overall file system status is '%s' [message: '%s']", 
                  $fs_states{ $snmp_result->{$oid_fsOverallStatus} }->[0], $snmp_result->{$oid_fsStatusMessage}
              )
          );
      }
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check the overall status of the appliance and some metrics (total read bytes per seconds and total write bytes per seconds).
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'read', 'write'.
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_GLOBALSTATUS

$fatpacked{"storage/netapp/ontap/snmp/mode/listclusternodes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTCLUSTERNODES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::listclusternodes;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my $mapping = {
      location => { oid => '.1.3.6.1.4.1.789.1.25.2.1.3' }, # nodeLocation
      model    => { oid => '.1.3.6.1.4.1.789.1.25.2.1.4' }, # nodeModel
      product  => { oid => '.1.3.6.1.4.1.789.1.25.2.1.23' }, # nodeProductVersion
      firmware => { oid => '.1.3.6.1.4.1.789.1.25.2.1.24' }  # nodeFirmwareVersion
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_name = '.1.3.6.1.4.1.789.1.25.2.1.1'; # nodeName
      my $snmp_result = $options{snmp}->get_table(oid => $oid_name);
      my $results = {};
      foreach (keys %$snmp_result) {
          /^$oid_name\.(.*)$/;
  
          $results->{$1} = { name => $snmp_result->{$_} };
      }
  
      $options{snmp}->load(
          oids => [ map($_->{oid}, values(%$mapping)) ],
          instances => [ map($_, keys(%$results)) ],
          instance_regexp => '^(.*)$'
      );
      $snmp_result = $options{snmp}->get_leef();
      foreach (keys %$results) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
  
          $results->{$_} = { %$result, %{$results->{$_}} };
      }
  
      return $results;
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $results = $self->manage_selection(snmp => $options{snmp});
      foreach my $instance (sort keys %$results) {
          $self->{output}->output_add(long_msg => 
              join('', map("[$_ = " . $results->{$instance}->{$_} . ']', ('name', keys(%$mapping))))
          );
      }
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'List cluster nodes:'
      );
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      $self->{output}->add_disco_format(elements => ['name', keys %$mapping]);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      my $results = $self->manage_selection(snmp => $options{snmp});
      foreach (sort keys %$results) {        
          $self->{output}->add_disco_entry(
              %{$results->{$_}}
          );
      }
  }
  1;
  
  
  =head1 MODE
  
  List cluster nodes.
  
  =over 8
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTCLUSTERNODES

$fatpacked{"storage/netapp/ontap/snmp/mode/listfilesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTFILESYS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::listfilesys;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'filter-name:s'   => { name => 'filter_name' },
          'filter-type:s'   => { name => 'filter_type' },
          'skip-total-zero' => { name => 'skip_total_zero' }
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my %map_types = (
      1 => 'traditionalVolume',
      2 => 'flexibleVolume',
      3 => 'aggregate',
      4 => 'stripedAggregate',
      5 => 'stripedVolume'
  );
  
  my $mapping = {
      dfFileSys       => { oid => '.1.3.6.1.4.1.789.1.5.4.1.2' },
      dfKBytesTotal   => { oid => '.1.3.6.1.4.1.789.1.5.4.1.3' },
      dfType          => { oid => '.1.3.6.1.4.1.789.1.5.4.1.23', map => \%map_types },
      df64TotalKBytes => { oid => '.1.3.6.1.4.1.789.1.5.4.1.29' },
      dfVserver       => { oid => '.1.3.6.1.4.1.789.1.5.4.1.34' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [ 
              { oid => $mapping->{dfFileSys}->{oid} },
              { oid => $mapping->{dfKBytesTotal}->{oid} },
              { oid => $mapping->{dfType}->{oid} },
              { oid => $mapping->{df64TotalKBytes}->{oid} },
              { oid => $mapping->{dfVserver}->{oid} },
          ],
          return_type => 1,
          nothing_quit => 1
      );
  
      $self->{fs} = {};
      foreach my $oid (keys %$snmp_result) {
          next if ($oid !~ /^$mapping->{dfFileSys}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $result->{dfFileSys} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{dfFileSys} . "': no matching filter.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_type}) && $self->{option_results}->{filter_type} ne '' &&
              $result->{dfType} !~ /$self->{option_results}->{filter_type}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $result->{dfFileSys} . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{fs}->{$instance} = {
              name => $result->{dfFileSys},
              total => defined($result->{df64TotalKBytes}) ? $result->{df64TotalKBytes} * 1024 : $result->{dfKBytesTotal} * 1024,
              type => $result->{dfType},
              vserver => $result->{dfVserver}
          };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{fs}}) {
          next if (defined($self->{option_results}->{skip_total_zero}) && $self->{fs}->{$instance}->{total} == 0);
          
          $self->{output}->output_add(long_msg => '[instance = ' . $instance . '] ' . 
              "[name = '" . $self->{fs}->{$instance}->{name} . "'] " .
              "[type = '" . $self->{fs}->{$instance}->{type} . "'] " .
              "[vserver = '" . $self->{fs}->{$instance}->{vserver} . "'] " .
              "[total = '" . $self->{fs}->{$instance}->{total} . "']");
      }
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List filesys:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['name', 'total', 'type', 'vserver']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{fs}}) {
          next if (defined($self->{option_results}->{skip_total_zero}) && $self->{fs}->{$instance}->{total} == 0);
  
          $self->{output}->add_disco_entry(%{$self->{fs}->{$instance}});
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List filesystems (volumes and aggregates also).
  
  =over 8
  
  =item B<--filter-name>
  
  Filter the filesystem name.
  
  =item B<--filter-type>
  
  Filter filesystem type (a regexp. Example: 'flexibleVolume|aggregate').
  
  =item B<--skip-total-zero>
  
  Don't display filesys with total equals 0.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTFILESYS

$fatpacked{"storage/netapp/ontap/snmp/mode/listplexes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTPLEXES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::listplexes;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {});
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my $map_plex_status = {
      1 => 'offline', 2 => 'resyncing', 3 => 'online'
  };
  
  my $mapping = {
      name      => { oid => '.1.3.6.1.4.1.789.1.6.11.1.2' }, # plexName
      aggregate => { oid => '.1.3.6.1.4.1.789.1.6.11.1.3' }, # plexVolName
      status    => { oid => '.1.3.6.1.4.1.789.1.6.11.1.4', map => $map_plex_status }  # plexStatus
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_table = '.1.3.6.1.4.1.789.1.6.11'; # plexTable
      my $snmp_result = $options{snmp}->get_table(oid => $oid_table, end => $mapping->{status}->{oid});
      my $results = {};
      foreach (keys %$snmp_result) {
          next if (! /^$mapping->{name}->{oid}\.(.*)$/);
  
          $results->{$1} = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $1);
      }
  
      return $results;
  }
  
  sub run {
      my ($self, %options) = @_;
  
      my $results = $self->manage_selection(snmp => $options{snmp});
      foreach my $instance (sort keys %$results) {
          $self->{output}->output_add(long_msg => 
              join('', map("[$_: " . $results->{$instance}->{$_} . ']', keys(%$mapping)))
          );
      }
  
      $self->{output}->output_add(
          severity => 'OK',
          short_msg => 'List plexes:'
      );
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
  
      $self->{output}->add_disco_format(elements => [keys %$mapping]);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      my $results = $self->manage_selection(snmp => $options{snmp});
      foreach (sort keys %$results) {        
          $self->{output}->add_disco_entry(
              %{$results->{$_}}
          );
      }
  }
  1;
  
  
  =head1 MODE
  
  List plexes.
  
  =over 8
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTPLEXES

$fatpacked{"storage/netapp/ontap/snmp/mode/listsnapvault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTSNAPVAULT';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::listsnapvault;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'transferring', 3 => 'pending',
      4 => 'aborting', 6 => 'quiescing', 7 => 'resyncing',
      12 => 'paused',
  };
  my $map_state = {
      1 => 'uninitialized', 2 => 'snapvaulted',
      3 => 'brokenOff', 4 => 'quiesced',
      5 => 'source', 6 => 'unknown', 7 => 'restoring',
  };
  
  my $oid_snapvaultStatusTable = '.1.3.6.1.4.1.789.1.19.11';
  my $mapping = {
      svSrc       => { oid => '.1.3.6.1.4.1.789.1.19.11.1.2' }, 
      svDst       => { oid => '.1.3.6.1.4.1.789.1.19.11.1.3' }, 
      svStatus    => { oid => '.1.3.6.1.4.1.789.1.19.11.1.4', map => $map_status }, 
      svState     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.5', map => $map_state },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_table(
          oid => $oid_snapvaultStatusTable, start => $mapping->{svSrc}->{oid}, end => $mapping->{svState}->{oid},
          nothing_quit => 1
      );
      
      $self->{snapvault} = {};
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$mapping->{svSrc}->{oid}\.(.*)$/);
          my $instance = $1;
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
          
          $self->{snapvault}->{$instance} = { %$result };
      }
  }
  
  sub run {
      my ($self, %options) = @_;
    
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{snapvault}}) { 
          $self->{output}->output_add(long_msg => '[src = ' . $self->{snapvault}->{$instance}->{svSrc} . 
              '] [dst = ' . $self->{snapvault}->{$instance}->{svDst} . 
              '] [status = ' . $self->{snapvault}->{$instance}->{svStatus} . 
              '] [state = ' . $self->{snapvault}->{$instance}->{svState} . ']'
          );
      }
      
      $self->{output}->output_add(severity => 'OK',
                                  short_msg => 'List snapvaults:');
      $self->{output}->display(nolabel => 1, force_ignore_perfdata => 1, force_long_output => 1);
      $self->{output}->exit();
  }
  
  sub disco_format {
      my ($self, %options) = @_;
      
      $self->{output}->add_disco_format(elements => ['src', 'dst', 'status', 'state']);
  }
  
  sub disco_show {
      my ($self, %options) = @_;
  
      $self->manage_selection(%options);
      foreach my $instance (sort keys %{$self->{snapvault}}) {             
          $self->{output}->add_disco_entry(
              src => $self->{snapvault}->{$instance}->{svSrc},
              dst => $self->{snapvault}->{$instance}->{svDst},
              status => $self->{snapvault}->{$instance}->{svStatus},
              state => $self->{snapvault}->{$instance}->{svState}
          );
      }
  }
  
  1;
  
  
  =head1 MODE
  
  List snapvaults.
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_LISTSNAPVAULT

$fatpacked{"storage/netapp/ontap/snmp/mode/ndmpsessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_NDMPSESSIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::ndmpsessions;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'warning:s'  => { name => 'warning' },
          'critical:s' => { name => 'critical' }
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
          $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
          $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_ndmpSessionOpened = '.1.3.6.1.4.1.789.1.10.2.0';
      my $result = $self->{snmp}->get_leef(oids => [$oid_ndmpSessionOpened], nothing_quit => 1);
      
      my $exit = $self->{perfdata}->threshold_check(value => $result->{$oid_ndmpSessionOpened}, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
      $self->{output}->output_add(severity => $exit,
                                  short_msg => sprintf("Current number of ndmp sessions opened: %d", $result->{$oid_ndmpSessionOpened}));
      $self->{output}->perfdata_add(label => 'sessions',
                                    value => $result->{$oid_ndmpSessionOpened},
                                    warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning'),
                                    critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical'),
                                    min => 0);
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check current total of ndmp sessions opened.
  
  =over 8
  
  =item B<--warning>
  
  Warning threshold.
  
  =item B<--critical>
  
  Critical threshold.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_NDMPSESSIONS

$fatpacked{"storage/netapp/ontap/snmp/mode/nvram.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_NVRAM';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::nvram;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_nvram_state = (
      1 => 'ok',
      2 => 'partiallyDischarged',
      3 => 'fullyDischarged',
      4 => 'notPresent',
      5 => 'nearEndOfLife',
      6 => 'atEndOfLife',
      7 => 'unknown',
      8 => 'overCharged',
      9 => 'fullyCharged',
  );
  
  my $thresholds = {
      nvram => [
          ['ok', 'OK'],
          ['partiallyDischarged', 'WARNING'],
          ['fullyDischarged', 'CRITICAL'],
          ['notPresent', 'CRITICAL'],
          ['nearEndOfLife', 'WARNING'],
          ['atEndOfLife', 'CRITICAL'],
          ['unknown', 'UNKNOWN'],
          ['overCharged', 'OK'],
          ['fullyCharged', 'OK'],
      ],
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'threshold-overload:s@' => { name => 'threshold_overload' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
  }
  
  my $mapping = {
      nvramBatteryStatus => { oid => '.1.3.6.1.4.1.789.1.2.5.1', map => \%mapping_nvram_state },  
  };
  my $mapping2 = {
      nodeNvramBatteryStatus => { oid => '.1.3.6.1.4.1.789.1.25.2.1.17', map => \%mapping_nvram_state },  
  };
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $mapping->{nvramBatteryStatus}->{oid} },
                                                              { oid => $oid_nodeName },
                                                              { oid => $mapping2->{nodeNvramBatteryStatus}->{oid} },
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$mapping->{nvramBatteryStatus}->{oid}}->{$mapping->{nvramBatteryStatus}->{oid} . '.0'})) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $results->{$mapping->{nvramBatteryStatus}->{oid}}, instance => '0');
          my $exit = $self->get_severity(section => 'nvram', value => $result->{nvramBatteryStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("NVRAM Batteries status is '%s'", $result->{nvramBatteryStatus}));
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'NVRAM Batteries status are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$mapping2->{nodeNvramBatteryStatus}->{oid}}})) {
              $oid =~ /^$mapping2->{nodeNvramBatteryStatus}->{oid}\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $results->{$mapping2->{nodeNvramBatteryStatus}->{oid}}, instance => $instance);
              
              my $exit = $self->get_severity(section => 'nvram', value => $result->{nodeNvramBatteryStatus});
              $self->{output}->output_add(long_msg => sprintf("NVRAM Batteries status is '%s' on node '%s'", 
                                                              $result->{nodeNvramBatteryStatus}, $name));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("NVRAM Batteries status is '%s' on node '%s'", 
                                                              $result->{nodeNvramBatteryStatus}, $name));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  1;
  
  
  =head1 MODE
  
  Check current status of the NVRAM batteries.
  
  =over 8
  
  =item B<--threshold-overload>
  
  Use this option to override the status returned by the plugin when the status label matches a regular expression (syntax: section,status,regexp).
  Example: --threshold-overload='nvram,CRITICAL,^(?!(ok)$)'
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_NVRAM

$fatpacked{"storage/netapp/ontap/snmp/mode/partnerstatus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_PARTNERSTATUS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::partnerstatus;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_partner_status = (
      1 => 'maybeDown',
      2 => 'ok',
      3 => 'dead',
  );
  my %mapping_interconnect_status = (
      1 => 'notPresent',
      2 => 'down',
      3 => 'partialFailure',
      4 => 'up',
  );
  my $thresholds = {
      partner => [
          ['maybeDown', 'WARNING'],
          ['ok', 'OK'],
          ['dead', 'CRITICAL'],
      ],
      interconnect => [
          ['notPresent', 'CRITICAL'],
          ['down', 'CRITICAL'],
          ['partialFailure', 'WARNING'],
          ['up', 'OK'],
      ],
  };
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'threshold-overload:s@' => { name => 'threshold_overload' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
      
      $self->{overload_th} = {};
      foreach my $val (@{$self->{option_results}->{threshold_overload}}) {
          if ($val !~ /^(.*?),(.*?),(.*)$/) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload option '" . $val . "'.");
              $self->{output}->option_exit();
          }
          my ($section, $status, $filter) = ($1, $2, $3);
          if ($self->{output}->is_litteral_status(status => $status) == 0) {
              $self->{output}->add_option_msg(short_msg => "Wrong threshold-overload status '" . $val . "'.");
              $self->{output}->option_exit();
          }
          $self->{overload_th}->{$section} = [] if (!defined($self->{overload_th}->{$section}));
          push @{$self->{overload_th}->{$section}}, {filter => $filter, status => $status};
      }
  }
  
  my $mapping = {
      cfPartnerStatus => { oid => '.1.3.6.1.4.1.789.1.2.3.4', map => \%mapping_partner_status },  
  };
  my $mapping2 = {
      cfInterconnectStatus => { oid => '.1.3.6.1.4.1.789.1.2.3.8', map => \%mapping_interconnect_status },  
  };
  my $mapping3 = {
      haPartnerStatus => { oid => '.1.3.6.1.4.1.789.1.21.2.1.6', map => \%mapping_partner_status },  
  };
  my $mapping4 = {
      haInterconnectStatus => { oid => '.1.3.6.1.4.1.789.1.21.2.1.10', map => \%mapping_interconnect_status },  
  };
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_cfPartnerName = '.1.3.6.1.4.1.789.1.2.3.6';
      my $oid_haNodeName = '.1.3.6.1.4.1.789.1.21.2.1.1';
      my $results = $self->{snmp}->get_multiple_table(oids => [
                                                              { oid => $oid_cfPartnerName },
                                                              { oid => $mapping->{cfPartnerStatus}->{oid} },
                                                              { oid => $mapping2->{cfInterconnectStatus}->{oid} },
                                                              { oid => $oid_haNodeName },
                                                              { oid => $mapping3->{haPartnerStatus}->{oid} },
                                                              { oid => $mapping4->{haInterconnectStatus}->{oid} },
                                                              ], nothing_quit => 1);
      
      if (defined($results->{$mapping->{cfPartnerStatus}->{oid}}->{$mapping->{cfPartnerStatus}->{oid} . '.0'})) {
          my $result = $self->{snmp}->map_instance(mapping => $mapping, results => $results->{$mapping->{cfPartnerStatus}->{oid}}, instance => '0');
          my $exit = $self->get_severity(section => 'partner', value => $result->{cfPartnerStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("Partner '%s' status is '%s'", $results->{$oid_cfPartnerName}->{$oid_cfPartnerName . '.0'}, $result->{cfPartnerStatus}));
          $result = $self->{snmp}->map_instance(mapping => $mapping2, results => $results->{$mapping2->{cfInterconnectStatus}->{oid}}, instance => '0');
          $exit = $self->get_severity(section => 'interconnect', value => $result->{cfInterconnectStatus});
          $self->{output}->output_add(severity => $exit,
                                      short_msg => sprintf("Interconnect status is '%s'", $result->{cfInterconnectStatus}));
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'HA status are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$mapping3->{haPartnerStatus}->{oid}}})) {
              $oid =~ /^$mapping3->{haPartnerStatus}->{oid}\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_haNodeName}->{$oid_haNodeName . '.' . $instance};
              my $result = $self->{snmp}->map_instance(mapping => $mapping3, results => $results->{$mapping3->{haPartnerStatus}->{oid}}, instance => $instance);
              
              my $exit = $self->get_severity(section => 'partner', value => $result->{haPartnerStatus});
              $self->{output}->output_add(long_msg => sprintf("Partner status of node '%s' is '%s'", 
                                                              $name, $result->{haPartnerStatus}));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Partner status of node '%s' is '%s'", 
                                                              $name, $result->{haPartnerStatus}));
              }
              
              $result = $self->{snmp}->map_instance(mapping => $mapping4, results => $results->{$mapping4->{haInterconnectStatus}->{oid}}, instance => $instance);
              $exit = $self->get_severity(section => 'interconnect', value => $result->{haInterconnectStatus});
              $self->{output}->output_add(long_msg => sprintf("Interconnect status on node '%s' is '%s'", 
                                                              $name, $result->{haInterconnectStatus}));
              if (!$self->{output}->is_status(litteral => 1, value => $exit, compare => 'ok')) {
                  $self->{output}->output_add(severity => $exit,
                                              short_msg => sprintf("Interconnect status on node '%s' is '%s'", 
                                                              $name, $result->{haInterconnectStatus}));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  sub get_severity {
      my ($self, %options) = @_;
      my $status = 'UNKNOWN'; # default 
      
      if (defined($self->{overload_th}->{$options{section}})) {
          foreach (@{$self->{overload_th}->{$options{section}}}) {            
              if ($options{value} =~ /$_->{filter}/i) {
                  $status = $_->{status};
                  return $status;
              }
          }
      }
      foreach (@{$thresholds->{$options{section}}}) {           
          if ($options{value} =~ /$$_[0]/i) {
              $status = $$_[1];
              return $status;
          }
      }
      
      return $status;
  }
  
  
  1;
  
  
  =head1 MODE
  
  Check status of clustered failover partner.
  
  =over 8
  
  =item B<--threshold-overload>
  
  Use this option to override the status returned by the plugin when the status label matches a regular expression (syntax: section,status,regexp).
  Example: --threshold-overload='partner,CRITICAL,^(?!(ok)$)'
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_PARTNERSTATUS

$fatpacked{"storage/netapp/ontap/snmp/mode/plexes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_PLEXES';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::plexes;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold_ng);
  
  sub plex_long_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "checking plex '%s'",
          $options{instance_value}->{name}
      );
  }
  
  sub prefix_plex_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "Plex '%s' ",
          $options{instance_value}->{name}
      );
  }
  
  sub prefix_aggregate_output {
      my ($self, %options) = @_;
  
      return sprintf(
          "aggregate '%s' ",
          $options{instance_value}->{aggregate}
      );
  }
  
  sub prefix_global_output {
      my ($self, %options) = @_;
  
      return 'Plex ';
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, cb_prefix_output => 'prefix_global_output', },
          { name => 'plexes', type => 3, cb_prefix_output => 'prefix_plex_output', cb_long_output => 'plex_long_output',
            indent_long_output => '    ', message_multiple => 'All plexes are ok',
              group => [
                  { name => 'aggregates', type => 1, cb_prefix_output => 'prefix_aggregate_output', message_multiple => 'aggregates are ok', display_long => 1, skipped_code => { -10 => 1 } }
              ]
          }
      ];
  
      $self->{maps_counters}->{global} = [
          { label => 'total-online', display_ok => 0, nlabel => 'plexes.online.count', set => {
                  key_values => [ { name => 'online' } ],
                  output_template => 'online: %s',
                  perfdatas => [
                      { template => '%s', min => 0 }
                  ]
              }
          },
          { label => 'total-offline', display_ok => 0, nlabel => 'plexes.offline.count', set => {
                  key_values => [ { name => 'offline' } ],
                  output_template => 'offline: %s',
                  perfdatas => [
                      { template => '%s', min => 0 }
                  ]
              }
          },
          { label => 'total-resyncing', display_ok => 0, nlabel => 'plexes.resyncing.count', set => {
                  key_values => [ { name => 'resyncing' } ],
                  output_template => 'resyncing: %s',
                  perfdatas => [
                      { template => '%s', min => 0 }
                  ]
              }
          }
      ];
  
      $self->{maps_counters}->{aggregates} = [
          {
              label => 'status',
              type => 2,
              warning_default => '%{status} eq "resyncing"',
              critical_default => '%{status} eq "offline"',
              set => {
                  key_values => [ { name => 'status' }, { name => 'aggregate' }, { name => 'name' } ],
                  output_template => "status: %s",
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
          { label => 'resyncing', nlabel => 'plex.resyncing.percentage', set => {
                  key_values => [ { name => 'resync' } ],
                  output_template => 'resyncing: %.2f %%',
                  perfdatas => [
                      { template => '%s', unit => '%', min => 0, max => 100, label_extra_instance => 1 }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => { 
          'filter-name:s'      => { name => 'filter_name' },
          'filter-aggregate:s' => { name => 'filter_aggregate' }
      });
  
      return $self;
  }
  
  my $map_plex_status = {
      1 => 'offline', 2 => 'resyncing', 3 => 'online'
  };
  
  my $mapping = {
      aggregate => { oid => '.1.3.6.1.4.1.789.1.6.11.1.3' }, # plexVolName
      status    => { oid => '.1.3.6.1.4.1.789.1.6.11.1.4', map => $map_plex_status },  # plexStatus
      resync    => { oid => '.1.3.6.1.4.1.789.1.6.11.1.5' } # plexPercentResyncing
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $oid_plexName = '.1.3.6.1.4.1.789.1.6.11.1.2';
  
      $self->{global} = { offline => 0, resyncing => 0, online => 0 };
      $self->{plexes} = {};
      my $instances = {};
      my $snmp_result = $options{snmp}->get_table(oid => $oid_plexName, nothing_quit => 1);
      foreach my $oid (keys %$snmp_result) {
          $oid =~ /^$oid_plexName\.(.*)$/;
          my $instance = $1;
          my $name = $snmp_result->{$oid};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping plex '" . $name . "'.", debug => 1);
              next;
          }
  
          $instances->{$instance} = $name;
          $self->{plexes}->{$name} = { name => $name, aggregates => {} };
      }
  
      if (scalar(keys %{$self->{plexes}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No plex found");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(
          oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [ map($_, keys %$instances) ],
          instance_regexp => '^(.*)$'
      );
      $snmp_result = $options{snmp}->get_leef();
      
      foreach (keys %$instances) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_aggregate}) && $self->{option_results}->{filter_aggregate} ne '' &&
              $result->{aggregate} !~ /$self->{option_results}->{filter_aggregate}/) {
              $self->{output}->output_add(long_msg => "skipping aggregatge '" . $result->{aggregate} . "'.", debug => 1);
              next;
          }
  
          $self->{plexes}->{ $instances->{$_} }->{aggregates}->{ $result->{aggregate} }->{name} = $instances->{$_};
          $self->{plexes}->{ $instances->{$_} }->{aggregates}->{ $result->{aggregate} }->{aggregate} = $result->{aggregate};
          $self->{plexes}->{ $instances->{$_} }->{aggregates}->{ $result->{aggregate} }->{status} = $result->{status};
          $self->{plexes}->{ $instances->{$_} }->{aggregates}->{ $result->{aggregate} }->{resync} = $result->{resync} if ($result->{status} eq 'resyncing');
          $self->{global}->{ $result->{status} }++;
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check plexes.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter plexes by name.
  
  =item B<--filter-aggregate>
  
  Filter plexes by aggregate name.
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN.
  You can use the following variables: %{status}, %{name}, %{aggregate}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING (default: '%{status} eq "resyncing"').
  You can use the following variables: %{status}, %{name}, %{aggregate}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{status}  eq "offline"').
  You can use the following variables: %{status}, %{name}, %{aggregate}
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'total-online', 'total-offline', 'total-resyncing', 'resyncing'.
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_PLEXES

$fatpacked{"storage/netapp/ontap/snmp/mode/psu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_PSU';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::psu;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envFailedPowerSupplyCount = '.1.3.6.1.4.1.789.1.2.4.4';
      my $oid_envFailedPowerSupplyMessage = '.1.3.6.1.4.1.789.1.2.4.5';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvFailedPowerSupplyCount = '.1.3.6.1.4.1.789.1.25.2.1.21';
      my $oid_nodeEnvFailedPowerSupplyMessage = '.1.3.6.1.4.1.789.1.25.2.1.22';
      my $results = $self->{snmp}->get_multiple_table(
          oids => [
              { oid => $oid_envFailedPowerSupplyCount }, 
              { oid => $oid_envFailedPowerSupplyMessage },
              { oid => $oid_nodeName },
              { oid => $oid_nodeEnvFailedPowerSupplyCount },
              { oid => $oid_nodeEnvFailedPowerSupplyMessage }
          ],
          nothing_quit => 1
      );
      
      if (defined($results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Power supplies are ok.');
          if ($results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'} != 0) {
              $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' power supplies are failed [message: %s].", 
                                                          $results->{$oid_envFailedPowerSupplyCount}->{$oid_envFailedPowerSupplyCount . '.0'},
                                                          $results->{$oid_envFailedPowerSupplyMessage}->{$oid_envFailedPowerSupplyMessage . '.0'}));
          }
      } else {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'Power supplies are ok on all nodes');
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvFailedPowerSupplyCount}})) {
              $oid =~ /^$oid_nodeEnvFailedPowerSupplyCount\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $count = $results->{$oid_nodeEnvFailedPowerSupplyCount}->{$oid};
              my $message = $results->{$oid_nodeEnvFailedPowerSupplyMessage}->{$oid_nodeEnvFailedPowerSupplyMessage . '.' . $instance};
              $self->{output}->output_add(long_msg => sprintf("'%d' power supplies are failed on node '%s' [message: %s]", 
                                                              $count, $name, defined($message) ? $message : '-'));
              if ($count != 0) {
                  $self->{output}->output_add(severity => 'CRITICAL',
                                          short_msg => sprintf("'%d' power supplies are failed on node '%s' [message: %s]", 
                                                          $count, $name, defined($message) ? $message : '-'));
              }
          }
      }
  
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if power supplies are failed (in degraded mode).
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_PSU

$fatpacked{"storage/netapp/ontap/snmp/mode/quotas.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_QUOTAS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::quotas;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::statefile;
  
  sub prefix_quota_output {
      my ($self, %options) = @_;
      
      return sprintf(
          "Quota '%s%s%s%s' ",
          $options{instance_value}->{vserver} ne '' ? 'vserver:' . $options{instance_value}->{vserver} . ',' : '',
          'volume:' . $options{instance_value}->{volume},
          $options{instance_value}->{qtree} ne '' ? ',' . 'qtree:' . $options{instance_value}->{qtree} : '',
          $self->{duplicated}->{$options{instance_value}->{vserver} . $options{instance_value}->{volume} . $options{instance_value}->{qtree} } > 1 ? ',index:' . $options{instance_value}->{index} : ''
      );
  }
  
  sub custom_space_usage_perfdata {
      my ($self, %options) = @_;
      
      my $instances = ['volume:' . $self->{result_values}->{volume}];
      unshift @$instances, 'vserver:' . $self->{result_values}->{vserver} if ($self->{result_values}->{vserver} ne '');
      push @$instances, 'qtree:' . $self->{result_values}->{qtree} if ($self->{result_values}->{qtree} ne '');
      push @$instances, 'index:' . $self->{result_values}->{index}
          if ($self->{instance_mode}->{duplicated}->{ $self->{result_values}->{vserver} . $self->{result_values}->{volume} . $self->{result_values}->{qtree} } > 1);
  
      my $warn_label = 'warning-'. $self->{thlabel};
      if ($self->{result_values}->{soft_limit} > 0) {
          $warn_label = 'warning-' . $self->{thlabel} . '-' . $self->{result_values}->{index};
      }
  
      $self->{output}->perfdata_add(
          nlabel => $self->{nlabel},
          unit => 'B',
          instances => $instances,
          value => $self->{result_values}->{used},
          warning => $self->{perfdata}->get_perfdata_for_output(label => $warn_label),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
          min => 0,
          max => $self->{result_values}->{total} > 0 ? $self->{result_values}->{total} : undef
      );
  }
  
  sub custom_space_usage_free_perfdata {
      my ($self, %options) = @_;
      
      my $instances = ['volume:' . $self->{result_values}->{volume}];
      unshift @$instances, 'vserver:' . $self->{result_values}->{vserver} if ($self->{result_values}->{vserver} ne '');
      push @$instances, 'qtree:' . $self->{result_values}->{qtree} if ($self->{result_values}->{qtree} ne '');
      push @$instances, 'index:' . $self->{result_values}->{index}
          if ($self->{instance_mode}->{duplicated}->{ $self->{result_values}->{vserver} . $self->{result_values}->{volume} . $self->{result_values}->{qtree} } > 1);
  
      $self->{output}->perfdata_add(
          nlabel => $self->{nlabel},
          unit => 'B',
          instances => $instances,
          value => $self->{result_values}->{free},
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
          min => 0,
          max => $self->{result_values}->{total}
      );
  }
  
  sub custom_space_usage_prct_perfdata {
      my ($self, %options) = @_;
  
      my $instances = ['volume:' . $self->{result_values}->{volume}];
      unshift @$instances, 'vserver:' . $self->{result_values}->{vserver} if ($self->{result_values}->{vserver} ne '');
      push @$instances, 'qtree:' . $self->{result_values}->{qtree} if ($self->{result_values}->{qtree} ne '');
      push @$instances, 'index:' . $self->{result_values}->{index}
          if ($self->{instance_mode}->{duplicated}->{ $self->{result_values}->{vserver} . $self->{result_values}->{volume} . $self->{result_values}->{qtree} } > 1);
  
      $self->{output}->perfdata_add(
          nlabel => $self->{nlabel},
          unit => '%',
          instances => $instances,
          value => sprintf('%.2f', $self->{result_values}->{prct_used}),
          warning => $self->{perfdata}->get_perfdata_for_output(label => 'warning-' . $self->{thlabel}),
          critical => $self->{perfdata}->get_perfdata_for_output(label => 'critical-' . $self->{thlabel}),
          min => 0, max => 100
      );
  }
  
  sub custom_space_usage_threshold {
      my ($self, %options) = @_;
  
      # the soft_limit override the default warning plugin threshold
      my $warn_label = 'warning-'. $self->{thlabel};
      if ($self->{result_values}->{soft_limit} > 0) {
          $warn_label = 'warning-' . $self->{thlabel} . '-' . $self->{result_values}->{index};
          $self->{perfdata}->threshold_validate(label => $warn_label, value => $self->{result_values}->{soft_limit});
      }
  
      return $self->{perfdata}->threshold_check(
          value => $self->{result_values}->{used}, threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => $warn_label, exit_litteral => 'warning' }
          ]
      );
  }
  
  sub custom_space_usage_free_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(
          value => $self->{result_values}->{free}, threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' }
          ]
      );
  }
  
  sub custom_space_usage_prct_threshold {
      my ($self, %options) = @_;
  
      return $self->{perfdata}->threshold_check(
          value => $self->{result_values}->{prct_used}, threshold => [
              { label => 'critical-' . $self->{thlabel}, exit_litteral => 'critical' },
              { label => 'warning-'. $self->{thlabel}, exit_litteral => 'warning' }
          ]
      );
  }
  
  sub custom_space_usage_output {
      my ($self, %options) = @_;
  
      my ($total_used_value, $total_used_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{used});
  
      my $msg;
      if ($self->{result_values}->{total} <= 0) {
          $msg = sprintf("used: %s (unlimited)", $total_used_value . " " . $total_used_unit);
      } else {
          my ($total_size_value, $total_size_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{total});
          my ($total_free_value, $total_free_unit) = $self->{perfdata}->change_bytes(value => $self->{result_values}->{free});
          $msg = sprintf(
              "total: %s used: %s (%.2f%%) free: %s (%.2f%%)",
              $total_size_value . " " . $total_size_unit,
              $total_used_value . " " . $total_used_unit, $self->{result_values}->{prct_used},
              $total_free_value . " " . $total_free_unit, $self->{result_values}->{prct_free}
          );
      }
      return $msg;
  }
  
  sub custom_space_usage_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{qtree} = $options{new_datas}->{$self->{instance} . '_qtree'};
      $self->{result_values}->{volume} = $options{new_datas}->{$self->{instance} . '_volume'};
      $self->{result_values}->{vserver} = $options{new_datas}->{$self->{instance} . '_vserver'};
      $self->{result_values}->{total} = $options{new_datas}->{$self->{instance} . '_total'};
      $self->{result_values}->{used} = $options{new_datas}->{$self->{instance} . '_used'};
      $self->{result_values}->{soft_limit} = $options{new_datas}->{$self->{instance} . '_soft_limit'};
      $self->{result_values}->{index} = $options{new_datas}->{$self->{instance} . '_index'};
  
      if ($self->{result_values}->{total} == 0) {
          return -10 if ($options{extra_options}->{label} ne 'usage');
          return 0;
      }
  
      $self->{result_values}->{prct_used} = $self->{result_values}->{used} * 100 / $self->{result_values}->{total};
      $self->{result_values}->{prct_free} = 100 - $self->{result_values}->{prct_used};
      $self->{result_values}->{free} = $self->{result_values}->{total} - $self->{result_values}->{used};
  
      # quotas can be over 100%
      if ($self->{result_values}->{free} < 0) {
          $self->{result_values}->{free} = 0;
          $self->{result_values}->{prct_free} = 0;
      }
      
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'quotas', type => 1, cb_prefix_output => 'prefix_quota_output', message_multiple => 'All quotas are ok', skipped_code => { -10 => 1 } }
      ];
  
      $self->{maps_counters}->{quotas} = [
           { label => 'space-usage', nlabel => 'quota.space.usage.bytes', set => {
                  key_values => [
                      { name => 'qtree' }, { name => 'volume' }, { name => 'vserver' },
                      { name => 'used' }, { name => 'total' }, { name => 'soft_limit' }, { name => 'index' }
                  ],
                  closure_custom_calc_extra_options => { label => 'usage' },
                  closure_custom_calc => $self->can('custom_space_usage_calc'),
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  closure_custom_threshold_check => $self->can('custom_space_usage_threshold'),
                  closure_custom_perfdata => $self->can('custom_space_usage_perfdata')
              }
          },
          { label => 'space-usage-free', nlabel => 'quota.space.free.bytes', display_ok => 0, set => {
                  key_values => [
                      { name => 'qtree' }, { name => 'volume' }, { name => 'vserver' },
                      { name => 'used' }, { name => 'total' }, { name => 'soft_limit' }, { name => 'index' }
                  ],
                  closure_custom_calc_extra_options => { label => 'free' },
                  closure_custom_calc => $self->can('custom_space_usage_calc'),
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  closure_custom_threshold_check => $self->can('custom_space_usage_free_threshold'),
                  closure_custom_perfdata => $self->can('custom_space_usage_free_perfdata')
              }
          },
          { label => 'space-usage-prct', nlabel => 'quota.space.usage.percentage', display_ok => 0, set => {
                  key_values => [ 
                      { name => 'qtree' }, { name => 'volume' }, { name => 'vserver' },
                      { name => 'used' }, { name => 'total' }, { name => 'soft_limit' }, { name => 'index' }
                  ],
                  closure_custom_calc_extra_options => { label => 'prct' },
                  closure_custom_calc => $self->can('custom_space_usage_calc'),
                  closure_custom_output => $self->can('custom_space_usage_output'),
                  closure_custom_threshold_check => $self->can('custom_space_usage_prct_threshold'),
                  closure_custom_perfdata => $self->can('custom_space_usage_prct_perfdata')
              }
          }
      ];
  }
  
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, force_new_perfdata => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-index:s'   => { name => 'filter_index' },
          'filter-vserver:s' => { name => 'filter_vserver' },
          'filter-volume:s'  => { name => 'filter_volume' },
          'filter-qtree:s'   => { name => 'filter_qtree' },
          'not-kbytes'       => { name => 'not_kbytes' },
          'cache'            => { name => 'cache' },
          'cache-time:s'     => { name => 'cache_time', default => 180 }
      });
  
      $self->{lcache} = centreon::plugins::statefile->new(%options);
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      if (defined($self->{option_results}->{cache})) {
          $self->{lcache}->check_options(option_results => $self->{option_results});
      }
  }
  
  my $mapping_infos = {
      qtree   => { oid => '.1.3.6.1.4.1.789.1.4.6.1.14' }, # qrV2Tree
      volume  => { oid => '.1.3.6.1.4.1.789.1.4.6.1.29' }, # qrV2VolumeName
      vserver => { oid => '.1.3.6.1.4.1.789.1.4.6.1.30' } # qrV2Vserver
  };
  my $mapping_datas = {
      used       => { oid => '.1.3.6.1.4.1.789.1.4.6.1.25' }, # qrV264KBytesUsed
      total      => { oid => '.1.3.6.1.4.1.789.1.4.6.1.26' }, # qrV264KBytesLimit
      threshold  => { oid => '.1.3.6.1.4.1.789.1.4.6.1.27' }, # qrV264KBytesThreshold
      soft_limit => { oid => '.1.3.6.1.4.1.789.1.4.6.1.28' }  # qrV264KBytesSoftLimit
  };
  
  sub get_snmp_informations {
      my ($self, %options) = @_;
  
      return $options{snmp}->get_multiple_table(
          oids => [
              { oid => $mapping_infos->{qtree}->{oid} },
              { oid => $mapping_infos->{volume}->{oid} },
              { oid => $mapping_infos->{vserver}->{oid} }
          ],
          return_type => 1,
          nothing_quit => 1
      );
  }
  
  sub get_informations {
      my ($self, %options) = @_;
  
      my $infos;
      if (defined($self->{option_results}->{cache})) {
          my $has_cache_file = $self->{lcache}->read(statefile => 'netapp_cache_' . $self->{mode} . '_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port());
          $infos = $self->{lcache}->get(name => 'infos');
          if ($has_cache_file == 0 ||
              !defined($infos->{updated}) ||
              ((time() - $infos->{updated}) > (($self->{option_results}->{cache_time}) * 60))) {
              $infos = $self->get_snmp_informations(snmp => $options{snmp});
              $self->{lcache}->write(data => { infos => { updated => time(), snmp_result => $infos } });
          } else {
              $infos = $infos->{snmp_result};
          }
      } else {
          $infos = $self->get_snmp_informations(snmp => $options{snmp});
      }
  
      return $infos;
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      if ($options{snmp}->is_snmpv1()) {
          $self->{output}->add_option_msg(short_msg => "Need to use SNMP v2c or v3.");
          $self->{output}->option_exit();
      }
  
      $self->{duplicated} = {};
  
      my $infos = $self->get_informations(snmp => $options{snmp});
      # theres are differents types: user, group and qtree
      $self->{quotas} = {};
      foreach my $oid (keys %$infos) {
          next if ($oid !~ /^$mapping_infos->{qtree}->{oid}\.(\d+)\.(\d+)$/);
          my $instance = $1 . '.' . $2;
          my $index = $2;
          my $result = $options{snmp}->map_instance(mapping => $mapping_infos, results => $infos, instance => $instance);
  
          $result->{volume} = '' if (!defined($result->{volume}));
          $result->{vserver} = '' if (!defined($result->{vserver}));
  
          next if (defined($self->{option_results}->{filter_index}) && $self->{option_results}->{filter_index} ne '' &&
              $index !~ /$self->{option_results}->{filter_index}/);
          next if (defined($self->{option_results}->{filter_qtree}) && $self->{option_results}->{filter_qtree} ne '' &&
              $result->{qtree} !~ /$self->{option_results}->{filter_qtree}/);
          next if ($result->{volume} ne '' && defined($self->{option_results}->{filter_volume}) && $self->{option_results}->{filter_volume} ne '' &&
              $result->{volume} !~ /$self->{option_results}->{filter_volume}/);
          next if ($result->{vserver} ne '' &&defined($self->{option_results}->{filter_vserver}) && $self->{option_results}->{filter_vserver} ne '' &&
              $result->{vserver} !~ /$self->{option_results}->{filter_vserver}/);
          my $path = $result->{vserver} . $result->{volume} . $result->{qtree};
          $self->{duplicated}->{$path} = 0 if (!defined($self->{duplicated}->{$path}));
          $self->{duplicated}->{$path}++;
  
          $self->{quotas}->{$instance} = $result;
          $self->{quotas}->{$instance}->{index} = $index;
      }
  
      my $multi = 1;
      $multi = 1024 unless defined($self->{option_results}->{not_kbytes});
  
      if (scalar(keys %{$self->{quotas}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => 'No quota found');
          $self->{output}->option_exit();
      }
  
      $options{snmp}->load(
          oids => [ map($_->{oid}, values(%$mapping_datas)) ],
          instances => [ map($_, keys(%{$self->{quotas}})) ],
          instance_regexp => '^(.*)$'
      );
      my $snmp_result = $options{snmp}->get_leef();
      foreach my $instance (keys %{$self->{quotas}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping_datas, results => $snmp_result, instance => $instance);
          $self->{quotas}->{$instance}->{used} = $result->{used} * $multi;
          $self->{quotas}->{$instance}->{total} = $result->{total} * $multi;
  
          # we use the lower limit
          $result->{threshold} *= $multi;
          my $soft_limit = $result->{soft_limit} * $multi;
          if ($result->{threshold} > 0 && ($soft_limit == 0 || $result->{threshold} < $soft_limit)) {
              $soft_limit = $result->{threshold};
          }
          $self->{quotas}->{$instance}->{soft_limit} = $soft_limit;
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check quotas.
  
  =over 8
  
  =item B<--filter-index>
  
  Filter by index (identified entry in the /etc/quotas) (can be a regexp).
  
  =item B<--filter-vserver>
  
  Filter by vserver name (can be a regexp).
  
  =item B<--filter-volume>
  
  Filter by volume name (can be a regexp).
  
  =item B<--filter-qtree>
  
  Filter by qtree name (can be a regexp).
  
  =item B<--cache>
  
  Use cache file to store quota volume/vserver/qtree information.
  
  =item B<--cache-time>
  
  Time in minutes before reloading cache file (default: 180).
  
  =item B<--warning-*> B<--critical-*>
  
  Thresholds.
  Can be: 'space-usage', 'space-usage-free', 'space-usage-prct'.
  
  =item B<--not-kbytes>
  
  If qrV264KBytesUsed and qrV264KBytesLimit OIDs are not really KBytes.
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_QUOTAS

$fatpacked{"storage/netapp/ontap/snmp/mode/sharecalls.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SHARECALLS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::sharecalls;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  sub set_counters {
      my ($self, %options) = @_;
      
      $self->{maps_counters_type} = [
          { name => 'global', type => 0, skipped_code => { -10 => 1 } }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'cifs', nlabel => 'storage.cifs.calls.persecond', set => {
                  key_values => [ { name => 'cifs', per_second => 1 } ],
                  output_template => 'CIFS : %s calls/s',
                  perfdatas => [
                      { template => '%d', min => 0 }
                  ]
              }
          },
          { label => 'nfs', nlabel => 'storage.nfs.calls.persecond', set => {
                  key_values => [ { name => 'nfs', per_second => 1 } ],
                  output_template => 'NFS : %s calls/s',
                  perfdatas => [
                      { template => '%d', min => 0 }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  my $oid_miscHighNfsOps = '.1.3.6.1.4.1.789.1.2.2.5.0';
  my $oid_miscLowNfsOps = '.1.3.6.1.4.1.789.1.2.2.6.0';
  my $oid_miscHighCifsOps = '.1.3.6.1.4.1.789.1.2.2.7.0';
  my $oid_miscLowCifsOps = '.1.3.6.1.4.1.789.1.2.2.8.0';
  my $oid_misc64NfsOps = '.1.3.6.1.4.1.789.1.2.2.27.0';
  my $oid_misc64CifsOps = '.1.3.6.1.4.1.789.1.2.2.28.0';
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $request = [
          $oid_miscHighNfsOps, $oid_miscLowNfsOps,
          $oid_miscHighCifsOps, $oid_miscLowCifsOps
      ];
      if (!$options{snmp}->is_snmpv1()) {
          push @{$request}, ($oid_misc64NfsOps, $oid_misc64CifsOps);
      }
      
      my $snmp_result = $options{snmp}->get_leef(oids => $request, nothing_quit => 1);
      
      $self->{global} = {};
      $self->{global}->{cifs} = defined($snmp_result->{$oid_misc64CifsOps}) ?
                                  $snmp_result->{$oid_misc64CifsOps} : 
                                  ($snmp_result->{$oid_miscHighCifsOps} << 32) + $snmp_result->{$oid_miscLowCifsOps};
      $self->{global}->{nfs} = defined($snmp_result->{$oid_misc64NfsOps}) ?
                                  $snmp_result->{$oid_misc64NfsOps} : 
                                  ($snmp_result->{$oid_miscHighNfsOps} << 32) + $snmp_result->{$oid_miscLowNfsOps};
  
      $self->{cache_name} = "cache_netapp_" . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' . $self->{mode} . '_' . 
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check cifs and nfs calls per seconds.
  If you are in cluster mode, the following mode doesn't work. Ask to netapp to add it :)
  
  =over 8
  
  =item B<--warning-*>
  
  Warning threshold.
  Can be: 'cifs', 'nfs'.
  
  =item B<--critical-*>
  
  Critical threshold.
  Can be: 'cifs', 'nfs'.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_SHARECALLS

$fatpacked{"storage/netapp/ontap/snmp/mode/shelf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SHELF';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::shelf;
  
  use base qw(centreon::plugins::templates::hardware);
  
  use strict;
  use warnings;
  
  sub set_system {
      my ($self, %options) = @_;
      
      $self->{regexp_threshold_numeric_check_section_option} = '^(voltage|temperature|fan)$';
      
      $self->{cb_hook1} = 'init_shelf';
      $self->{cb_hook2} = 'snmp_execute';
      
      $self->{thresholds} = {
          communication => [
              ['initializing', 'WARNING'],
              ['transitioning', 'WARNING'],
              ['inactive', 'CRITICAL'],
              ['reconfiguring', 'WARNING'],
              ['nonexistent', 'CRITICAL'],
              ['active', 'OK'],
          ],
          raid => [
              ['initializing', 'WARNING'],
              ['reconstructionInProgress', 'WARNING'],
              ['parityVerificationInProgress', 'OK'],
              ['scrubbingInProgress', 'OK'],
              ['prefailed', 'CRITICAL'],
              ['failed', 'CRITICAL'],
              ['active', 'OK'],
          ],
          fan => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          psu => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          electronics => [
              ['failed', 'CRITICAL'],
              ['ok', 'OK'],
          ],
          voltage => [
              ['under critical threshold', 'CRITICAL'],
              ['under warning threshold', 'WARNING'],
              ['over critical threshold', 'CRITICAL'],
              ['over warning threshold', 'WARNING'],
              ['ok', 'OK'],
          ],
          temperature => [
              ['under critical threshold', 'CRITICAL'],
              ['under warning threshold', 'WARNING'],
              ['over critical threshold', 'CRITICAL'],
              ['over warning threshold', 'WARNING'],
              ['ok', 'OK'],
          ],
      };
      
      $self->{components_path} = 'storage::netapp::ontap::snmp::mode::components';
      $self->{components_module} = ['communication', 'psu', 'fan', 'temperature', 'voltage', 'electronics', 'raid'];
  }
  
  my $oid_enclNumber = '.1.3.6.1.4.1.789.1.21.1.1';
  my $oid_enclChannelShelfAddr = '.1.3.6.1.4.1.789.1.21.1.2.1.3';
  
  sub snmp_execute {
      my ($self, %options) = @_;
      
      $self->{snmp} = $options{snmp};
      $self->{results} = $self->{snmp}->get_multiple_table(oids => $self->{request});
      $self->{number_shelf} = defined($self->{results}->{$oid_enclNumber}->{$oid_enclNumber . '.0'}) ? $self->{results}->{$oid_enclNumber}->{$oid_enclNumber . '.0'} : -1;
      $self->{shelf_addr} = $self->{results}->{$oid_enclChannelShelfAddr};
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  sub init_shelf {
      my ($self, %options) = @_;
  
      push @{$self->{request}}, ({ oid => $oid_enclNumber }, { oid => $oid_enclChannelShelfAddr });
  }
  
  1;
  
  
  =head1 MODE
  
  Check Shelves hardware (temperatures, voltages, electronics, fan, power supplies).
  
  =over 8
  
  =item B<--component>
  
  Which component to check (default: '.*').
  Can be: 'psu', 'fan', 'communication', 'voltage', 'temperature', 'electronics', 'raid'.
  
  =item B<--filter>
  
  Exclude the items given as a comma-separated list (example: --filter=fan --filter=psu).
  You can also exclude items from specific instances: --filter=psu,41239F00647-A
  
  =item B<--absent-problem>
  
  Return an error if an entity is not 'present' (default is skipping) (comma separated list)
  Can be specific or global: --absent-problem=fan,41239F00647-fan02
  
  =item B<--no-component>
  
  Define the expected status if no components are found (default: critical).
  
  =item B<--threshold-overload>
  
  Use this option to override the status returned by the plugin when the status label matches a regular expression (syntax: section,[instance,]status,regexp).
  Example: --threshold-overload='gfc,CRITICAL,^(?!(Online)$)'
  
  =item B<--warning>
  
  Set warning threshold for temperature, fan, voltage (syntax: type,regexp,threshold)
  Example: --warning='41239F00647-vimm46,20' --warning='41239F00647-vimm5.*,30'
  
  =item B<--critical>
  
  Set critical threshold for temperature, fan, voltage (syntax: type,regexp,threshold)
  Example: --critical='temperature,.*,25' --critical='temperature,.*,35'
  
  =item B<--warning-count-*>
  
  Define the warning threshold for the number of components of one type (replace '*' with the component type).
  
  =item B<--critical-count-*>
  
  Define the critical threshold for the number of components of one type (replace '*' with the component type).
  
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_SHELF

$fatpacked{"storage/netapp/ontap/snmp/mode/sis.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SIS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::sis;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  use Digest::MD5 qw(md5_hex);
  
  sub custom_status_output { 
      my ($self, %options) = @_;
  
      my $msg = sprintf('status : %s [state: %s] [lastOpError: %s]',
          $self->{result_values}->{status},
          $self->{result_values}->{state},
          $self->{result_values}->{lastOpError},
      );
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_sisStatus'};
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_sisState'};
      $self->{result_values}->{lastOpError} = $options{new_datas}->{$self->{instance} . '_sisLastOpError'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'sis', type => 1, cb_prefix_output => 'prefix_sis_output', message_multiple => 'All single instance storages are ok', skipped_code => { -10 => 1, -11 => 1 } }
      ];
  
      $self->{maps_counters}->{sis} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'sisStatus' }, { name => 'sisState' }, { name => 'sisLastOpError' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
      ];
  }
  
  sub prefix_sis_output {
      my ($self, %options) = @_;
  
      return "Single instance storage '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-name:s'     => { name => 'filter_name' },
          'unknown-status:s'  => { name => 'unknown_status', default => '' },
          'warning-status:s'  => { name => 'warning_status', default => '' },
          'critical-status:s' => { name => 'critical_status', default => '%{state} eq "enabled" and %{lastOpError} !~ /-|Success/i' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'active', 3 => 'undoing',
      4 => 'pending', 5 => 'initializing',
      6 => 'downgrading', 7 => 'disabled',
  };
  
  my $map_state = { 1 => 'disabled', 2 => 'enabled' };
  
  my $mapping = {
      sisState        => { oid => '.1.3.6.1.4.1.789.1.23.2.1.3', map => $map_state }, 
      sisStatus       => { oid => '.1.3.6.1.4.1.789.1.23.2.1.4', map => $map_status },
      sisLastOpError  => { oid => '.1.3.6.1.4.1.789.1.23.2.1.12' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $oid_sisIsLicensed = '.1.3.6.1.4.1.789.1.23.1.0';
      my $snmp_result = $options{snmp}->get_leef(oids => [$oid_sisIsLicensed]);
      if (!defined($snmp_result->{$oid_sisIsLicensed}) || $snmp_result->{$oid_sisIsLicensed} != 2) {
          $self->{output}->add_option_msg(short_msg => 'single instance storage is not licensed');
          $self->{output}->option_exit();
      }
      
      my $oid_sisPath = '.1.3.6.1.4.1.789.1.23.2.1.2';
      my $oid_sisVserver = '.1.3.6.1.4.1.789.1.23.2.1.16';
      
      $self->{snapvault} = {};
      $snmp_result = $options{snmp}->get_multiple_table(oids => [ { oid => $oid_sisPath }, { oid => $oid_sisVserver }], return_type => 1, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$oid_sisPath\.(.*)$/);
          my $instance = $1;
          my $name = defined($snmp_result->{$oid_sisVserver . '.' . $instance}) && $snmp_result->{$oid_sisVserver . '.' . $instance} ne '' ?
              $snmp_result->{$oid_sisVserver . '.' . $instance} . ':' . $snmp_result->{$oid} :
              $snmp_result->{$oid};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping sis '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{sis}->{$instance} = { display => $name };
      }
  
      if (scalar(keys %{$self->{sis}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [keys %{$self->{sis}}], instance_regexp => '^(.*)$');
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      foreach (keys %{$self->{sis}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          
          $self->{sis}->{$_} = { %{$self->{sis}->{$_}}, %$result };
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check single instance storage.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter name (can be a regexp).
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{state}, %{status}, %{lastOpError}, %{display}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{state}, %{status}, %{lastOpError}, %{display}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{state} eq "enabled" and %{lastOpError} !~ /-|Success/i').
  You can use the following variables: %{state}, %{status}, %{lastOpError}, %{display}
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_SIS

$fatpacked{"storage/netapp/ontap/snmp/mode/snapmirrorlag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPMIRRORLAG';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::snapmirrorlag;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_state'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'snapmirror', type => 1, cb_prefix_output => 'prefix_snapmirror_output', message_multiple => 'All snapmirrors lags are ok' },
      ];
  
      $self->{maps_counters}->{snapmirror} = [
           { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'state' }, { name => 'display' } ],
                  output_template => "state is '%s'",
                  output_use => 'state',
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'lag', set => {
                  key_values => [ { name => 'lag' }, { name => 'display' } ],
                  output_template => 'lag: %s seconds',
                  perfdatas => [
                      { label => 'lag', value => 'lag', template => '%s', min => 0, unit => 's',
                        label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_snapmirror_output {
      my ($self, %options) = @_;
  
      return "Snapmirror '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-name:s'     => { name => 'filter_name' },
          'filter-status:s'   => { name => 'filter_status' },
          'unknown-status:s'  => { name => 'unknown_status', default => '' },
          'warning-status:s'  => { name => 'warning_status', default => '%{state} =~ /quiesced/i' },
          'critical-status:s' => { name => 'critical_status', default => '%{state} =~ /unknown|brokenOff|uninitialized/i' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  sub check_snapmirror {
      my ($self, %options) = @_;
  
      my $oid_snapmirrorOn = '.1.3.6.1.4.1.789.1.9.1.0';
      my $oid_snapmirrorSrc = '.1.3.6.1.4.1.789.1.9.20.1.2';
  
      my $snmp_result = $options{snmp}->get_leef(oids => [$oid_snapmirrorOn]);
      return if (!defined($snmp_result->{$oid_snapmirrorOn}));
  
      if ($snmp_result->{$oid_snapmirrorOn} != 2) {
          $self->{output}->add_option_msg(short_msg => "snapmirror is not turned on.");
          $self->{output}->option_exit();
      }
      
      my $id_selected = [];
      my $snmp_result_name = $options{snmp}->get_table(oid => $oid_snapmirrorSrc);
      foreach my $oid (keys %$snmp_result_name) {
          next if ($oid !~ /\.([0-9]+)$/);
          my $instance = $1;
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $snmp_result_name->{$oid} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid} . "': no matching filter.", debug => 1);
              next;
          }
  
          push @$id_selected, $instance;
      }
  
      return if (scalar(@$id_selected) <= 0);
  
      my $map_state = {
          1 => 'uninitialized', 2 => 'snapmirrored', 
          3 => 'brokenOff', 4 => 'quiesced',
          5 => 'source', 6 => 'unknown',
      };
      my $mapping = {
          snapmirrorState => { oid => '.1.3.6.1.4.1.789.1.9.20.1.5', map => $map_state },
          snapmirrorLag   => { oid => '.1.3.6.1.4.1.789.1.9.20.1.6' },
      };
  
      $options{snmp}->load(oids => [$mapping->{snapmirrorState}->{oid}, $mapping->{snapmirrorLag}->{oid}], instances => $id_selected);
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      $self->{snapmirror} = {};
      foreach (@$id_selected) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_status}) && $self->{option_results}->{filter_status} ne '' &&
              $result->{snapmirrorState} !~ /$self->{option_results}->{filter_status}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid_snapmirrorSrc . '.' . $_} . "': no matching filter.", debug => 1);
              next;
          }
          
          $self->{snapmirror}->{$_} = {
              display => $snmp_result_name->{$oid_snapmirrorSrc . '.' . $_},
              state => $result->{snapmirrorState},
              lag => int($result->{snapmirrorLag} / 100),
          };
      }
  }
  
  sub check_sm {
      my ($self, %options) = @_;
  
      return if (scalar(keys %{$self->{snapmirror}}) > 0);
  
      my $oid_snapmirrorRelSrcPath = '.1.3.6.1.4.1.789.1.29.1.1.2';
  
      my $id_selected = [];
      my $snmp_result_name = $options{snmp}->get_table(oid => $oid_snapmirrorRelSrcPath, nothing_quit => 1);
      foreach my $oid (keys %$snmp_result_name) {
          next if ($oid !~ /\.([0-9]+)$/);
          my $instance = $1;
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $snmp_result_name->{$oid} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid} . "': no matching filter.", debug => 1);
              next;
          }
  
          push @$id_selected, $instance;
      }
  
      if (scalar(@$id_selected) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapmirrors found for filter '" . $self->{option_results}->{filter_name} . "'.");
          $self->{output}->option_exit();
      }
      
      my $map_state = {
          0 => 'uninitialized', 1 => 'snapmirrored', 2 => 'brokenOff',
      };
      my $mapping = {
          snapmirrorRelState => { oid => '.1.3.6.1.4.1.789.1.29.1.1.6', map => $map_state },
          snapmirrorRelLag   => { oid => '.1.3.6.1.4.1.789.1.29.1.1.7' },
      };
  
      $options{snmp}->load(oids => [$mapping->{snapmirrorRelState}->{oid}, $mapping->{snapmirrorRelLag}->{oid}], instances => $id_selected);
      my $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      $self->{snapmirror} = {};
      foreach (@$id_selected) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_status}) && $self->{option_results}->{filter_status} ne '' &&
              $result->{snapmirrorState} !~ /$self->{option_results}->{filter_status}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $snmp_result_name->{$oid_snapmirrorRelSrcPath . '.' . $_} . "': no matching filter.", debug => 1);
              next;
          }
          
          $self->{snapmirror}->{$_} = {
              display => $snmp_result_name->{$oid_snapmirrorRelSrcPath . '.' . $_},
              state => $result->{snapmirrorRelState},
              lag => int($result->{snapmirrorRelLag} / 100),
          };
      }
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->check_snapmirror(%options);
      $self->check_sm(%options);
  
      if (scalar(keys %{$self->{snapmirror}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapmirrors found.");
          $self->{output}->option_exit();
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapmirrors status and lag.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter the snapmirror name (can be a regexp).
  
  =item B<--filter-status>
  
  Filter on status (can be a regexp).
  
  =item B<--filter-counters>
  
  Only display some counters (regexp can be used).
  Example: --filter-counters='^status$'
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{state}, %{display}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING (default: '%{state} =~ /quiesced/i').
  You can use the following variables: %{state}, %{display}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '%{state} =~ /unknown|brokenOff|uninitialized/i').
  You can use the following variables: %{state}, %{display}
  
  =item B<--warning-lag>
  
  Warning threshold.
  
  =item B<--critical-lag>
  
  Critical threshold.
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPMIRRORLAG

$fatpacked{"storage/netapp/ontap/snmp/mode/snapshotage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPSHOTAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::snapshotage;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  use DateTime;
  
  my $oid_slvMonth = '.1.3.6.1.4.1.789.1.5.5.2.1.2';
  my $oid_slvDay = '.1.3.6.1.4.1.789.1.5.5.2.1.3';
  my $oid_slvHour = '.1.3.6.1.4.1.789.1.5.5.2.1.4';
  my $oid_slvMinutes = '.1.3.6.1.4.1.789.1.5.5.2.1.5';
  my $oid_slvName = '.1.3.6.1.4.1.789.1.5.5.2.1.6';
  my $oid_slvVolumeName = '.1.3.6.1.4.1.789.1.5.5.2.1.9';
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'name:s'     => { name => 'name' },
          'regexp'     => { name => 'use_regexp' },
          'warning:s'  => { name => 'warning' },
          'critical:s' => { name => 'critical' },
      });
      
      $self->{snapshot_id_selected} = [];
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  
      if (($self->{perfdata}->threshold_validate(label => 'warning', value => $self->{option_results}->{warning})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong warning threshold '" . $self->{option_results}->{warning} . "'.");
         $self->{output}->option_exit();
      }
      if (($self->{perfdata}->threshold_validate(label => 'critical', value => $self->{option_results}->{critical})) == 0) {
         $self->{output}->add_option_msg(short_msg => "Wrong critical threshold '" . $self->{option_results}->{critical} . "'.");
         $self->{output}->option_exit();
      }    
  }
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      $self->{result_names} = $self->{snmp}->get_table(oid => $oid_slvName, nothing_quit => 1);
      foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$self->{result_names}})) {
          next if ($oid !~ /\.([0-9]+\.[0-9]+)$/);
          my $instance = $1;
  
          # Get all without a name
          if (!defined($self->{option_results}->{name})) {
              push @{$self->{snapshot_id_selected}}, $instance; 
              next;
          }
          
          if (!defined($self->{option_results}->{use_regexp}) && $self->{result_names}->{$oid} eq $self->{option_results}->{name}) {
              push @{$self->{snapshot_id_selected}}, $instance; 
          }
          if (defined($self->{option_results}->{use_regexp}) && $self->{result_names}->{$oid} =~ /$self->{option_results}->{name}/) {
              push @{$self->{snapshot_id_selected}}, $instance;
          }
      }
  
      if (scalar(@{$self->{snapshot_id_selected}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No snapshot found for name '" . $self->{option_results}->{name} . "'.");
          $self->{output}->option_exit();
      }
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      $self->manage_selection();
      $self->{snmp}->load(oids => [$oid_slvName, $oid_slvMonth, $oid_slvDay, $oid_slvHour, $oid_slvMinutes, $oid_slvVolumeName],
                          instances => $self->{snapshot_id_selected},
                          instance_regexp => '(\d+\.\d+)$');
      my $result = $self->{snmp}->get_leef();
      
      if (!defined($self->{option_results}->{name}) || defined($self->{option_results}->{use_regexp})) {
          $self->{output}->output_add(severity => 'OK',
                                      short_msg => 'All snapshot age are ok.');
      }
  
      my $count = 0;
      my $now = time();
      foreach my $instance (sort @{$self->{snapshot_id_selected}}) {
          $count++;
          my $name = $self->{result_names}->{$oid_slvName . '.' . $instance};
          my $month = $result->{$oid_slvMonth . '.' . $instance};
          my $day = $result->{$oid_slvDay . '.' . $instance};
          my $hour = $result->{$oid_slvHour . '.' . $instance};
          my $minutes = $result->{$oid_slvMinutes . '.' . $instance};
          my $volume_name = $result->{$oid_slvVolumeName . '.' . $instance};
  
          my ($sec,$min,$hr,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
          $year = $year + 1900;     
          my $dt = DateTime->new(
                                  year       => $year,
                                  month      => $month,
                                  day        => $day,
                                  hour       => $hour,
                                  minute     => $minutes,
                                  second     => 0,
                                  time_zone  => 'local',
          );
          my $distant_time = $dt->epoch;
  
          my $age = $now - $distant_time;
  
          # Fix if snapshot was last year
          if ($age < 0) {
              $dt = DateTime->new(
                                  year       => $year - 1,
                                  month      => $month,
                                  day        => $day,
                                  hour       => $hour,
                                  minute     => $minutes,
                                  second     => 0,
                                  time_zone  => 'local',
              );
              $distant_time = $dt->epoch;
              $age = $now - $distant_time;
          }
  
          my $readable_age = centreon::plugins::misc::change_seconds(value => $age);
          $self->{output}->output_add(long_msg => sprintf("Snapshot '%s' age: %s [Volume: %s]", $name, $readable_age, $volume_name));
  
          my $exit = $self->{perfdata}->threshold_check(value => $age, threshold => [ { label => 'critical', 'exit_litteral' => 'critical' }, { label => 'warning', exit_litteral => 'warning' } ]);
          if (!$self->{output}->is_status(value => $exit, compare => 'ok', litteral => 1)) {
              $self->{output}->output_add(severity => $exit,
                                          short_msg => sprintf("Snapshot '%s' age: %s [Volume: %s]", $name, $readable_age, $volume_name));
          }
      }
      
      $self->{output}->perfdata_add(label => 'snapshots',
                                    value => $count,
                                    min => 0);
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapshot age of volumes.
  
  =over 8
  
  =item B<--warning>
  
  Warning threshold in seconds.
  
  =item B<--critical>
  
  Critical threshold in seconds.
  
  =item B<--name>
  
  Set the snapshot name.
  
  =item B<--regexp>
  
  Allows to use regexp to filter snapshot name (with option --name).
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPSHOTAGE

$fatpacked{"storage/netapp/ontap/snmp/mode/snapvaultusage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPVAULTUSAGE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::snapvaultusage;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold);
  use Digest::MD5 qw(md5_hex);
  
  sub custom_status_output { 
      my ($self, %options) = @_;
  
      my $msg = 'status : ' . $self->{result_values}->{status} . ' [state : ' . $self->{result_values}->{state} . ']';
      return $msg;
  }
  
  sub custom_status_calc {
      my ($self, %options) = @_;
  
      $self->{result_values}->{status} = $options{new_datas}->{$self->{instance} . '_svStatus'};
      $self->{result_values}->{state} = $options{new_datas}->{$self->{instance} . '_svState'};
      $self->{result_values}->{display} = $options{new_datas}->{$self->{instance} . '_display'};
      return 0;
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'snapvault', type => 1, cb_prefix_output => 'prefix_snapvault_output', message_multiple => 'All snapvault usages are ok', skipped_code => { -10 => 1, -11 => 1 } }
      ];
  
      $self->{maps_counters}->{snapvault} = [
          { label => 'status', threshold => 0, set => {
                  key_values => [ { name => 'svState' }, { name => 'svStatus' }, { name => 'display' } ],
                  closure_custom_calc => $self->can('custom_status_calc'),
                  closure_custom_output => $self->can('custom_status_output'),
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold,
              }
          },
          { label => 'lag', set => {
                  key_values => [ { name => 'svLag' }, { name => 'display' } ],
                  output_template => 'lag : %s seconds',
                  perfdatas => [
                      { label => 'lag', template => '%s', min => 0, unit => 's',
                        label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'transfer-traffic', set => {
                  key_values => [ { name => 'svTotalTransMBs', per_second => 1 }, { name => 'display' } ],
                  output_template => 'transfer traffic : %s %s/s',
                  output_change_bytes => 1,
                  perfdatas => [
                      { label => 'transfer_traffic', template => '%.2f',
                        unit => 'B/s', min => 0, label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'transfer-succeed', display_ok => 0, set => {
                  key_values => [ { name => 'svTotalSuccesses' }, { name => 'display' } ],
                  output_template => 'transfer succeed : %s',
                  perfdatas => [
                      { label => 'transfer_succeed', template => '%s', min => 0,
                        label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
          { label => 'transfer-failed', display_ok => 0, set => {
                  key_values => [ { name => 'svTotalFailures' }, { name => 'display' } ],
                  output_template => 'transfer failed : %s',
                  perfdatas => [
                      { label => 'transfer_failed', template => '%s', min => 0,
                        label_extra_instance => 1, instance_use => 'display' },
                  ],
              }
          },
      ];
  }
  
  sub prefix_snapvault_output {
      my ($self, %options) = @_;
  
      return "Snapvault '" . $options{instance_value}->{display} . "' ";
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options, statefile => 1);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
          'filter-name:s'     => { name => 'filter_name' },
          'unknown-status:s'  => { name => 'unknown_status', default => '' },
          'warning-status:s'  => { name => 'warning_status', default => '' },
          'critical-status:s' => { name => 'critical_status', default => '' },
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->change_macros(macros => ['warning_status', 'critical_status', 'unknown_status']);
  }
  
  my $map_status = {
      1 => 'idle', 2 => 'transferring', 3 => 'pending',
      4 => 'aborting', 6 => 'quiescing', 7 => 'resyncing',
      12 => 'paused',
  };
  
  my $map_state = {
      1 => 'uninitialized', 2 => 'snapvaulted',
      3 => 'brokenOff', 4 => 'quiesced',
      5 => 'source', 6 => 'unknown', 7 => 'restoring',
  };
  
  my $mapping = {
      svStatus            => { oid => '.1.3.6.1.4.1.789.1.19.11.1.4', map => $map_status }, 
      svState             => { oid => '.1.3.6.1.4.1.789.1.19.11.1.5', map => $map_state },
      svLag               => { oid => '.1.3.6.1.4.1.789.1.19.11.1.6' }, # timeticks
      svTotalSuccesses    => { oid => '.1.3.6.1.4.1.789.1.19.11.1.7' },
      svTotalFailures     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.9' },
      svTotalTransMBs     => { oid => '.1.3.6.1.4.1.789.1.19.11.1.11' },
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
      
      my $oid_svOn = '.1.3.6.1.4.1.789.1.19.1.0';
  
      my $snmp_result = $options{snmp}->get_leef(oids => [$oid_svOn]);
      if (!defined($snmp_result->{$oid_svOn}) || $snmp_result->{$oid_svOn} != 2) {
          $self->{output}->add_option_msg(short_msg => "snapvault is not turned on.");
          $self->{output}->option_exit();
      }
      
      my $oid_svSrc = '.1.3.6.1.4.1.789.1.19.11.1.2';
      my $oid_svDst = '.1.3.6.1.4.1.789.1.19.11.1.3';
      
      $self->{snapvault} = {};
      $snmp_result = $options{snmp}->get_multiple_table(oids => [{ oid => $oid_svSrc }, { oid => $oid_svDst }], return_type => 1, nothing_quit => 1);
      foreach my $oid (keys %{$snmp_result}) {
          next if ($oid !~ /^$oid_svSrc\.(.*)$/);
          my $instance = $1;
          my $name = $snmp_result->{$oid_svSrc . '.' . $instance} . '.' . $snmp_result->{$oid_svDst . '.' . $instance};
  
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $name !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping snapvault '" . $name . "'.", debug => 1);
              next;
          }
  
          $self->{snapvault}->{$instance} = { display => $name };
      }
  
      if (scalar(keys %{$self->{snapvault}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No entry found.");
          $self->{output}->option_exit();
      }
      
      $options{snmp}->load(oids => [
              map($_->{oid}, values(%$mapping)) 
          ],
          instances => [keys %{$self->{snapvault}}], instance_regexp => '^(.*)$');
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
      
      foreach (keys %{$self->{snapvault}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $_);
  
          $result->{svTotalTransMBs} *= 1024 * 1024;
          $result->{svLag} = int($result->{svLag} / 100);
          
          $self->{snapvault}->{$_} = { %{$self->{snapvault}->{$_}}, %$result };
      }
      
      $self->{cache_name} = "netapp_" . $self->{mode} . '_' . $options{snmp}->get_hostname()  . '_' . $options{snmp}->get_port() . '_' .
          (defined($self->{option_results}->{filter_counters}) ? md5_hex($self->{option_results}->{filter_counters}) : md5_hex('all')) . '_' .
          (defined($self->{option_results}->{filter_name}) ? md5_hex($self->{option_results}->{filter_name}) : md5_hex('all'));
  }
  
  1;
  
  
  =head1 MODE
  
  Check snapvault usage.
  
  =over 8
  
  =item B<--filter-name>
  
  Filter snapvault name (can be a regexp).
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{state}, %{status}, %{display}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{state}, %{status}, %{display}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '').
  You can use the following variables: %{state}, %{status}, %{display}
  
  =item B<--warning-*> B<--critical-*>
  
  Warning threshold.
  Can be:  'lag' (s), 'transfer-traffic' (B/s), 'transfer-succeed',
  'transfer-failed'.
  
  =back
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_MODE_SNAPVAULTUSAGE

$fatpacked{"storage/netapp/ontap/snmp/mode/temperature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_TEMPERATURE';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::temperature;
  
  use base qw(centreon::plugins::mode);
  
  use strict;
  use warnings;
  
  my %mapping_temperature = (
      1 => 'no',
      2 => 'yes'
  );
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $options{options}->add_options(arguments => {
      });
  
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::init(%options);
  }
  
  sub run {
      my ($self, %options) = @_;
      $self->{snmp} = $options{snmp};
  
      my $oid_envOverTemperature = '.1.3.6.1.4.1.789.1.2.4.1';
      my $oid_nodeName = '.1.3.6.1.4.1.789.1.25.2.1.1';
      my $oid_nodeEnvOverTemperature = '.1.3.6.1.4.1.789.1.25.2.1.18';
      my $results = $self->{snmp}->get_multiple_table(
          oids => [
              { oid => $oid_envOverTemperature },
              { oid => $oid_nodeName },
              { oid => $oid_nodeEnvOverTemperature }
          ],
          nothing_quit => 1
      );
      
      if (defined($results->{$oid_envOverTemperature}->{$oid_envOverTemperature . '.0'})) {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => 'Hardware temperature is ok.'
          );
          if ($mapping_temperature{$results->{$oid_envOverTemperature}->{$oid_envOverTemperature . '.0'}} eq 'yes') {
              $self->{output}->output_add(
                  severity => 'CRITICAL',
                  short_msg => 'Hardware temperature is over temperature range.'
              );
          }
      } else {
          $self->{output}->output_add(
              severity => 'OK',
              short_msg => 'Hardware temperature are ok on all nodes'
          );
          foreach my $oid ($self->{snmp}->oid_lex_sort(keys %{$results->{$oid_nodeEnvOverTemperature}})) {
              $oid =~ /^$oid_nodeEnvOverTemperature\.(.*)$/;
              my $instance = $1;
              my $name = $results->{$oid_nodeName}->{$oid_nodeName . '.' . $instance};
              my $temp = $results->{$oid_nodeEnvOverTemperature}->{$oid};
              $self->{output}->output_add(
                  long_msg => sprintf(
                      "hardware temperature on node '%s' is over range: '%s'", 
                      $name, $mapping_temperature{$temp}
                  )
              );
              if ($mapping_temperature{$temp} eq 'yes') {
                  $self->{output}->output_add(
                      severity => 'CRITICAL',
                      short_msg => sprintf("Hardware temperature is over temperature range on node '%s'", $name)
                  );
              }
          }
      }
      
      $self->{output}->display();
      $self->{output}->exit();
  }
  
  1;
  
  
  =head1 MODE
  
  Check if hardware is currently operating outside of its recommended temperature range.
  
  =over 8
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_TEMPERATURE

$fatpacked{"storage/netapp/ontap/snmp/mode/volumeoptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_MODE_VOLUMEOPTIONS';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::mode::volumeoptions;
  
  use base qw(centreon::plugins::templates::counter);
  
  use strict;
  use warnings;
  use centreon::plugins::templates::catalog_functions qw(catalog_status_threshold_ng);
  
  sub custom_options_threshold {
      my ($self, %options) = @_;
  
      my $status = catalog_status_threshold_ng($self, %options);
      if (!$self->{output}->is_status(value => $status, compare => 'ok', litteral => 1)) {
          $self->{instance_mode}->{global}->{failed}++;
      }
      return $status;
  }
  
  sub prefix_volume_output {
      my ($self, %options) = @_;
  
      return "Volume '" . $options{instance_value}->{display} . "' ";
  }
  
  sub set_counters {
      my ($self, %options) = @_;
  
      $self->{maps_counters_type} = [
          { name => 'volumes', type => 1, cb_prefix_output => 'prefix_volume_output', message_multiple => 'All volumes are ok', skipped_code => { -10 => 1 } },
          { name => 'global', type => 0 } # need to be after for counting failed
      ];
  
      $self->{maps_counters}->{volumes} = [
           { label => 'status', type => 2, set => {
                  key_values => [ { name => 'status' }, { name => 'display' } ],
                  output_template => "status is '%s'",
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => \&catalog_status_threshold_ng
              }
          },
          { label => 'options', type => 2, set => {
                  key_values => [ { name => 'options' }, { name => 'display' } ],
                  output_template => "options: '%s'",
                  closure_custom_perfdata => sub { return 0; },
                  closure_custom_threshold_check => $self->can('custom_options_threshold')
              }
          }
      ];
      
      $self->{maps_counters}->{global} = [
          { label => 'failed', display_ok => 0, set => {
                  key_values => [ { name => 'failed' } ],
                  output_template => 'Failed: %s',
                  perfdatas => [
                      { label => 'failed', template => '%s', min => 0 }
                  ]
              }
          }
      ];
  }
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
      
      $options{options}->add_options(arguments => {
          'filter-name:s'    => { name => 'filter_name' },
          'filter-vserver:s' => { name => 'filter_vserver' },
          'filter-status:s'  => { name => 'filter_status' }
      });
      
      return $self;
  }
  
  sub check_options {
      my ($self, %options) = @_;
      $self->SUPER::check_options(%options);
  
      $self->{test_option} = 0;
      foreach ('warning', 'unknown', 'critical') {
          $self->{test_option} = 1 if (defined($self->{option_results}->{$_ . '-options'}) && $self->{option_results}->{$_ . '-options'} ne '');
      }
  }
  
  my $mapping = {
      name    => { oid => '.1.3.6.1.4.1.789.1.5.8.1.2' }, # volName
      vserver => { oid => '.1.3.6.1.4.1.789.1.5.8.1.14' } # volVserver
  };
  my $mapping2 = {
      status  => { oid => '.1.3.6.1.4.1.789.1.5.8.1.5' }, # volState
      options => { oid => '.1.3.6.1.4.1.789.1.5.8.1.7' }  # volOptions
  };
  
  sub manage_selection {
      my ($self, %options) = @_;
  
      my $snmp_result = $options{snmp}->get_multiple_table(
          oids => [
              { oid => $mapping->{name}->{oid} },
              { oid => $mapping->{vserver}->{oid} }
          ],
          return_type => 1,
          nothing_quit => 1
      );
  
      $self->{volumes} = {};
      foreach my $oid (keys %$snmp_result) {
          next if ($oid !~ /\.([0-9]+)$/);
          my $instance = $1;
  
          my $result = $options{snmp}->map_instance(mapping => $mapping, results => $snmp_result, instance => $instance);
          my $name = defined($result->{vserver}) && $result->{vserver} ne '' ?
              $result->{vserver} . ':' . $result->{name} :
              $result->{name};
          if (defined($self->{option_results}->{filter_vserver}) && $self->{option_results}->{filter_vserver} ne '' &&
              $result->{vserver} !~ /$self->{option_results}->{filter_vserver}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $name . "': no matching filter.", debug => 1);
              next;
          }
          if (defined($self->{option_results}->{filter_name}) && $self->{option_results}->{filter_name} ne '' &&
              $result->{name} !~ /$self->{option_results}->{filter_name}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $name . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{volumes}->{$instance} = {
              display => $name
          };
      }
  
      if (scalar(keys %{$self->{volumes}}) <= 0) {
          $self->{output}->add_option_msg(short_msg => "No volume found.");
          $self->{output}->option_exit();
      }
  
      my $load_oids = [$mapping2->{status}->{oid}];
      push @$load_oids, $mapping2->{options}->{oid} if ($self->{test_option} == 1);
      $options{snmp}->load(oids => $load_oids, instances => [keys %{$self->{volumes}}]);
      $snmp_result = $options{snmp}->get_leef(nothing_quit => 1);
  
      $self->{global} = { failed => 0 };
      foreach (keys %{$self->{volumes}}) {
          my $result = $options{snmp}->map_instance(mapping => $mapping2, results => $snmp_result, instance => $_);
          if (defined($self->{option_results}->{filter_status}) && $self->{option_results}->{filter_status} ne '' &&
              $result->{status} !~ /$self->{option_results}->{filter_status}/) {
              $self->{output}->output_add(long_msg => "skipping '" . $self->{volumes}->{$_}->{display} . "': no matching filter.", debug => 1);
              next;
          }
  
          $self->{volumes}->{$_}->{status} = $result->{status};
          $self->{volumes}->{$_}->{options} = $result->{options};
      }
  }
  
  1;
  
  
  =head1 MODE
  
  Check options from volumes.
  
  =over 8
  
  =item B<--filter-vserver>
  
  Filter volumes by vserver name (can be a regexp).
  
  =item B<--filter-name>
  
  Filter on volume name (can be a regexp).
  
  =item B<--filter-status>
  
  Filter on volume status (can be a regexp).
  
  =item B<--unknown-status>
  
  Define the conditions to match for the status to be UNKNOWN (default: '').
  You can use the following variables: %{status}, %{display}
  
  =item B<--warning-status>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{status}, %{display}
  
  =item B<--critical-status>
  
  Define the conditions to match for the status to be CRITICAL (default: '').
  You can use the following variables: %{status}, %{display}
  
  =item B<--unknown-options>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{options}, %{display}
  
  =item B<--warning-options>
  
  Define the conditions to match for the status to be WARNING (default: '').
  You can use the following variables: %{options}, %{display}
  
  =item B<--critical-options>
  
  Define the conditions to match for the status to be CRITICAL (default: '').
  You can use the following variables: %{options}, %{display}
  
  =back
  
  =cut
      
STORAGE_NETAPP_ONTAP_SNMP_MODE_VOLUMEOPTIONS

$fatpacked{"storage/netapp/ontap/snmp/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STORAGE_NETAPP_ONTAP_SNMP_PLUGIN';
  #
  # Copyright 2024 Centreon (http://www.centreon.com/)
  #
  # Centreon is a full-fledged industry-strength solution that meets
  # the needs in IT infrastructure and application monitoring for
  # service performance.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  #
  
  package storage::netapp::ontap::snmp::plugin;
  
  use strict;
  use warnings;
  use base qw(centreon::plugins::script_snmp);
  
  sub new {
      my ($class, %options) = @_;
      my $self = $class->SUPER::new(package => __PACKAGE__, %options);
      bless $self, $class;
  
      $self->{version} = '1.0';
      $self->{modes} = {
          'aggregates'         => 'storage::netapp::ontap::snmp::mode::aggregates',
          'cache-age'          => 'storage::netapp::ontap::snmp::mode::cacheage',
          'cluster-nodes'      => 'storage::netapp::ontap::snmp::mode::clusternodes',
          'cp-statistics'      => 'storage::netapp::ontap::snmp::mode::cpstatistics',
          'cpuload'            => 'storage::netapp::ontap::snmp::mode::cpuload',
          'diskfailed'         => 'storage::netapp::ontap::snmp::mode::diskfailed',
          'failover'           => 'storage::netapp::ontap::snmp::mode::failover',
          'fan'                => 'storage::netapp::ontap::snmp::mode::fan',
          'filesys'            => 'storage::netapp::ontap::snmp::mode::filesys',
          'list-cluster-nodes' => 'storage::netapp::ontap::snmp::mode::listclusternodes',
          'list-filesys'       => 'storage::netapp::ontap::snmp::mode::listfilesys',
          'list-plexes'        => 'storage::netapp::ontap::snmp::mode::listplexes',
          'list-snapvault'     => 'storage::netapp::ontap::snmp::mode::listsnapvault',
          'global-status'      => 'storage::netapp::ontap::snmp::mode::globalstatus',
          'ndmpsessions'       => 'storage::netapp::ontap::snmp::mode::ndmpsessions',
          'nvram'              => 'storage::netapp::ontap::snmp::mode::nvram',
          'partnerstatus'      => 'storage::netapp::ontap::snmp::mode::partnerstatus',
          'plexes'             => 'storage::netapp::ontap::snmp::mode::plexes',
          'psu'                => 'storage::netapp::ontap::snmp::mode::psu',
          'quotas'             => 'storage::netapp::ontap::snmp::mode::quotas',
          'share-calls'        => 'storage::netapp::ontap::snmp::mode::sharecalls',
          'shelf'              => 'storage::netapp::ontap::snmp::mode::shelf',
          'sis'                => 'storage::netapp::ontap::snmp::mode::sis',
          'snapmirrorlag'      => 'storage::netapp::ontap::snmp::mode::snapmirrorlag',
          'snapshotage'        => 'storage::netapp::ontap::snmp::mode::snapshotage',
          'snapvault-usage'    => 'storage::netapp::ontap::snmp::mode::snapvaultusage',
          'temperature'        => 'storage::netapp::ontap::snmp::mode::temperature',
          'uptime'             => 'snmp_standard::mode::uptime',
          'volumeoptions'      => 'storage::netapp::ontap::snmp::mode::volumeoptions'
      };
  
      return $self;
  }
  
  1;
  
  
  =head1 PLUGIN DESCRIPTION
  
  Check Netapp ONTAP in SNMP.
  
  =cut
STORAGE_NETAPP_ONTAP_SNMP_PLUGIN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Copyright 2024 Centreon (http://www.centreon.com/)
#
# Centreon is a full-fledged industry-strength solution that meets
# the needs in IT infrastructure and application monitoring for
# service performance.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;
# Not perl embedded compliant at all
use FindBin;
use lib "$FindBin::Bin";
# use lib '/usr/lib/nagios/plugins/';

use centreon::plugins::script;

centreon::plugins::script->new()->run();
